Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./gatsby-ssr.tsx
========================================

export const onRenderBody = ({ setHtmlAttributes }: any) => {
  // Set the HTML language attribute
  setHtmlAttributes({ lang: "it" })
}
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./flake.nix
========================================

{
  description = "Gruppo Natura Lentiai Frontend workspace";

  inputs.nixpkgs.url = "github:nixos/nixpkgs/nixos-unstable";

  outputs = { self, nixpkgs }:
    let
      system = "x86_64-linux";
      pkgs = import nixpkgs { inherit system; };
    in {
      devShells.${system}.default = pkgs.mkShell {
        buildInputs = with pkgs; [
          nodejs_22
          python3
          gcc
          gnumake
          pkg-config
          # Librerie per i moduli nativi (Gatsby/Sanity)
          vips
        ];

        shellHook = ''
          # Invece di LD_LIBRARY_PATH, diciamo ai compilatori dove trovare le cose
          export PKG_CONFIG_PATH="${pkgs.vips.dev}/lib/pkgconfig"
          
          # Indichiamo a Sharp (usato da Gatsby) di usare la libvips di sistema di Nix
          export SHARP_IGNORE_GLOBAL_LIBVIPS=1
          
          echo "üåø Welcome to Gruppo Natura Lentiai Frontend workspace üåº"
          echo "‚úÖ Clean environment: System tools won't crash."
        '';
      };
    };
}Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./static/CNAME
========================================

grupponaturalentiai.itGenerated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./tsconfig.json
========================================

{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Enable incremental compilation */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./",                          /* Specify the folder for .tsbuildinfo incremental compilation files. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "esnext" /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */,
    "lib": [
      "dom",
      "esnext"
    ] /* Specify a set of bundled library declaration files that describe the target runtime environment. */,
    "jsx": "react" /* Specify what JSX code is generated. */,
    // "experimentalDecorators": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h' */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using `jsx: react-jsx*`.` */
    // "reactNamespace": "",                             /* Specify the object invoked for `createElement`. This only applies when targeting `react` JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */

    /* Modules */
    "module": "esnext" /* Specify what module code is generated. */,
    // "rootDir": "./",                                  /* Specify the root folder within your source files. */
    "moduleResolution": "node" /* Specify how TypeScript looks up a file from a given module specifier. */,
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like `./node_modules/@types`. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    "resolveJsonModule": true /* Enable importing .json files */,
    // "noResolve": true,                                /* Disallow `import`s, `require`s or `<reference>`s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from `node_modules`. Only applicable with `allowJs`. */

    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If `declaration` is true, also designates a file that bundles all .d.ts output. */
    // "outDir": "./",                                   /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have `@internal` in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like `__extends` in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing `const enum` declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
    // "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables `allowSyntheticDefaultImports` for type compatibility. */,
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true /* Ensure that casing is correct in imports. */,

    /* Type Checking */
    "strict": true /* Enable all strict type-checking options. */,
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied `any` type.. */
    // "strictNullChecks": true,                         /* When type checking, take into account `null` and `undefined`. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for `bind`, `call`, and `apply` methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "noImplicitThis": true,                           /* Enable error reporting when `this` is given the type `any`. */
    // "useUnknownInCatchVariables": true,               /* Type catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when a local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Include 'undefined' in index signature results */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true /* Skip type checking all .d.ts files. */
  },
  "include": [
    "./src/**/*",
    "./gatsby-node.ts",
    "./gatsby-config.ts",
    "./plugins/**/*"
  ]
}
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./package.json
========================================

{
  "name": "site-gruppo-natura-lentiai",
  "homepage": "https://grupponaturalentiai.github.io/Frontend",
  "version": "1.0.0",
  "private": true,
  "description": "site-gruppo-natura-lentiai",
  "author": "Andrea Nicolai",
  "keywords": [
    "gatsby"
  ],
  "scripts": {
    "develop": "gatsby develop",
    "start": "gatsby develop",
    "build": "gatsby build",
    "serve": "gatsby serve",
    "clean": "gatsby clean",
    "typecheck": "tsc --noEmit",
    "deploy": "npm run clean && gatsby build --prefix-paths && gh-pages -d public"
  },
  "dependencies": {
    "@portabletext/react": "^3.2.0",
    "@types/leaflet-routing-machine": "^3.2.8",
    "axios": "^1.7.9",
    "babel-plugin-styled-components": "^2.1.4",
    "file-loader": "^6.2.0",
    "framer-motion": "^12.0.6",
    "gatsby": "^5.14.1",
    "gatsby-plugin-google-fonts": "^1.0.1",
    "gatsby-plugin-image": "^3.14.0",
    "gatsby-plugin-manifest": "^5.14.0",
    "gatsby-plugin-react-helmet": "^6.14.0",
    "gatsby-plugin-react-leaflet": "^4.0.3",
    "gatsby-plugin-sharp": "^5.14.0",
    "gatsby-plugin-sitemap": "^6.14.0",
    "gatsby-plugin-styled-components": "^6.14.0",
    "gatsby-plugin-svgr": "^3.0.0-beta.0",
    "gatsby-source-filesystem": "^5.14.0",
    "gatsby-source-sanity": "^7.9.1",
    "gatsby-transformer-json": "^5.14.0",
    "gatsby-transformer-remark": "^6.14.0",
    "gatsby-transformer-sharp": "^5.14.0",
    "leaflet": "^1.9.3",
    "leaflet-css": "^0.1.0",
    "leaflet-routing-machine": "^3.2.12",
    "lodash": "^4.17.23",
    "normalize.css": "^8.0.1",
    "prettier": "^3.4.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-helmet": "^6.1.0",
    "react-leaflet": "^4.2.1",
    "styled-components": "^6.1.14"
  },
  "devDependencies": {
    "@types/leaflet": "^1.9.16",
    "@types/lodash": "^4.17.23",
    "@types/node": "^20.11.19",
    "@types/react": "^18.2.55",
    "@types/react-dom": "^18.2.19",
    "@types/react-helmet": "^6.1.11",
    "gh-pages": "^6.3.0",
    "typescript": "^5.3.3"
  }
}Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./gatsby-node.ts
========================================

import { GatsbyNode } from "gatsby"
import path from "path"

export const createPages: GatsbyNode["createPages"] = async ({
  graphql,
  actions,
  reporter,
}) => {
  const { createPage } = actions

  // Fetch all posts from Sanity (REMOTE)
  const allPosts = await graphql<any>(`
    query SourcingAllPosts {
      allSanityPost(sort: { publishedAt: DESC }) { 
        nodes {
          slug {
            current
          }
          title
        }
      }
    }
  `)

  const posts = allPosts?.data.allSanityPost.nodes

  if (!posts || posts.length === 0) {
    reporter.panicOnBuild("No posts found")
    return
  }

  // 1Ô∏è‚É£ Pagine statiche dei post (AGGIUNTA LOGICA PREV/NEXT)
  posts.forEach((post: any, index: number) => {
    // Essendo in ordine dal pi√π recente al pi√π vecchio:
    // Il precedente (pi√π vecchio) √® index + 1
    // Il successivo (pi√π recente) √® index - 1
    const prev = index === posts.length - 1 ? null : posts[index + 1]
    const next = index === 0 ? null : posts[index - 1]

    if (post.slug?.current) {
      createPage({
        path: post.slug.current,
        component: path.resolve("src/templates/post.tsx"),
        context: {
          slug: post.slug.current,
          prevSlug: prev?.slug?.current || null,
          prevTitle: prev?.title || null,
          nextSlug: next?.slug?.current || null,
          nextTitle: next?.title || null,
        },
      })
    }
  })
}
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./gatsby-config.ts
========================================

import type { GatsbyConfig } from "gatsby"

require("dotenv").config({
  path: `.env.${process.env.NODE_ENV}`,
})

const config: GatsbyConfig = {
  // pathPrefix: pathPrefix, // restore if we want to use the old https://grupponaturalentiai.github.io/Frontend
  siteMetadata: {
    title: `site-gruppo-natura-lentiai`,
    siteUrl: `https://grupponaturalentiai.it`,
  },
  // More easily incorporate content into your pages through automatic TypeScript type generation and better GraphQL IntelliSense.
  // If you use VSCode you can also use the GraphQL plugin
  // Learn more at: https://gatsby.dev/graphql-typegen
  graphqlTypegen: true,
  plugins: [
    {
      resolve: "gatsby-source-sanity",
      options: {
        projectId: "ze02ljgl",
        dataset: "post-blog",
        useCdn: false,
        watchMode: process.env.LOCAL === "true",
      },
    },
    "gatsby-plugin-image",
    "gatsby-plugin-sharp",
    "gatsby-transformer-sharp",
    "gatsby-plugin-styled-components",
    {
      resolve: `gatsby-plugin-sitemap`,
      options: {
        output: `/sitemap.xml`,
        resolveSiteUrl: () => `https://grupponaturalentiai.it`,
      },
    },
    {
      resolve: "gatsby-plugin-manifest",
      options: {
        icon: "src/icons/LogoFavicon.svg",
        // start_url: `/Frontend/`,  // old https://grupponaturalentiai.github.io/Frontend
        cache_busting_mode: "none",
        start_url: "/",
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `data`, // General name for JSON data
        path: `${__dirname}/src/data/`, // Path to folder containing JSON files
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `images`, // For image files
        path: `${__dirname}/src/images/`, // Path to folder containing images
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `logos`,
        path: `${__dirname}/src/logos/`,
      },
    },
    `gatsby-transformer-json`,
    `gatsby-transformer-remark`,
    {
      resolve: `gatsby-plugin-svgr`,
      options: {
        svgo: true,
        svgoConfig: {
          plugins: [
            { name: "removeViewBox", active: false },
            { name: "removeDimensions", active: true },
          ],
        },
        prettier: true,
        titleProp: true,
      },
    },
    {
      resolve: "gatsby-plugin-react-leaflet",
      options: {
        linkStyles: true,
      },
    },
    {
      resolve: `gatsby-plugin-google-fonts`,
      options: {
        fonts: [
          `Funnel Sans:ital,wght@0,300..800;1,300..800`, // Funnel Sans
          `Condiment`, // Condiment
          `Caveat:wght@400..700`, // Caveat
          `Cedarville Cursive`, // Cedarville Cursive
        ],
        display: "swap", // improves loading performance
      },
    },
  ],
}

export default config
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./.prettierrc
========================================

semi: false
arrowParens: avoid
singleQuote: false
trailingComma: all
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./README.md
========================================

# üåø Gruppo Natura Lentiai - Sito Ufficiale

Benvenuto nel repository frontend del sito ufficiale dell'associazione **Gruppo Natura Lentiai**.
Il sito √® progettato per essere super-veloce, accessibile e facilmente aggiornabile grazie a un'architettura **Jamstack** basata su Gatsby e Sanity CMS.

üåê **Sito Live:** [grupponaturalentiai.it](https://grupponaturalentiai.it)

---

## üõ† Tech Stack

- **Framework:** [Gatsby](https://www.gatsbyjs.com/) (React) - Generazione di siti statici (SSG) per performance ottimali.
- **Linguaggio:** [TypeScript](https://www.typescriptlang.org/) - Per codice tipizzato e sicuro.
- **Styling:** [Styled Components](https://styled-components.com/) - CSS-in-JS.
- **CMS (Headless):** [Sanity.io](https://www.sanity.io/) - Gestione dei contenuti del Blog tramite query GraphQL.
- **Mappe:** [React Leaflet](https://react-leaflet.js.org/) - Mappe interattive per i percorsi dell'associazione.
- **Automazione:** [GitHub Actions](https://github.com/features/actions) - Build e deploy automatici e gratuiti.

---

## üöÄ Sviluppo Locale

Se vuoi contribuire al codice sorgente o testare modifiche in locale, segui questi passaggi.

### 1. Prerequisiti
Assicurati di avere installato sul tuo computer:
- **Node.js** (Versione 20 o superiore consigliata)
- **npm** (incluso in Node.js)

### 2. Installazione
Clona il repository e installa le dipendenze:
```bash
git clone [https://github.com/GruppoNaturaLentiai/Frontend.git](https://github.com/GruppoNaturaLentiai/Frontend.git)
cd Frontend
npm ci
```

### 3. Avvio del server di sviluppo

Per avviare l'ambiente di sviluppo locale con hot-reloading:

```bash
npm run develop
```

Il sito sar√† visibile all'indirizzo: `http://localhost:8000`
L'interfaccia di esplorazione GraphQL sar√† disponibile su: `http://localhost:8000/___graphql`

---

## üèó Architettura e Deploy

Il sito √® ospitato gratuitamente su **GitHub Pages** (sul branch `gh-pages`).
Non √® necessario eseguire script di build o deploy manuali dal proprio computer. Il processo √® interamente automatizzato tramite **GitHub Actions** (`.github/workflows/deploy.yml`).

Il deploy automatico viene attivato in due scenari:

1. **Modifiche al codice:** Quando una Pull Request viene unita (merged) al branch `main`.
2. **Pubblicazione Articoli:** Quando un redattore pubblica, modifica o elimina un articolo dall'interfaccia di Sanity CMS (tramite Webhook che invia l'evento `sanity-publish`).

Il processo di build utilizza un sistema di **Cache** per le immagini processate da Gatsby e per i pacchetti `npm`, riducendo i tempi di compilazione da 20 minuti a pochi minuti.

---

## üìÅ Struttura principale del Progetto

* `/src/components` - Componenti React riutilizzabili (Header, Footer, UI, ecc.).
* `/src/pages` - Pagine statiche principali del sito (es. index, blog, chi-siamo, contatti).
* `/src/templates` - Template dinamici generati a tempo di build (es. `post.tsx` per i singoli articoli del blog).
* `/src/data` - Dati statici JSON, coordinate dei tracciati GPS e percorsi mappa.
* `/src/styles` - Variabili globali CSS, breakpoints, palette colori (i "verdi" di GNL).
* `/gatsby-node.ts` - Logica di back-end di Gatsby per la creazione programmatica delle pagine recuperando i dati da Sanity.
* `/.github/workflows` - File di configurazione delle pipeline CI/CD.

---

## ü§ù Crediti e Copyright

Sviluppato e mantenuto per **Gruppo Natura Lentiai**.
¬© Copyright Andrea Nicolai - Tutti i diritti riservati.Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./flake.lock
========================================

{
  "nodes": {
    "nixpkgs": {
      "locked": {
        "lastModified": 1771369470,
        "narHash": "sha256-0NBlEBKkN3lufyvFegY4TYv5mCNHbi5OmBDrzihbBMQ=",
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "0182a361324364ae3f436a63005877674cf45efb",
        "type": "github"
      },
      "original": {
        "owner": "nixos",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "nixpkgs": "nixpkgs"
      }
    }
  },
  "root": "root",
  "version": 7
}
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./.gitignore
========================================

node_modules/
.cache/
public
src/gatsby-types.d.ts
docs/
.direnv/Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./.prettierignore
========================================

docs/
public/
.cache/
node_modules/Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./generate_context.sh
========================================

#!/bin/bash

find . -type f \
  -not -path "*/node_modules/*" \
  -not -path "*/.git/*" \
  -not -path "*/.cache/*" \
  -not -path "*/public/*" \
  -not -path "*/.gatsby/*" \
  -not -path "*/.direnv/*" \
  -not -path "*/.github/*" \
  -not -path "./content/*" \
  -not -name "package-lock.json" \
  -not -name "yarn.lock" \
  -not -name "*.png" \
  -not -name "*.jpg" \
  -not -name "*.jpeg" \
  -not -name "*.svg" \
  -not -name "*.ico" \
  -not -name "*.woff*" \
  -not -name "*.ttf" \
  -not -name ".env*" \
  -not -name "context_for_llm.txt" \
  -exec echo -e "Generated at $(date)" \; \
  -exec echo -e "\n========================================\nFILE: {}\n========================================\n" \; \
  -exec cat {} \; > context_for_llm.txt

echo "‚úÖ Fatto! Il contesto √® stato salvato in 'context_for_llm.txt'"
echo "‚ö†Ô∏è  Attenzione: Se il file √® molto grande, incollalo in pi√π parti."Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/data/contacts.json
========================================

{
  "phone": ["+39", "371", "184", "7744"],
  "email": ["gruppo", "natura", "lentiai", "@", "libero", ".", "it"],
  "youtube": "https://www.youtube.com/channel/UCbP1HqPAvI5Ofoatb9MzZmQ",
  "facebook-laghetti": "https://www.facebook.com/profile.php?id=100064320537208",
  "facebook-narcisi": "https://www.facebook.com/profile.php?id=100069990139319"
}
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/data/sustain-us.json
========================================

{
  "IBAN": {
    "bank": "FPB CASSA RURALE LENTIAI",
    "account": "IT07 U081 4005 8650 0003 1160 657"
  }
}
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/data/imageMetadata.json
========================================

[
  {
    "title": "Mappa dei laghetti della Rimonta",
    "description": "Mappa dei laghetti della Rimonta",
    "alt": "Mappa dei laghetti della Rimonta",
    "tags": [
      "laghetti",
      "laghetti-mappe",
      "mappe"
    ],
    "fileName": "laghetti-mappa.png",
    "copyright": ""
  },
  {
    "title": "Bardies - Catasto asburgico (1818-1829)",
    "description": "Una mappa del catasto austriaco risalente al 1830 ci riporta l‚Äôimmagine di un paese sulla sponda di un ragguardevole corso d‚Äôacqua, a difesa del quale appaiono una serie di strutture costiere. ",
    "alt": "Foto tratta dal catasto asburgico in cui compare Bardies (Borgo Valbelluna)",
    "tags": [
      "laghetti",
      "laghetti-storia"
    ],
    "fileName": "CatastoAsburgo1818-1829.jpg",
    "copyright": ""
  },
  {
    "title": "Bardies",
    "description": "Bardies (Borgo Valbelluna) e la sua piazza",
    "alt": "Foto storica di Bardies (Borgo Valbelluna) con la piazza",
    "tags": [
      "laghetti",
      "laghetti-storia"
    ],
    "fileName": "Bardies00.jpg",
    "copyright": ""
  },
  {
    "title": "Bardies",
    "description": "Il ponte sul torrente Rimonta. Sulla sinistra si nota la chiesa Sant'Antonio Abate di Bardies, mentre sulla destra l'attuale albergo 'Cavallino Rosso'",
    "alt": "Foto storica di Bardies (Borgo Valbelluna) con un ponte l'albergo 'Cavallino Rosso'",
    "tags": [
      "laghetti",
      "laghetti-storia"
    ],
    "fileName": "Bardies01.jpg",
    "copyright": ""
  },
  {
    "title": "Rimontarte",
    "description": "Logo di Rimontarte",
    "alt": "Rimontarte Logo",
    "tags": [
      "laghetti-rimontarte"
    ],
    "fileName": "rimontarte-logo.png",
    "copyright": ""
  },
  {
    "title": "",
    "description": "Un pettirosso",
    "alt": "Foto di un pettirosso",
    "tags": [
      "laghetti",
      "laghetti-natura"
    ],
    "fileName": "rimonta-pettirosso.png",
    "copyright": "Riccardo Deon"
  },
  {
    "title": "",
    "description": "Un cervo",
    "alt": "Foto di un cervo",
    "tags": [
      "laghetti",
      "laghetti-natura"
    ],
    "fileName": "rimonta-cervo.png",
    "copyright": "Riccardo Deon"
  },
  {
    "title": "",
    "description": "Una forra",
    "alt": "Foto di una forra",
    "tags": [
      "laghetti",
      "laghetti-natura"
    ],
    "fileName": "rimonta-canyon.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "Panorama delle prealpi di Lentiai",
    "alt": "Foto di un panorama collinare di Lentiai",
    "tags": [
      "laghetti",
      "laghetti-natura"
    ],
    "fileName": "rimonta-bacino.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "Panorama dei laghetti della Rimonta",
    "alt": "Panorama con un lago e un cigno",
    "tags": [
      "laghetti",
      "laghetti-natura"
    ],
    "fileName": "rimonta-panorama.jpg",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "La vegetazione subacquea",
    "alt": "Foto subacquea con alcune piante",
    "tags": [
      "laghetti",
      "laghetti-natura"
    ],
    "fileName": "rimonta-underwater.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "<b>Walter Bernardi</b> - La via dell'acqua",
    "description": "",
    "alt": "Murales di Walter Bernardi",
    "tags": [
      "laghetti",
      "laghetti-rimontarte"
    ],
    "fileName": "rimontarte-01-la-via-dell-acqua.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "<b>Bruno Corriani</b> - La libellula",
    "description": "",
    "alt": "Scultura in ferro di una libellula fatta da Bruno Corriani",
    "tags": [
      "laghetti",
      "laghetti-rimontarte"
    ],
    "fileName": "rimontarte-02-la-libellula.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "<b>Mauro Ricci</b> - Il cervo volante",
    "description": "",
    "alt": "Scultura in ferro di un cervo volante eseguita da Mauro Ricci",
    "tags": [
      "laghetti",
      "laghetti-rimontarte"
    ],
    "fileName": "rimontarte-03-il-cervo-volante.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "<b>Andrea Gaspari</b> - Rufus il drago",
    "description": "",
    "alt": "Scultura in legno eseguita da Andrea Gaspari di un drago immerso in un laghetto e nascosto da un canneto",
    "tags": [
      "laghetti",
      "laghetti-rimontarte"
    ],
    "fileName": "rimontarte-04-rufus-il-drago.jpg",
    "copyright": "Walter Argenta"
  },
  {
    "title": "<b>Ezio Giordano</b> - Lo gnomo",
    "description": "",
    "alt": "Scultura in legno eseguita da Ezio Giordano di uno gnomo con una chiocciola sopra.",
    "tags": [
      "laghetti",
      "laghetti-rimontarte"
    ],
    "fileName": "rimontarte-05-lo-gnomo.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "<b>Franco Vergerio</b> - La ragnatela",
    "description": "",
    "alt": "Scultura in legno e corda di Franco Vergerio, raffigurante una ragnatela sospesa fra due alberi ed un ragno.",
    "tags": [
      "laghetti",
      "laghetti-rimontarte"
    ],
    "fileName": "rimontarte-06-la-ragnatela.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "<b>Artisti vari</b> - La rinascita",
    "description": "",
    "alt": "Una scultura su un ceppo di legno raffigurante un fiore",
    "tags": [
      "laghetti",
      "laghetti-rimontarte"
    ],
    "fileName": "rimontarte-07-la-rinascita.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "<b>Artisti vari</b> - La rinascita",
    "description": "",
    "alt": "Alcune opere d'arte su base di ceppi di legno",
    "tags": [
      "laghetti",
      "laghetti-rimontarte"
    ],
    "fileName": "rimontarte-07-la-rinascita-bis.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "<b>Beppino Lorenzet</b> - Il folletto",
    "description": "",
    "alt": "Una scultura di legno eseguita da Beppino lorenzet di uno gnomo che si arrampica su una corda ed un gufo sulla spalla.",
    "tags": [
      "laghetti",
      "laghetti-rimontarte"
    ],
    "fileName": "rimontarte-08-il-folletto.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "<b>Sara Andrich</b> - Il nido",
    "description": "",
    "alt": "Una scultura eseguita da Sara Andrich di un nido con degli uccellini col il becco aperto arancione.",
    "tags": [
      "laghetti",
      "laghetti-rimontarte"
    ],
    "fileName": "rimontarte-09-il-nido.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "<b>Beppino Lorenzet</b> - Il fungo",
    "description": "",
    "alt": "Una scultura eseguita da Beppino Lorenzed di un fungo.",
    "tags": [
      "laghetti",
      "laghetti-rimontarte"
    ],
    "fileName": "rimontarte-10-il-fungo.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "<b>Gianni Stiletto e Franco Vergerio</b> - Concerto con coro di farfalle",
    "description": "",
    "alt": "Un'installazione di ideata e creata da Franco Vergerio raffigurante un contrabbasso, sopra il quale sono posizionate delle farfalle create da Gianni Stiletto.",
    "tags": [
      "laghetti",
      "laghetti-rimontarte"
    ],
    "fileName": "rimontarte-11-concerto-con-coro-di-farfalle.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "<b>Luca Lisot</b> - La rana",
    "description": "",
    "alt": "Una scultura di legno raffigurante una rana creata da Luca Lisot.",
    "tags": [
      "laghetti",
      "laghetti-rimontarte"
    ],
    "fileName": "rimontarte-12-la-rana.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "",
    "alt": "Una passerella in legno con dietro il torrente Rimonta",
    "tags": [
      "laghetti",
      "laghetti-main"
    ],
    "fileName": "rimonta-cover-01-old.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "",
    "alt": "Un panorama invernale dei laghetti della Rimonta",
    "tags": [
      "laghetti",
      "laghetti-main"
    ],
    "fileName": "rimonta-cover-02-old.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "Panoramica dell'interno della chiesa di Bardies in cui sono visibili pareti affrescate.",
    "alt": "Panoramica dell'interno della chiesa di Bardies",
    "tags": [
      "laghetti",
      "laghetti-storia"
    ],
    "fileName": "bardies-chiesa-00.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "Particolare di un affresco raffigurante Sant'Antonio Abate.",
    "alt": "Particolare di un affresco raffigurante Sant'Antonio Abate",
    "tags": [
      "laghetti",
      "laghetti-storia"
    ],
    "fileName": "bardies-chiesa-01.png",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "Sottostante al ponte si trovano le acque del torrente Forada.",
    "alt": "L'arcata inferiore del ponte romano in cui si intravedono le acque del torrente Forata",
    "tags": [
      "laghetti",
      "laghetti-storia"
    ],
    "fileName": "ponte_00.jpg",
    "copyright": "Alida Cavalet"
  },
  {
    "title": "",
    "description": "L'ultima azione di restauro del ponte risale al 2016.",
    "alt": "Un ponte romano con un telo che ne protegge la parte superiore",
    "tags": [
      "laghetti",
      "laghetti-storia"
    ],
    "fileName": "ponte_01.jpeg",
    "copyright": ""
  },
  {
    "title": "",
    "description": "",
    "alt": "Una foto artistica di uno scorcio su un lago",
    "tags": [
      "laghetti",
      "laghetti-main"
    ],
    "fileName": "rimonta-cover-01.jpg",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "",
    "alt": "Un panorama invernale dei laghetti della Rimonta con alberi innevati",
    "tags": [
      "laghetti",
      "laghetti-main"
    ],
    "fileName": "rimonta-cover-02.jpg",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "Laghetti d'inverno. Si intravede Rufus il Drago",
    "alt": "Panorama invernale dei laghetti. Si intravede l'opera di legno \"Rufus il Drago\"",
    "tags": [
      "laghetti"
    ],
    "fileName": "Laghetti02.jpg",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "Il sentiero dei Laghetti attraversa una radura. Sullo sfondo le Dolomiti.",
    "alt": "Panoramica del sentiero che attraversa una radura. Si vede una persona in piedi e le Dolomiti sullo sfondo.",
    "tags": [
      "laghetti"
    ],
    "fileName": "Laghetti06.jpg",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "Durante il percorso si possono trovare pannelli informativi affiancati alle opere d'arte.",
    "alt": "Una persona di spalle sta leggendo un pannello informativo. A fianco, uno dei ceppi scolpiti facente parte del gruppo di opere \"La Rinascita\".",
    "tags": [
      "laghetti"
    ],
    "fileName": "Laghetti07.jpg",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "Sul percorso dei laghetti della Rimonta si sfruttano passerelle di legno.",
    "alt": "Una passerella di legno",
    "tags": [
      "laghetti"
    ],
    "fileName": "Laghetti08.jpg",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "Prato costellato di narcisi durante il periodo della fioritura.",
    "alt": "Un prato di narcisi bianchi al tramonto. Sullo sfondo a destra degli alberi e un recinto.",
    "tags": [
      "narcisi"
    ],
    "fileName": "Fioritura01.jpg",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "Durante la fioritura dei narcisi i prati si tingono di bianco. Sullo sfondo la Valbelluna coperta dalle nuvole e le cime delle dolomiti innevate.",
    "alt": "Un panorama con un prato di narcisi bianchi. Sullo sfondo la Valbelluna coperta dalle nuvole e le cime delle dolomiti innevate.",
    "tags": [
      "narcisi",
      "main"
    ],
    "fileName": "Fioritura02.jpg",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "Alcuni narcisi in primo piano. Sullo sfondo la Valbelluna e le Dolomiti bellunesi.",
    "alt": "Alcuni narcisi in primo piano. Sullo sfondo la Valbelluna e le Dolomiti bellunesi.",
    "tags": [
      "narcisi"
    ],
    "fileName": "Fioritura03.jpg",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "I prati sembrano innevati durante la fioritura dei Narcisi. Sullo sfondo il monte Avena.",
    "alt": "Un prato con molti narcisi bianchi. Sullo sfondo alcune montagne",
    "tags": [
      "narcisi"
    ],
    "fileName": "Fioritura04.jpg",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "Panorama di prati con narcisi in fiore. Sullo sfondo Col Moscher e Malga Garda. Continuando si pu√≤ scendere fino a Malga Mariech, Milies e infine Valdobbiadene.",
    "alt": "Un prato con alcuni narcisi e sullo sfondo le Prealpi Bellunesi.",
    "tags": [
      "narcisi"
    ],
    "fileName": "Fioritura05.jpg",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "Il Principe Bianco.",
    "alt": "Un primo piano di una coppia di Narcisi incorniciati da fiori volgarmente detti \"Botton d'oro\".",
    "tags": [
      "narcisi"
    ],
    "fileName": "Fioritura06.jpg",
    "copyright": "Walter Argenta"
  },
  {
    "title": "",
    "description": "",
    "alt": "Un prato con molti narcisi e le Prealpi bellunesi sullo sfondo.",
    "tags": [
      "narcisi"
    ],
    "fileName": "Fioritura07.jpg",
    "copyright": "Walter Argenta"
  },
  {
    "title": "Chi siamo",
    "description": "Il Maestro Franco Vergerio mentre restaura la statua di Rufus il drago",
    "alt": "Un uomo che ristruttura una statua d'inverno",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_000.jpeg",
    "copyright": "Orfeo Dal Piva"
  },
  {
    "title": "Chi siamo",
    "description": "I volontari si occupano di tenere pulito il sentiero dei laghetti della Rimonta",
    "alt": "Un uomo che taglia un tronco con una motosega",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_001.jpeg",
    "copyright": "Orfeo Dal Piva"
  },
  {
    "title": "Chi siamo",
    "description": "",
    "alt": "Un uomo su una scala sta montando la scultura de \"La ragnatela\"",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_002.jpeg",
    "copyright": "Orfeo Dal Piva"
  },
  {
    "title": "Chi siamo",
    "description": "Alcuni volontari",
    "alt": "Alcuni volontari del GNL",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_003.jpeg",
    "copyright": ""
  },
  {
    "title": "Chi siamo",
    "description": "Alcuni volontari",
    "alt": "Un folto gruppo di volontari del GNL",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_004.jpeg",
    "copyright": ""
  },
  {
    "title": "Chi siamo",
    "description": "Alcuni volontari",
    "alt": "Un volontario si occupa della sostituzione di pannelli informativi lungo il sentiero dei Laghetti della Rimonta",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_005.jpeg",
    "copyright": "Orfeo Dal Piva"
  },
  {
    "title": "Chi siamo",
    "description": "I volontari si occupano della bonifica dell'ecosistema dei Laghetti",
    "alt": "Alcuni volontari  si occupano della bonifica dell'ecosistema dei Laghetti togliendo il fango con alcuni secchi",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_006.jpeg",
    "copyright": ""
  },
  {
    "title": "Chi siamo",
    "description": "",
    "alt": "Un volontario sorride seduto su un trattore",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_007.jpeg",
    "copyright": ""
  },
  {
    "title": "Chi siamo",
    "description": "",
    "alt": "Un paio di volontari mostrano i nuovi pannelli informativi del percorso dei Laghetti della Rimonta",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_008.jpeg",
    "copyright": ""
  },
  {
    "title": "Chi siamo",
    "description": "Un momento di convivialit√†",
    "alt": "Un uomo versa della birra in un bicchiere ad un'altra persona",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_009.jpeg",
    "copyright": "Orfeo Dal Piva"
  },
  {
    "title": "Chi siamo",
    "description": "I volontari si occupano di tenere pulito il sentiero dei Laghetti della Rimonta",
    "alt": "Un paio di volontari stanno tagliando con una motosega un albero caduto che ostruisce il percorso",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_010.jpeg",
    "copyright": ""
  },
  {
    "title": "Chi siamo",
    "description": "Alcuni volontari aiutano a montare l'opera \"Concerto con coro di farfalle\"",
    "alt": "Un paio di volontari stanno tagliando con una motosega un albero caduto che ostruisce il percorso",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_011.jpeg",
    "copyright": ""
  },
  {
    "title": "Chi siamo",
    "description": "I volontari si occupano della manutenzione delle passerelle del sentiero dei Laghetti della Rimonta",
    "alt": "Un uomo √® chino a riparare una passerella in legno",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_012.jpeg",
    "copyright": "Orfeo Dal Piva"
  },
  {
    "title": "Chi siamo",
    "description": "Alcuni volontari in Col D'Artent",
    "alt": "Un gruppo di volontari in montagna",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_013.jpeg",
    "copyright": "Orfeo Dal Piva"
  },
  {
    "title": "Chi siamo",
    "description": "Alcuni volontari durante le domeniche di fioritura del Narciso",
    "alt": "Un paio seduti di uomini sotto un gazebo informativo in Col D'Artent",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_014.jpeg",
    "copyright": ""
  },
  {
    "title": "Chi siamo",
    "description": "Alcuni volontari del GNL durante le domeniche di fioritura del Narciso",
    "alt": "Alcuni uomini sotto un gazebo informativo in Col D'Artent",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_016.jpeg",
    "copyright": ""
  },
  {
    "title": "Chi siamo",
    "description": "Un volontario si occupa di fare la \"meda\" durante la fienagione.",
    "alt": "Un uomo durante la fienagione butta del fieno sopra un cumulo di fieno con una forca.",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_015.jpeg",
    "copyright": ""
  },
  {
    "title": "Chi siamo",
    "description": "I volontari del GNL durante le giornate di estirpazione del veratro in Col D'Artent.",
    "alt": "Alcuni volontari su una collina si occupano di estirpare il veratro, pianta infestante, in Col D'Artent",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_017.jpeg",
    "copyright": ""
  },
  {
    "title": "Chi siamo",
    "description": "",
    "alt": "Un uomo su un cumulo di fieno",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_018.jpeg",
    "copyright": ""
  },
  {
    "title": "Chi siamo",
    "description": "Periodicamente i volontari si occupano di organizzare Giornate Ecologiche per la pulizia dell'ambiente.",
    "alt": "Alcuni volontari con giubbotti arancioni durante una giornata ecologica",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_019.jpeg",
    "copyright": ""
  },
  {
    "title": "Chi siamo",
    "description": "I volontari del GNL dopo aver estirpato il veratro in Col D'Artent.",
    "alt": "Un gruppo di persone dopo aver estirpato il veratro in col D'Artent",
    "tags": [
      "chi-siamo"
    ],
    "fileName": "chi-siamo_020.jpg",
    "copyright": "Orfeo Dal Piva"
  },
  {
    "title": "Anello Ciclo-Pedonale di Lentiai",
    "description": "Informazioni utili sull'anello ciclopedonale di Lentiai",
    "alt": "Informazioni utili sull'anello ciclopedonale di Lentiai",
    "tags": [
      "mobilit√†"
    ],
    "fileName": "anello-ciclopedonale-lentiai-00.jpeg",
    "copyright": "Gruppo Natura Lentiai"
  },
  {
    "title": "Anello Ciclo-Pedonale di Lentiai",
    "description": "Cartina dell'anello ciclopedonale di Lentiai",
    "alt": "Cartina dell'anello ciclopedonale di Lentiai",
    "tags": [
      "mobilit√†"
    ],
    "fileName": "anello-ciclopedonale-lentiai-01.jpeg",
    "copyright": "Gruppo Natura Lentiai"
  },
  {
    "title": "Mappa dell'area",
    "description": "Cartina con la zona di fioritura dei narcisi sul Monte Avena",
    "alt": "Cartina del percorso dei narcisi in localit√† Monte Avena",
    "tags": [
      "narcisi-valbelluna",
      "narcisi"
    ],
    "fileName": "narcisi_valbelluna_avena_map.jpeg",
    "copyright": ""
  },
  {
    "title": "La fioritura dei Narcisi sul monte Avena",
    "description": "La fioritura dei Narcisi sul monte Avena",
    "alt": "",
    "tags": [
      "narcisi-valbelluna",
      "narcisi"
    ],
    "fileName": "narcisi_valbelluna_avena_pic.jpeg",
    "copyright": "Antonella Cossa"
  },
  {
    "title": "Mappa dell'area",
    "description": "Cartina con la zona di fioritura dei narcisi in localit√† Castron - Praderadego",
    "alt": "Cartina del percorso dei narcisi in localit√† Castron",
    "tags": [
      "narcisi-valbelluna"
    ],
    "fileName": "narcisi_valbelluna_castron_map.jpeg",
    "copyright": ""
  },
  {
    "title": "Mappa dell'area",
    "description": "Cartina con la zona di fioritura dei narcisi in localit√† Le Lei - Lamon",
    "alt": "Cartina del percorso dei narcisi in localit√† Le Lei - Lamon",
    "tags": [
      "narcisi-valbelluna"
    ],
    "fileName": "narcisi_valbelluna_le_lei_map.jpeg",
    "copyright": ""
  },
  {
    "title": "La fioritura dei Narcisi in localit√† Le Lei - Lamon",
    "description": "La fioritura dei Narcisi in localit√† Le Lei - Lamon",
    "alt": "",
    "tags": [
      "narcisi-valbelluna",
      "narcisi"
    ],
    "fileName": "narcisi_valbelluna_le_lei_pic.jpeg",
    "copyright": "Mamma Gloria (account FB)"
  }
]Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/data/paths/laghetti.ts
========================================

import { colors } from "../../styles"

const paths = [
  {
    legend: "Parcheggio - Inizio percorso",
    key: "park-laghetti-start",
    path: [
      [46.04685, 12.02487],
      [46.04637, 12.02511],
      [46.04627, 12.02529],
      [46.04627, 12.02547],
      [46.04636, 12.02612],
      [46.04603, 12.02633],
      [46.04559, 12.02653],
      [46.04515, 12.02685],
      [46.04518, 12.0271],
      [46.04521, 12.02727],
      [46.04529, 12.02762],
      [46.04533, 12.02764],
      [46.04545, 12.02786],
      [46.04558, 12.02794],
      [46.04567, 12.02795],
      [46.0457, 12.02783],
      [46.04571, 12.02769],
      [46.04571, 12.0276],
      [46.04572, 12.02747],
      [46.04576, 12.0274],
      [46.04599, 12.02733],
      [46.04625, 12.02724],
      [46.04644, 12.02711],
      [46.04678, 12.02703],
      [46.04697, 12.02695],
      [46.04716, 12.02694],
      [46.04752, 12.02676],
      [46.04779, 12.02666],
      [46.048, 12.02661],
      [46.04817, 12.02653],
      [46.04827, 12.02653],
      [46.04837, 12.02656],
      [46.04845, 12.02656],
      [46.04865, 12.02643],
      [46.04881, 12.02638],
      [46.04921, 12.02631],
      [46.04941, 12.02632],
      [46.04946, 12.02637],
      [46.04948, 12.02645],
      [46.04948, 12.02688],
      [46.04951, 12.02655],
      [46.04955, 12.02649],
    ] as [number, number][],
    color: colors.paths.tomato,
  },
  {
    legend: 'Percorso "Laghetti della Rimonta"',
    key: "laghetti-round-trip",
    path: [
      [46.04947, 12.02641],
      [46.04948, 12.02645],
      [46.04948, 12.02688],
      [46.04951, 12.02655],
      [46.0496, 12.02642],
      [46.04973, 12.02623],
      [46.04985, 12.02626],
      [46.04995, 12.02632],
      [46.05012, 12.02632],
      [46.05021, 12.0262],
      [46.0503, 12.02608],
      [46.05039, 12.02602],
      [46.05077, 12.0257],
      [46.05113, 12.02559],
      [46.05128, 12.02565],
      [46.0514, 12.02565],
      [46.05151, 12.02557],
      [46.05183, 12.02532],
      [46.05197, 12.02513],
      [46.05209, 12.02506],
      [46.05224, 12.02483],
      [46.05228, 12.02465],
      [46.05235, 12.02453],
      [46.05248, 12.02445],
      [46.05258, 12.0244],
      [46.05271, 12.02436],
      [46.05275, 12.02441],
      [46.05279, 12.02453],
      [46.05284, 12.02458],
      [46.05302, 12.02448],
      [46.05305, 12.02445],
      [46.05312, 12.02427],
      [46.05318, 12.02421],
      [46.0533, 12.02399],
      [46.05339, 12.02399],
      [46.05349, 12.02393],
      [46.05357, 12.02389],
      [46.05367, 12.02387],
      [46.05375, 12.02381],
      [46.05384, 12.0238],
      [46.05388, 12.0239],
      [46.05398, 12.024],
      [46.05403, 12.02411],
      [46.05416, 12.02429],
      [46.0542, 12.0244],
      [46.05441, 12.02467],
      [46.0545, 12.02476],
      [46.05454, 12.02488],
      [46.05462, 12.02494],
      [46.05462, 12.02508],
      [46.05469, 12.0253],
      [46.05471, 12.02535],
      [46.05472, 12.02545],
      [46.05466, 12.02574],
      [46.05464, 12.02586],
      [46.05464, 12.02601],
      [46.05466, 12.02614],
      [46.05461, 12.02627],
      [46.05457, 12.02638],
      [46.05449, 12.02648],
      [46.05448, 12.02662],
      [46.0545, 12.02675],
      [46.05457, 12.02702],
      [46.05473, 12.02714],
      [46.05478, 12.02726],
      [46.05484, 12.02753],
      [46.05484, 12.02758],
      [46.05484, 12.02758],
      [46.05484, 12.02764],
      [46.05486, 12.02772],
      [46.055, 12.02798],
      [46.05502, 12.02814],
      [46.0551, 12.02834],
      [46.0552, 12.02872],
      [46.05523, 12.0289],
      [46.05524, 12.02903],
      [46.05507, 12.0291],
      [46.0548, 12.02927],
      [46.05472, 12.0293],
      [46.05462, 12.02929],
      [46.05455, 12.02938],
      [46.05452, 12.02953],
      [46.05456, 12.02979],
      [46.05462, 12.03006],
      [46.0546, 12.03022],
      [46.05456, 12.03048],
      [46.0545, 12.03058],
      [46.05442, 12.03064],
      [46.05428, 12.03042],
      [46.05412, 12.03027],
      [46.05408, 12.03014],
      [46.054, 12.03008],
      [46.0539, 12.02995],
      [46.05386, 12.02989],
      [46.05374, 12.02977],
      [46.0536, 12.02965],
      [46.05352, 12.02953],
      [46.05338, 12.02938],
      [46.05333, 12.02923],
      [46.05324, 12.02918],
      [46.05309, 12.02908],
      [46.053, 12.029],
      [46.05294, 12.02889],
      [46.05285, 12.02883],
      [46.05266, 12.02881],
      [46.05248, 12.02877],
      [46.05239, 12.02878],
      [46.05231, 12.02882],
      [46.05202, 12.0288],
      [46.05192, 12.02874],
      [46.05189, 12.02861],
      [46.05189, 12.02848],
      [46.05178, 12.02834],
      [46.0517, 12.02821],
      [46.05153, 12.02809],
      [46.0514, 12.028],
      [46.05122, 12.02791],
      [46.05098, 12.02767],
      [46.05077, 12.02753],
      [46.05059, 12.02739],
      [46.05036, 12.0273],
      [46.05019, 12.0272],
      [46.05012, 12.02714],
      [46.04952, 12.02689],
    ] as [number, number][],
    color: colors.paths.liver,
  },
]

export default paths
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/data/paths/narcisi.ts
========================================

import { colors } from "../../styles"

const paths = [
  {
    legend: "Piazza Lentiai - Chalet Col D'Artent",
    key: "piazza-lentiai-chalet-col-d-artent",
    mean: "car" as "car",
    color: colors.paths.liver,
    path: [
      [46.04492, 12.02171],
      [46.04497, 12.02188],
      [46.04508, 12.02244],
      [46.04519, 12.02312],
      [46.04527, 12.02368],
      [46.04531, 12.02415],
      [46.04531, 12.02441],
      [46.04526, 12.02489],
      [46.04523, 12.02515],
      [46.0448, 12.02513],
      [46.04465, 12.02511],
      [46.04433, 12.0251],
      [46.04419, 12.02512],
      [46.04405, 12.02524],
      [46.04377, 12.02544],
      [46.04354, 12.02555],
      [46.04345, 12.02557],
      [46.04338, 12.02554],
      [46.04329, 12.02545],
      [46.04317, 12.02526],
      [46.04308, 12.02508],
      [46.04281, 12.02444],
      [46.04271, 12.02433],
      [46.04251, 12.02416],
      [46.04233, 12.02403],
      [46.04221, 12.02399],
      [46.04198, 12.02404],
      [46.04188, 12.02418],
      [46.04141, 12.02496],
      [46.04103, 12.02534],
      [46.04094, 12.02548],
      [46.04092, 12.02561],
      [46.04093, 12.02573],
      [46.04105, 12.02616],
      [46.04107, 12.02638],
      [46.04108, 12.02722],
      [46.04104, 12.02749],
      [46.04097, 12.02761],
      [46.04051, 12.02795],
      [46.04027, 12.02817],
      [46.03986, 12.02846],
      [46.03974, 12.02851],
      [46.03954, 12.02852],
      [46.03934, 12.02845],
      [46.03914, 12.0283],
      [46.039, 12.0281],
      [46.03879, 12.02775],
      [46.03858, 12.02738],
      [46.038, 12.0264],
      [46.03791, 12.02636],
      [46.03785, 12.02635],
      [46.03774, 12.02638],
      [46.03766, 12.02645],
      [46.0376, 12.02659],
      [46.0376, 12.02682],
      [46.03761, 12.02727],
      [46.03759, 12.02743],
      [46.03749, 12.02767],
      [46.03739, 12.02785],
      [46.03722, 12.02801],
      [46.03707, 12.02812],
      [46.03692, 12.0282],
      [46.03652, 12.02834],
      [46.03625, 12.0284],
      [46.03606, 12.0284],
      [46.0359, 12.02834],
      [46.03577, 12.02822],
      [46.0354, 12.0277],
      [46.03512, 12.02729],
      [46.03487, 12.02682],
      [46.03479, 12.02621],
      [46.03461, 12.02566],
      [46.03452, 12.025],
      [46.03446, 12.02479],
      [46.03414, 12.02412],
      [46.03399, 12.02393],
      [46.03388, 12.0239],
      [46.03346, 12.02407],
      [46.03321, 12.0242],
      [46.0331, 12.02437],
      [46.03306, 12.02448],
      [46.03303, 12.02464],
      [46.03297, 12.02526],
      [46.03293, 12.02555],
      [46.03268, 12.02654],
      [46.03258, 12.02708],
      [46.03255, 12.02731],
      [46.03256, 12.0275],
      [46.03294, 12.0289],
      [46.03299, 12.02937],
      [46.03297, 12.02978],
      [46.03274, 12.03044],
      [46.03273, 12.03061],
      [46.03276, 12.03078],
      [46.03287, 12.0312],
      [46.03284, 12.03151],
      [46.03275, 12.03178],
      [46.03246, 12.03236],
      [46.03231, 12.03282],
      [46.03206, 12.03413],
      [46.03197, 12.03451],
      [46.03185, 12.03477],
      [46.0317, 12.03489],
      [46.03031, 12.03509],
      [46.02983, 12.0351],
      [46.02942, 12.03508],
      [46.02927, 12.03501],
      [46.02902, 12.03484],
      [46.02864, 12.03459],
      [46.02841, 12.03442],
      [46.02827, 12.03427],
      [46.02752, 12.03328],
      [46.02707, 12.03224],
      [46.02669, 12.031],
      [46.02628, 12.02959],
      [46.0261, 12.02873],
      [46.02601, 12.02858],
      [46.0256, 12.02831],
      [46.02545, 12.02819],
      [46.02538, 12.02792],
      [46.02507, 12.02628],
      [46.02423, 12.02422],
      [46.02418, 12.02417],
      [46.02411, 12.02415],
      [46.02401, 12.02419],
      [46.02397, 12.02434],
      [46.02419, 12.02509],
      [46.02406, 12.02614],
      [46.02377, 12.02674],
      [46.0234, 12.02701],
      [46.02327, 12.02701],
      [46.02321, 12.02698],
      [46.02317, 12.02692],
      [46.02274, 12.02529],
      [46.02269, 12.02513],
      [46.02265, 12.02508],
      [46.02239, 12.02503],
      [46.02217, 12.025],
      [46.02199, 12.02476],
      [46.02189, 12.02454],
      [46.02174, 12.02421],
      [46.02169, 12.02413],
      [46.02049, 12.02328],
      [46.02015, 12.02323],
      [46.01955, 12.02335],
      [46.01903, 12.02335],
      [46.019, 12.02333],
      [46.01897, 12.0233],
      [46.01892, 12.02318],
      [46.01888, 12.02303],
      [46.01879, 12.0229],
      [46.01872, 12.02285],
      [46.01865, 12.02286],
      [46.0186, 12.0229],
      [46.01855, 12.02297],
      [46.01848, 12.02318],
      [46.01841, 12.02497],
      [46.01843, 12.02679],
      [46.0184, 12.02687],
      [46.01831, 12.02694],
      [46.01823, 12.02693],
      [46.01814, 12.02685],
      [46.01796, 12.02661],
      [46.01788, 12.02657],
      [46.01777, 12.02662],
      [46.0177, 12.02678],
      [46.01767, 12.02817],
      [46.01764, 12.02839],
      [46.01752, 12.02858],
      [46.01732, 12.02865],
      [46.01706, 12.02865],
      [46.01688, 12.02878],
      [46.01681, 12.02898],
      [46.01682, 12.02913],
      [46.01696, 12.02961],
      [46.01695, 12.02984],
      [46.01683, 12.03057],
      [46.01669, 12.0306],
      [46.0166, 12.03057],
      [46.01616, 12.02991],
      [46.01584, 12.02886],
      [46.01575, 12.02883],
      [46.01568, 12.02894],
      [46.01566, 12.02907],
      [46.01581, 12.02988],
      [46.01575, 12.03011],
      [46.01559, 12.03022],
      [46.0154, 12.03024],
      [46.01521, 12.03013],
      [46.01494, 12.02977],
      [46.01479, 12.02947],
      [46.0147, 12.02917],
      [46.01473, 12.02889],
      [46.01469, 12.0286],
      [46.01372, 12.0268],
      [46.0136, 12.02586],
      [46.01349, 12.02573],
      [46.01324, 12.02556],
      [46.01266, 12.02531],
      [46.01256, 12.02496],
      [46.01244, 12.02475],
      [46.01171, 12.02437],
      [46.01136, 12.02431],
      [46.01056, 12.02467],
      [46.00954, 12.0242],
      [46.00867, 12.02311],
      [46.00847, 12.02303],
      [46.00817, 12.02312],
      [46.00806, 12.02313],
    ] as [number, number][],
  },
  {
    legend: "Col D'Artent - Col Moscher",
    key: "col-d-artent-col-moscher",
    difficulty: "Molto facile",
    notes:
      "Escursione facile. Adatto ad ogni livello di allenamento. Sentieri facilmente percorribili. Adatto ad ogni livello di abilit√†.",
    time: "55m",
    totDistance: "3.1km",
    posElevation: "210m",
    negElevation: "25m",
    color: colors.paths.green,
    mean: "foot" as "foot",
    type: "andata",
    path: [
      [46.00804, 12.02313],
      [46.00781, 12.02306],
      [46.00759, 12.02296],
      [46.00712, 12.02247],
      [46.0059, 12.02188],
      [46.00493, 12.02103],
      [46.00433, 12.02087],
      [46.00351, 12.02005],
      [46.00192, 12.01873],
      [46.00099, 12.01826],
      [46.0005, 12.01774],
      [46.00044, 12.01766],
      [46.0004, 12.01715],
      [46.00027, 12.01666],
      [45.99947, 12.01624],
      [45.99882, 12.01647],
      [45.99847, 12.01604],
      [45.99731, 12.01579],
      [45.99714, 12.01575],
      [45.996, 12.01505],
      [45.99522, 12.01475],
      [45.99434, 12.01381],
      [45.9942, 12.01367],
      [45.99396, 12.01346],
      [45.99336, 12.01338],
      [45.99302, 12.01341],
      [45.99262, 12.01344],
      [45.99208, 12.01343],
      [45.99168, 12.01354],
      [45.99127, 12.01354],
      [45.99063, 12.01345],
    ] as [number, number][],
  },
  {
    legend: "Col D'Artent - Malga Garda",
    key: "col-d-artent-malga-garda",
    difficulty: "Facile",
    notes:
      "Escursione facile. Adatto ad ogni livello di allenamento. Sentieri facilmente percorribili. Adatto ad ogni livello di abilit√†.",
    time: "1h 25m",
    totDistance: "4.4km",
    posElevation: "280m",
    negElevation: "40m",
    color: colors.paths.orange,
    mean: "foot" as "foot",
    type: "andata",
    path: [
      [46.00804, 12.02313],
      [46.00781, 12.02306],
      [46.00759, 12.02296],
      [46.00712, 12.02247],
      [46.0059, 12.02188],
      [46.00493, 12.02103],
      [46.00433, 12.02087],
      [46.00351, 12.02005],
      [46.00192, 12.01873],
      [46.00099, 12.01826],
      [46.0005, 12.01774],
      [46.00044, 12.01766],
      [46.0004, 12.01715],
      [46.00027, 12.01666],
      [45.99947, 12.01624],
      [45.99882, 12.01647],
      [45.99847, 12.01604],
      [45.99731, 12.01579],
      [45.99714, 12.01575],
      [45.996, 12.01505],
      [45.99522, 12.01475],
      [45.99434, 12.01381],
      [45.9942, 12.01367],
      [45.99396, 12.01346],
      [45.99336, 12.01338],
      [45.99302, 12.01341],
      [45.99262, 12.01344],
      [45.99208, 12.01343],
      [45.99168, 12.01354],
      [45.99127, 12.01354],
      [45.99072, 12.01346],
      [45.99035, 12.01342],
      [45.98995, 12.01349],
      [45.98872, 12.01327],
      [45.98823, 12.013],
      [45.98748, 12.01291],
      [45.98704, 12.01271],
      [45.98669, 12.01243],
      [45.98629, 12.01214],
      [45.98592, 12.01161],
      [45.98535, 12.01115],
      [45.98466, 12.01079],
      [45.98431, 12.01045],
      [45.98365, 12.01026],
      [45.98328, 12.01126],
      [45.98265, 12.01158],
      [45.98257, 12.0118],
      [45.98246, 12.01212],
      [45.98226, 12.01256],
      [45.98138, 12.01332],
      [45.98109, 12.0135],
      [45.98079, 12.01334],
      [45.98023, 12.01338],
      [45.98001, 12.01368],
      [45.97984, 12.01464],
      [45.97969, 12.01499],
      [45.97929, 12.01528],
      [45.97874, 12.01542],
      [45.97804, 12.01575],
      [45.97757, 12.01581],
      [45.97718, 12.01612],
      [45.97714, 12.01583],
      [45.97706, 12.01558],
      [45.977, 12.01517],
      [45.97669, 12.01451],
      [45.9765, 12.01416],
      [45.97645, 12.01421],
      [45.97639, 12.01484],
      [45.9762, 12.01525],
      [45.976, 12.01559],
      [45.97559, 12.01591],
      [45.97529, 12.01609],
      [45.97509, 12.01612],
      [45.97484, 12.01637],
      [45.97459, 12.01655],
      [45.9744, 12.01658],
    ] as [number, number][],
  },
  {
    legend:
      "Anello Col D'Artent - Malga Garda - Capitello di Garda - Col D'Artent",
    key: "anello-artent-garda-capitello",
    difficulty: "Medio-Facile",
    notes:
      "Escursione di difficolt√† media. Sentieri facilmente percorribili. Non presenta particolari difficolt√† se non la lunghezza del percorso.",
    time: "3h 30m",
    totDistance: "13.3km",
    posElevation: "441m",
    negElevation: "441m",
    color: colors.paths.tomato,
    mean: "foot" as "foot",
    type: "Andata-Ritorno",
    path: [
      [46.00804, 12.02313],
      [46.00781, 12.02306],
      [46.00759, 12.02296],
      [46.00712, 12.02247],
      [46.0059, 12.02188],
      [46.00493, 12.02103],
      [46.00433, 12.02087],
      [46.00351, 12.02005],
      [46.00192, 12.01873],
      [46.00099, 12.01826],
      [46.0005, 12.01774],
      [46.00044, 12.01766],
      [46.0004, 12.01715],
      [46.00027, 12.01666],
      [45.99947, 12.01624],
      [45.99882, 12.01647],
      [45.99847, 12.01604],
      [45.99731, 12.01579],
      [45.99714, 12.01575],
      [45.996, 12.01505],
      [45.99522, 12.01475],
      [45.99434, 12.01381],
      [45.9942, 12.01367],
      [45.99396, 12.01346],
      [45.99336, 12.01338],
      [45.99302, 12.01341],
      [45.99262, 12.01344],
      [45.99208, 12.01343],
      [45.99168, 12.01354],
      [45.99127, 12.01354],
      [45.99072, 12.01346],
      [45.99035, 12.01342],
      [45.98995, 12.01349],
      [45.98872, 12.01327],
      [45.98823, 12.013],
      [45.98748, 12.01291],
      [45.98704, 12.01271],
      [45.98669, 12.01243],
      [45.98629, 12.01214],
      [45.98592, 12.01161],
      [45.98535, 12.01115],
      [45.98466, 12.01079],
      [45.98431, 12.01045],
      [45.98365, 12.01026],
      [45.98328, 12.01126],
      [45.98265, 12.01158],
      [45.98257, 12.0118],
      [45.98246, 12.01212],
      [45.98226, 12.01256],
      [45.98138, 12.01332],
      [45.98109, 12.0135],
      [45.98079, 12.01334],
      [45.98023, 12.01338],
      [45.98001, 12.01368],
      [45.97984, 12.01464],
      [45.97969, 12.01499],
      [45.97929, 12.01528],
      [45.97874, 12.01542],
      [45.97804, 12.01575],
      [45.97757, 12.01581],
      [45.97718, 12.01612],
      [45.97714, 12.01583],
      [45.97706, 12.01558],
      [45.977, 12.01517],
      [45.97669, 12.01451],
      [45.9765, 12.01416],
      [45.97645, 12.01421],
      [45.97639, 12.01484],
      [45.9762, 12.01525],
      [45.976, 12.01559],
      [45.97559, 12.01591],
      [45.97529, 12.01609],
      [45.97509, 12.01612],
      [45.97484, 12.01637],
      [45.97459, 12.01655],
      [45.9744, 12.01658],
      [45.97417, 12.01657],
      [45.97373, 12.0164],
      [45.97354, 12.01651],
      [45.97333, 12.01676],
      [45.97314, 12.01703],
      [45.97288, 12.01721],
      [45.97256, 12.01733],
      [45.97231, 12.0174],
      [45.97215, 12.01741],
      [45.97173, 12.01759],
      [45.97053, 12.01741],
      [45.97034, 12.0174],
      [45.96986, 12.0177],
      [45.96917, 12.01787],
      [45.96847, 12.018],
      [45.96812, 12.01805],
      [45.96776, 12.01821],
      [45.96681, 12.01856],
      [45.96592, 12.01911],
      [45.96466, 12.01977],
      [45.96353, 12.02077],
      [45.96258, 12.02175],
      [45.96241, 12.02203],
      [45.96237, 12.0222],
      [45.9623, 12.02237],
      [45.96226, 12.02239],
      [45.9623, 12.02237],
      [45.96263, 12.0223],
      [45.96283, 12.0222],
      [45.96309, 12.02194],
      [45.96333, 12.02157],
      [45.96354, 12.02131],
      [45.96374, 12.02114],
      [45.96408, 12.0209],
      [45.96456, 12.02068],
      [45.96504, 12.02047],
      [45.9656, 12.02036],
      [45.96598, 12.0202],
      [45.96638, 12.02012],
      [45.96704, 12.0201],
      [45.96772, 12.02015],
      [45.96827, 12.02005],
      [45.96947, 12.02009],
      [45.96972, 12.02016],
      [45.97025, 12.02015],
      [45.97063, 12.02038],
      [45.97093, 12.02074],
      [45.97113, 12.02097],
      [45.97151, 12.02111],
      [45.97179, 12.02112],
      [45.97202, 12.02105],
      [45.97229, 12.02113],
      [45.97262, 12.02126],
      [45.97285, 12.02119],
      [45.9731, 12.02094],
      [45.97318, 12.0209],
      [45.97331, 12.02098],
      [45.97348, 12.02109],
      [45.97399, 12.02181],
      [45.97413, 12.02196],
      [45.97432, 12.02196],
      [45.97471, 12.02172],
      [45.97484, 12.02162],
      [45.97486, 12.02135],
      [45.97502, 12.02124],
      [45.97526, 12.02117],
      [45.97571, 12.02072],
      [45.97583, 12.02067],
      [45.97595, 12.02072],
      [45.97605, 12.02099],
      [45.97617, 12.02151],
      [45.97627, 12.02171],
      [45.97637, 12.02171],
      [45.97649, 12.02167],
      [45.97699, 12.02104],
      [45.97707, 12.02063],
      [45.97706, 12.02032],
      [45.97708, 12.01981],
      [45.97714, 12.0193],
      [45.97736, 12.01891],
      [45.97778, 12.01837],
      [45.97817, 12.01798],
      [45.97844, 12.01799],
      [45.97876, 12.01807],
      [45.979, 12.018],
      [45.97919, 12.01763],
      [45.97923, 12.01725],
      [45.97936, 12.01706],
      [45.97964, 12.01696],
      [45.98006, 12.01675],
      [45.98024, 12.01648],
      [45.98044, 12.01569],
      [45.98045, 12.0152],
      [45.98048, 12.01494],
      [45.9806, 12.01455],
      [45.98074, 12.01419],
      [45.98086, 12.01387],
      [45.98108, 12.01352],
    ] as [number, number][],
  },
  {
    legend: "Carrettiera Stabie - Col Moscher",
    key: "stabie-col-moscher",
    difficulty: "Medio-Facile",
    notes:
      "Escursione di difficolt√† media. Sentieri facilmente percorribili. Non presenta particolari difficolt√† se non la lunghezza del percorso e il dislivello.",
    time: "2h 50m",
    totDistance: "5.1km",
    posElevation: "800m",
    negElevation: "90m",
    color: colors.paths.mustard,
    mean: "foot" as "foot",
    type: "Andata",
    path: [
      [46.01189, 11.99492],
      [46.01182, 11.99484],
      [46.01177, 11.99516],
      [46.01171, 11.99562],
      [46.01166, 11.99574],
      [46.01156, 11.99589],
      [46.01119, 11.99619],
      [46.0111, 11.99638],
      [46.01099, 11.9967],
      [46.01096, 11.99687],
      [46.01095, 11.99708],
      [46.01093, 11.99755],
      [46.01097, 11.99768],
      [46.01098, 11.99777],
      [46.01097, 11.99784],
      [46.01092, 11.99791],
      [46.01065, 11.99841],
      [46.0106, 11.99844],
      [46.01056, 11.99843],
      [46.01054, 11.99841],
      [46.01051, 11.99836],
      [46.01052, 11.99802],
      [46.01048, 11.9979],
      [46.01017, 11.99748],
      [46.01011, 11.99744],
      [46.00949, 11.99751],
      [46.00937, 11.99748],
      [46.00924, 11.9974],
      [46.0092, 11.9973],
      [46.00914, 11.99694],
      [46.00914, 11.99675],
      [46.00931, 11.99637],
      [46.00933, 11.99629],
      [46.00932, 11.99622],
      [46.00928, 11.99616],
      [46.00923, 11.99612],
      [46.0091, 11.99611],
      [46.00897, 11.99607],
      [46.00874, 11.99587],
      [46.0083, 11.99569],
      [46.0081, 11.9957],
      [46.008, 11.99573],
      [46.00782, 11.99631],
      [46.0075, 11.99679],
      [46.00723, 11.99691],
      [46.00691, 11.99689],
      [46.0066, 11.99708],
      [46.00649, 11.99704],
      [46.00614, 11.99631],
      [46.00598, 11.99618],
      [46.00563, 11.99617],
      [46.00533, 11.99721],
      [46.00524, 11.99729],
      [46.00512, 11.99727],
      [46.00482, 11.99682],
      [46.00376, 11.99638],
      [46.00244, 11.99625],
      [46.00218, 11.99628],
      [46.00189, 11.99641],
      [46.00161, 11.99687],
      [46.00141, 11.99689],
      [46.00089, 11.99767],
      [46.00091, 11.9977],
      [46.00106, 11.99759],
      [46.00114, 11.99766],
      [46.0015, 11.99758],
      [46.00189, 11.99784],
      [46.00213, 11.99838],
      [46.00253, 11.99873],
      [46.00306, 11.9998],
      [46.00312, 12.00043],
      [46.00306, 12.00071],
      [46.0029, 12.00092],
      [46.00213, 12.00098],
      [46.00183, 12.00136],
      [46.00172, 12.00208],
      [46.00132, 12.00246],
      [46.00124, 12.00301],
      [46.001, 12.0028],
      [46.00091, 12.0031],
      [45.99931, 12.00483],
      [45.99897, 12.00497],
      [45.99871, 12.00448],
      [45.99875, 12.00301],
      [45.9985, 12.0021],
      [45.99819, 12.00178],
      [45.99796, 12.0017],
      [45.99788, 12.00178],
      [45.99788, 12.0019],
      [45.99803, 12.00204],
      [45.99811, 12.00217],
      [45.99817, 12.00236],
      [45.99814, 12.00253],
      [45.99802, 12.0026],
      [45.99784, 12.00249],
      [45.99762, 12.00249],
      [45.99725, 12.00242],
      [45.99679, 12.00255],
      [45.99646, 12.00274],
      [45.99612, 12.00278],
      [45.99599, 12.00283],
      [45.99598, 12.00295],
      [45.99614, 12.00353],
      [45.99613, 12.00397],
      [45.99571, 12.00523],
      [45.99558, 12.00574],
      [45.99492, 12.00625],
      [45.99462, 12.00653],
      [45.99474, 12.00719],
      [45.99462, 12.0073],
      [45.99398, 12.00594],
      [45.99395, 12.00574],
      [45.99402, 12.0054],
      [45.99399, 12.00514],
      [45.99388, 12.00503],
      [45.99374, 12.00499],
      [45.99345, 12.00497],
      [45.99318, 12.00514],
      [45.99282, 12.00512],
      [45.99272, 12.00506],
      [45.99264, 12.00504],
      [45.99257, 12.00523],
      [45.99254, 12.00541],
      [45.99256, 12.00549],
      [45.99272, 12.00558],
      [45.99291, 12.00592],
      [45.99286, 12.006],
      [45.99272, 12.00591],
      [45.99265, 12.00594],
      [45.99258, 12.00611],
      [45.99254, 12.00638],
      [45.99253, 12.00703],
      [45.99246, 12.00713],
      [45.99236, 12.00713],
      [45.99216, 12.00724],
      [45.99215, 12.00739],
      [45.99228, 12.00752],
      [45.99242, 12.00796],
      [45.99258, 12.00814],
      [45.99256, 12.00825],
      [45.99216, 12.00805],
      [45.99207, 12.00806],
      [45.99205, 12.00826],
      [45.99214, 12.00859],
      [45.99217, 12.00886],
      [45.9917, 12.01063],
      [45.99182, 12.01149],
      [45.99183, 12.01172],
      [45.99195, 12.01229],
      [45.99193, 12.01237],
    ] as [number, number][],
  },
]

export default paths
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/data/sections.ts
========================================

export const navItems = [
  {
    label: "Laghetti della Rimonta",
    url: "/laghetti",
    subsections: [
      {
        label: "Mappe",
        url: "/laghetti/mappe",
      },
      {
        label: "Rimontarte",
        url: "/laghetti/rimontarte",
      },
      {
        label: "Storia",
        url: "/laghetti/storia",
      },
      {
        label: "Natura",
        url: "/laghetti/natura",
      },
      {
        label: "Galleria",
        url: "/laghetti/galleria",
      },
    ],
  },
  {
    label: "Progetto Narcisi",
    url: "/narcisi",
    subsections: [
      {
        label: "Mappe",
        url: "/narcisi/mappe",
      },
      {
        label: "Il progetto",
        url: "/narcisi/progetto",
      },
      {
        label: "Storia",
        url: "/narcisi/storia",
      },
      {
        label: "Natura",
        url: "/narcisi/natura",
      },
      {
        label: "Narcisi in Valbelluna",
        url: "/narcisi/valbelluna",
      },
      {
        label: "Galleria",
        url: "/narcisi/galleria",
      },
    ],
  },
  {
    label: "Sociale",
    url: "/sociale",
    subsections: [
      {
        label: "Mobilit√† sostenibile",
        url: "/sociale/mobilit√†-sostenibile",
      },
      {
        label: "Educazione ambientale",
        url: "/sociale/educazione-ambientale",
      },
      {
        label: "Rifiuti",
        url: "/sociale/rifiuti",
      },
      {
        label: "I nostri Ideali",
        url: "/sociale/ideali",
      },
    ],
  },
  {
    label: "Blog",
    url: "/blog",
  },
  {
    label: "Chi siamo",
    url: "/chi-siamo",
  },
  {
    label: "Contatti",
    url: "/contatti",
  },
  {
    label: "Partecipa",
    url: "/partecipa",
  },
]

export const footerSections = [
  {
    label: "Laghetti della Rimonta",
    url: "/laghetti",
    subsections: [
      {
        label: "Mappe",
        url: "/laghetti/mappe",
      },
      {
        label: "Rimontarte",
        url: "/laghetti/rimontarte",
      },
      {
        label: "Storia",
        url: "/laghetti/storia",
      },
      {
        label: "Natura",
        url: "/laghetti/natura",
      },
      {
        label: "Galleria",
        url: "/laghetti/galleria",
      },
    ],
  },
  {
    label: "Progetto Narcisi",
    url: "/narcisi",
    subsections: [
      {
        label: "Mappe",
        url: "/narcisi/mappe",
      },
      {
        label: "Il progetto",
        url: "/narcisi/progetto",
      },
      {
        label: "Storia",
        url: "/narcisi/storia",
      },
      {
        label: "Natura",
        url: "/narcisi/natura",
      },
      {
        label: "Galleria",
        url: "/narcisi/galleria",
      },
    ],
  },
  {
    label: "Sociale",
    url: "/sociale",
    subsections: [
      {
        label: "Mobilit√† sostenibile",
        url: "/sociale/mobilit√†-sostenibile",
      },
      {
        label: "Educazione ambientale",
        url: "/sociale/educazione-ambientale",
      },
      {
        label: "Rifiuti",
        url: "/sociale/rifiuti",
      },
      {
        label: "I nostri Ideali",
        url: "/sociale/ideali",
      },
    ],
  },
  {
    label: "Su di noi",
    subsections: [
      {
        label: "Blog",
        url: "/blog",
      },
      {
        label: "Chi siamo",
        url: "/chi-siamo",
      },
      {
        label: "Contatti",
        url: "/contatti",
      },
      {
        label: "Partecipa",
        url: "/partecipa",
      },
    ],
  },
]
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/hooks/useResponsiveClickHandler.tsx
========================================

import { useEffect, useRef, useState } from "react"

const useResponsiveClickHandler = (
  mediaQuery: string,
  handler: () => void,
): (() => void) | undefined => {
  const [clickHandler, setClickHandler] = useState<(() => void) | undefined>(
    undefined,
  )
  const mediaQueryRef = useRef<MediaQueryList | null>(null)

  useEffect(() => {
    mediaQueryRef.current = window.matchMedia(mediaQuery)

    const updateClickHandler = (
      event: MediaQueryListEvent | MediaQueryList,
    ) => {
      const shouldSetHandler = event.matches
      const shouldUnsetHandler = !event.matches && clickHandler
      const alreadyUnsetHandler = !event.matches && !clickHandler
      if (alreadyUnsetHandler) return
      if (shouldUnsetHandler) setClickHandler(undefined)
      if (shouldSetHandler) setClickHandler(prev => (prev ? prev : handler))
    }
    updateClickHandler(mediaQueryRef.current)

    mediaQueryRef.current.addEventListener("change", updateClickHandler)
    return () => {
      mediaQueryRef.current?.removeEventListener("change", updateClickHandler)
    }
  }, [mediaQuery, handler])

  return clickHandler
}

export default useResponsiveClickHandler
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/hooks/useThrottledState.ts
========================================

import { useEffect, useRef, useState } from "react"
import throttle from "lodash/throttle"

const useThrottledState = <T>(
  defaultVal: T,
  throttleRate: number,
  dispatch: any,
) => {
  const [value, setValue] = useState(defaultVal)

  const throttledFunc = useRef(throttle(dispatch, throttleRate)).current

  useEffect(() => {
    throttledFunc(value)
  }, [value])

  return [value, setValue]
}

export default useThrottledState
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/hooks/useSwipe.ts
========================================

import { TouchEvent, useRef } from "react"

interface SwipeInput {
  onSwipedLeft: () => void
  onSwipedRight: () => void
}

interface SwipeOutput {
  onTouchStart: (e: TouchEvent) => void
  onTouchMove: (e: TouchEvent) => void
  onTouchEnd: () => void
}

export default (input: SwipeInput): SwipeOutput => {
  const touchStart = useRef<number | null>(null)
  const touchEnd = useRef<number | null>(null)

  // the required distance between touchStart and touchEnd to be detected as a swipe
  const minSwipeDistance = 50

  const onTouchStart = (e: React.TouchEvent) => {
    touchEnd.current = null
    touchStart.current = e.targetTouches[0].clientX
  }

  const onTouchMove = (e: React.TouchEvent) => {
    touchEnd.current = e.targetTouches[0].clientX
  }

  const onTouchEnd = () => {
    if (!touchStart.current || !touchEnd.current) return
    const distance = touchStart.current - touchEnd.current
    const isLeftSwipe = distance > minSwipeDistance
    const isRightSwipe = distance < -minSwipeDistance
    if (isLeftSwipe) input.onSwipedLeft()
    if (isRightSwipe) input.onSwipedRight()
  }

  return {
    onTouchStart,
    onTouchMove,
    onTouchEnd,
  }
}
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/hooks/usePreventDragAndWheel.tsx
========================================

import { useEffect } from "react"

const usePreventScrollOnImageView = (condition: boolean) => {
  const handleWheel = (event: WheelEvent) => {
    if (condition) {
      event.preventDefault()
    }
  }

  const handleTouchMove = (event: TouchEvent) => {
    if (condition) {
      event.preventDefault()
    }
  }

  const handleMouseMove = (event: MouseEvent) => {
    if (condition) {
      event.preventDefault()
    }
  }

  useEffect(() => {
    if (condition) {
      window.addEventListener("wheel", handleWheel, { passive: false })
      window.addEventListener("touchmove", handleTouchMove, { passive: false })
      window.addEventListener("mousemove", handleMouseMove)
    } else {
      window.removeEventListener("wheel", handleWheel)
      window.removeEventListener("touchmove", handleTouchMove)
      window.removeEventListener("mousemove", handleMouseMove)
    }

    return () => {
      window.removeEventListener("wheel", handleWheel)
      window.removeEventListener("touchmove", handleTouchMove)
      window.removeEventListener("mousemove", handleMouseMove)
    }
  }, [condition])

  return null
}

export default usePreventScrollOnImageView
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/cookie-preferences/index.tsx
========================================

import React, { useState, useEffect } from "react"
import * as S from "./styled"
import * as T from "../typography"
import { colors } from "../../styles"

interface Props {
  onClose: () => void
}

const CookiePreferences: React.FC<Props> = ({ onClose }) => {
  const [analyticsEnabled, setAnalyticsEnabled] = useState(false)
  const [isSaving, setIsSaving] = useState(false)

  useEffect(() => {
    // Load saved preferences
    const savedPrefs = localStorage.getItem("cookie-preferences")
    if (savedPrefs) {
      try {
        const prefs = JSON.parse(savedPrefs)
        setAnalyticsEnabled(prefs.analytics || false)
      } catch (e) {
        console.error("Error parsing cookie preferences", e)
      }
    }
  }, [])

  const savePreferences = () => {
    setIsSaving(true)

    // Save preferences
    localStorage.setItem(
      "cookie-preferences",
      JSON.stringify({
        analytics: analyticsEnabled,
        lastUpdated: new Date().toISOString(),
      }),
    )

    // If analytics are disabled, clear any existing analytics cookies
    if (!analyticsEnabled) {
      clearAnalyticsCookies()
    }

    // Close the modal after a short delay for better UX
    setTimeout(() => {
      setIsSaving(false)
      onClose()
    }, 500)
  }

  const clearAnalyticsCookies = () => {
    const cookies = document.cookie.split(";")
    cookies.forEach(cookie => {
      const name = cookie.split("=")[0].trim()
      // Clear Google Analytics and Gatsby cookies
      if (
        name.startsWith("_") ||
        name.startsWith("ga") ||
        name.startsWith("_ga") ||
        name.startsWith("_gid") ||
        name.startsWith("_gat") ||
        name.startsWith("gatsby")
      ) {
        document.cookie = `${name}=; Max-Age=0; path=/; domain=${window.location.hostname};`
      }
    })
  }

  return (
    <S.ModalOverlay onClick={e => e.target === e.currentTarget && onClose()}>
      <S.ModalContainer onClick={e => e.stopPropagation()}>
        <S.Title>Gestisci le tue preferenze</S.Title>

        <S.CookieType>
          <S.CookieHeader>
            <S.CookieTitle>
              Cookie Tecnici Necessari
              <S.RequiredBadge>Sempre attivi</S.RequiredBadge>
            </S.CookieTitle>
          </S.CookieHeader>
          <S.CookieDescription>
            Questi cookie sono essenziali per il corretto funzionamento del sito
            web e non possono essere disattivati. Vengono utilizzati per
            funzionalit√† di base come la navigazione tra le pagine e l'accesso
            alle aree protette.
          </S.CookieDescription>
        </S.CookieType>

        <S.CookieType>
          <S.CookieHeader>
            <S.CookieTitle>Cookie Analitici</S.CookieTitle>
            <S.CheckboxLabel>
              <input
                type="checkbox"
                checked={analyticsEnabled}
                onChange={e => setAnalyticsEnabled(e.target.checked)}
                aria-label="Attiva cookie analitici"
              />
              <span>
                <T.P3 className="label">
                  {analyticsEnabled ? "Attivati" : "Disattivati"}
                </T.P3>
              </span>
            </S.CheckboxLabel>
          </S.CookieHeader>
          <S.CookieDescription>
            Questi cookie ci aiutano a capire come i visitatori interagiscono
            con il nostro sito, raccogliendo informazioni in forma anonima. I
            dati raccolti ci permettono di migliorare l'esperienza utente. Se
            disattivati, non potremo monitorare le prestazioni del sito.
          </S.CookieDescription>
        </S.CookieType>

        <S.ButtonRow>
          <S.ModalButton
            onClick={savePreferences}
            color={colors.green.green600}
            disabled={isSaving}
            aria-label="Salva le preferenze"
          >
            <S.ButtonLabel>
              {isSaving ? "Salvataggio..." : "Salva preferenze"}
            </S.ButtonLabel>
          </S.ModalButton>
          <S.ModalButton
            onClick={onClose}
            color={colors.green.green400}
            disabled={isSaving}
            aria-label="Annulla e torna indietro"
          >
            <S.ButtonLabel>Annulla</S.ButtonLabel>
          </S.ModalButton>
        </S.ButtonRow>
      </S.ModalContainer>
    </S.ModalOverlay>
  )
}

export default CookiePreferences
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/cookie-preferences/styled.ts
========================================

import styled from "styled-components"
import * as T from "../typography"
import { breakpoint, colors } from "../../styles"

// Styled Components
export const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 1100;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1rem;
  box-sizing: border-box;
  overflow-y: auto;
`

export const ModalContainer = styled.div`
  background: ${colors.green.green100};
  padding: 2rem;
  border-radius: 12px;
  max-width: 600px;
  width: 100%;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
  margin: auto;
  max-height: 90vh;
  overflow-y: auto;

  @media (max-width: ${breakpoint.tablet}) {
    padding: 1.5rem;
    max-height: 85vh;
  }

  @media (max-width: ${breakpoint.mobile}) {
    padding: 1.25rem;
    max-height: 80vh;
  }
`

export const Title = styled(T.H2)`
  font-weight: bold;
  margin: 0 0 1.5rem 0;
  color: ${colors.green.green900};
  text-align: center;

  @media (max-width: ${breakpoint.mobile}) {
    margin-bottom: 1.25rem;
  }
`

export const ButtonRow = styled.div`
  margin-top: 2rem;
  display: flex;
  justify-content: flex-end;
  gap: 0.75rem;
  flex-wrap: wrap;

  @media (max-width: ${breakpoint.mobile}) {
    flex-direction: column;
    gap: 0.5rem;
    margin-top: 1.5rem;
  }
`

export const CookieType = styled.div`
  background: ${colors.green.green50};
  border-radius: 8px;
  padding: 1.25rem;
  margin-bottom: 1rem;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);

  &:last-child {
    margin-bottom: 0;
  }
`

export const CookieHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.75rem;
`

export const CookieTitle = styled(T.H4)`
  font-weight: bold;
  color: ${colors.green.green900};
  margin: 0;
`

export const CookieDescription = styled(T.P3)`
  color: ${colors.green.green800};
  margin: 0.5rem 0 0 0;
  line-height: 1.5;
`

export const CheckboxLabel = styled.label`
  display: flex;
  align-items: center;
  color: ${colors.green.green900};
  cursor: pointer;
  margin: 0;
  min-width: 105px;
  justify-content: space-between;

  input[type="checkbox"] {
    margin-right: 0.75rem;
    margin-top: 0.25rem;
    min-width: 1.1rem;
    min-height: 1.1rem;
    cursor: pointer;
    align-self: center;
    accent-color: ${colors.green.green700};
  }

  .label {
    margin: 0;
  }
`

export const RequiredBadge = styled(T.P4)`
  display: inline-block;
  background: ${colors.green.green300};
  color: ${colors.green.green900};
  font-size: 0.75rem;
  padding: 0.2rem 0.5rem;
  border-radius: 12px;
  margin-left: 0.75rem;
`

export const ButtonLabel = styled(T.P4)`
  color: ${colors.green.green50};
  margin: 0;
`

export const ModalButton = styled.button<{ color: string }>`
  background-color: ${props => props.color};
  color: white;
  padding: 0.7rem 1.5rem;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.5s ease;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 120px;
  @media (max-width: ${breakpoint.mobile}) {
    width: 100%;
    padding: 0.8rem 1.5rem;
  }

  &:hover {
    background-color: ${props => `${props.color}cc`};
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  &:active {
    background-color: ${props => `${props.color}99`};
    transform: translateY(0);
    box-shadow: none;
  }
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/image-with-credits/index.tsx
========================================

import { GatsbyImage, IGatsbyImageData } from "gatsby-plugin-image"
import * as React from "react"
import * as T from "./../typography"
import * as S from "./styled"

const ImageWithCredits = ({
  title,
  description,
  alt,
  image,
  copyright,
  minHeight,
  minWidth,
  maxHeight,
  maxWidth,
  noDescription,
  noCopyright,
  objectFit = "cover" // Default a "cover" per mantenere belle le foto
}: {
  title: string
  description: string
  alt: string
  image: IGatsbyImageData
  copyright: string | undefined
  minWidth?: number
  minHeight?: number
  maxWidth?: number
  maxHeight?: number
  noDescription?: boolean
  noCopyright?: boolean
  objectFit?: "cover" | "contain" | "fill" | "none" | "scale-down"
}) => (
  <S.ImgWrapper
    $maxHeight={maxHeight}
    $maxWidth={maxWidth}
    $minHeight={minHeight}
    $minWidth={minWidth}
  >
    {title && <T.H3 dangerouslySetInnerHTML={{ __html: title }} />}
    <GatsbyImage
      image={image}
      alt={alt}
      style={{
        borderRadius: "12px",
        marginTop: "1em",
        width: "100%",
        maxHeight: maxHeight ? `${maxHeight}px` : undefined, // RIMOSSO il "450px" forzato!
        boxShadow: "0 8px 24px rgba(44, 69, 34, 0.12)"
      }}
      imgStyle={{
        objectFit: objectFit // Usiamo la prop dinamica
      }}
    />
    {noCopyright ? null : copyright ? (
      <T.P4>Foto di {copyright}</T.P4>
    ) : (
      <T.P4>Autore sconosciuto</T.P4>
    )}
    {!noDescription && (
      <S.ImageDescription
        style={{
          maxWidth: image.width,
        }}
        dangerouslySetInnerHTML={{ __html: description }}
      />
    )}
  </S.ImgWrapper>
)

export default ImageWithCredits
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/image-with-credits/styled.ts
========================================

import styled from "styled-components"
import * as T from "./../typography"

export const ImgWrapper = styled.div<{
  $maxWidth?: number
  $maxHeight?: number
  $minWidth?: number
  $minHeight?: number
}>`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start; /* Fa partire gli elementi dall'alto verso il basso */
  text-align: center;
  width: 100%;
  ${({ $maxWidth }) => ($maxWidth ? `max-width: ${$maxWidth}px;` : "")}
  ${({ $maxHeight }) => ($maxHeight ? `max-height: ${$maxHeight}px;` : "")}
  ${({ $minWidth }) => ($minWidth ? `min-width: ${$minWidth}px;` : "")}
  ${({ $minHeight }) => ($minHeight ? `min-height: ${$minHeight}px;` : "")}
`

export const ImageDescription = styled(T.P3)`
  white-space: break-spaces;
  margin-top: 0.5em;
`Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/blog-list/index.tsx
========================================

import React, { useState, useRef, useEffect } from "react"
import { IGatsbyImageData, GatsbyImage } from "gatsby-plugin-image"
import * as S from "./styled"
import * as T from "../typography"
import { navigate } from "gatsby"

// Props injected during build time
export type PostInfo = {
  slug: string
  title: string
  publishedAt: string
  author: string
  excerpt: string
  coverImage: {
    description?: string
    altText: string
    title?: string
    gatsbyImage?: IGatsbyImageData | null
    renderImageUrl?: string
  }
}

interface BlogListProps {
  posts: PostInfo[]
  isFromPost?: boolean
}

const getImage = (post: PostInfo) => {
  if (post.coverImage.gatsbyImage) {
    return (
      <GatsbyImage
        image={post.coverImage.gatsbyImage as IGatsbyImageData}
        alt={post.coverImage.altText ?? "Cover image"}
      />
    )
  } else if (post.coverImage.renderImageUrl) {
    return (
      <img
        className="cover-image"
        src={post.coverImage.renderImageUrl}
        alt={post.coverImage.altText ?? "Cover image"}
      />
    )
  }
  return null
}

export const FeaturedBlog: React.FC<BlogListProps> = ({ posts, isFromPost }) => {
  // Inizializziamo a 1 di default
  const [currentPage, setCurrentPage] = useState(1)
  const gridRef = useRef<HTMLDivElement>(null)

  // Quando il componente viene montato, controlla se c'√® una pagina salvata in memoria
  useEffect(() => {
    if (isFromPost) {
      // Se arriviamo da un post, ripristiniamo la pagina salvata
      const savedPage = sessionStorage.getItem("gnl-blog-page")
      if (savedPage) {
        setCurrentPage(parseInt(savedPage, 10))
      }
    } else {
      // Se arriviamo da qualsiasi altra parte (es. Menu), resettiamo a 1 e puliamo la memoria
      sessionStorage.removeItem("gnl-blog-page")
      setCurrentPage(1)
    }
  }, [isFromPost])

  const POSTS_PER_PAGE = 6

  if (!posts || posts.length === 0) {
    return <T.P2 style={{ textAlign: "center", marginTop: "2rem" }}>Nessun articolo pubblicato al momento.</T.P2>
  }

  const sorted = [...posts].sort(
    (a, b) => new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime(),
  )

  const [featured, ...others] = sorted
  const totalPages = Math.ceil(others.length / POSTS_PER_PAGE)
  const currentPosts = others.slice(
    (currentPage - 1) * POSTS_PER_PAGE,
    currentPage * POSTS_PER_PAGE
  )

  const handlePageChange = (page: number) => {
    setCurrentPage(page)
    // SALVA LA PAGINA IN MEMORIA!
    if (typeof window !== "undefined") {
      sessionStorage.setItem("gnl-blog-page", page.toString())
    }

    if (gridRef.current) {
      const yOffset = gridRef.current.getBoundingClientRect().top + window.scrollY - 100
      window.scrollTo({ top: yOffset, behavior: "smooth" })
    }
  }

  // Sostituito Array.from con un approccio funzionale standard
  const pagesArray = Array(totalPages).fill(0).map((_, i) => i + 1)

  return (
    <S.Container>
      {/* Mostra il post in evidenza SOLO nella prima pagina */}
      {currentPage === 1 && (
        <S.FeaturedPostWrapper onClick={() => navigate(`${featured.slug}`)}>
          <S.CoverImgWrapper $isFeatured={true}>
            {getImage(featured)}
          </S.CoverImgWrapper>
          <S.FeaturedContent>
            <T.P4 style={{ color: "#FE4A49", fontWeight: "bold", marginBottom: "0.5rem" }}>ULTIMO ARTICOLO</T.P4>
            <S.FeaturedTitle>{featured.title}</S.FeaturedTitle>
            <S.MetaInfo>
              {new Date(featured.publishedAt).toLocaleDateString("it-IT", {
                weekday: "long",
                year: "numeric",
                month: "long",
                day: "numeric",
              })}{" "}
              ‚Ä¢ {featured.author}
            </S.MetaInfo>
            <T.P2>{featured.excerpt}</T.P2>
          </S.FeaturedContent>
        </S.FeaturedPostWrapper>
      )}

      {/* Griglia post successivi paginata */}
      <div ref={gridRef}>
        <S.Grid>
          {currentPosts.map(post => (
            <S.Card key={post.slug} onClick={() => navigate(`${post.slug}`)}>
              {/* ... (Lascia intatto il contenuto della Card) ... */}
              <S.CoverImgWrapper $isFeatured={false}>
                {getImage(post)}
              </S.CoverImgWrapper>
              <S.CardContent>
                <S.CardTitle>{post.title}</S.CardTitle>
                <S.MetaInfo>
                  {new Date(post.publishedAt).toLocaleDateString("it-IT", {
                    year: "numeric",
                    month: "long",
                    day: "numeric",
                  })}
                </S.MetaInfo>
                <S.CardExcerpt>{post.excerpt}</S.CardExcerpt>
              </S.CardContent>
            </S.Card>
          ))}
        </S.Grid>
      </div>

      {/* Controlli Paginazione aggiornati */}
      {totalPages > 1 && (
        <S.PaginationWrapper>
          <S.PageButton
            onClick={() => handlePageChange(currentPage - 1)}
            disabled={currentPage === 1}
            aria-label="Pagina precedente"
          >
            &#8592;
          </S.PageButton>

          {pagesArray.map(page => (
            <S.PageButton
              key={page}
              $active={currentPage === page}
              onClick={() => handlePageChange(page)}
            >
              {page}
            </S.PageButton>
          ))}

          <S.PageButton
            onClick={() => handlePageChange(currentPage + 1)}
            disabled={currentPage === totalPages}
            aria-label="Pagina successiva"
          >
            &#8594;
          </S.PageButton>
        </S.PaginationWrapper>
      )}
    </S.Container>
  )
}Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/blog-list/styled.ts
========================================

import styled from "styled-components"
import { breakpoint, breakpointNum, colors } from "../../styles"
import * as T from "../typography"

export const Container = styled.div`
  margin-top: 2rem;
  padding: 2rem;
  padding-top: 3rem;
  max-width: 1200px; 
  margin: 0 auto;
  width: 100%; 
  box-sizing: border-box; 

  @media (max-width: ${breakpointNum.mobile}px) {
    padding: 1.5rem 1rem; 
  }
`

export const FeaturedPostWrapper = styled.article`
  margin-bottom: 4rem;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 4px 12px ${colors.green.green600}66;
  cursor: pointer;
  background: #fff;
  transition: all 0.3s ease;
  display: flex;
  flex-direction: row; 
  align-items: stretch;
  
  /* Sostituisci max-height con height fisso per forzare la forma del banner su Desktop */
  height: 400px; 

  &:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 24px ${colors.green.green700}66;
  }

  /* Spostiamo il passaggio a colonna ai 900px (bigtablet) per evitare schiacciamenti */
  @media (max-width: ${breakpoint.bigtablet}) {
    flex-direction: column; 
    height: auto; /* Sblocchiamo l'altezza in verticale per far adattare il testo */
  }
`

export const CoverImgWrapper = styled.div<{ $isFeatured?: boolean }>`
  flex: ${({ $isFeatured }) => ($isFeatured ? "1" : "none")};
  
  .gatsby-image-wrapper, .cover-image {
    width: 100%;
    /* Su desktop l'immagine prende tutta l'altezza (i 400px definiti sopra) */
    height: ${({ $isFeatured }) => ($isFeatured ? "100%" : "220px")};
    object-fit: cover;
    
    /* FIX PER TABLET/MOBILE: Quando andiamo in colonna, diamo un'altezza massima fissa all'immagine in evidenza */
    @media (max-width: ${breakpoint.bigtablet}) {
      height: ${({ $isFeatured }) => ($isFeatured ? "350px" : "220px")};
    }
    
    @media (max-width: ${breakpoint.mobile}) {
      height: ${({ $isFeatured }) => ($isFeatured ? "250px" : "200px")};
    }
  }
`

export const FeaturedContent = styled.div`
  flex: 1;
  padding: 2.5rem;
  display: flex;
  flex-direction: column;
  justify-content: center;
  overflow: hidden;

  @media (max-width: ${breakpoint.bigtablet}) {
    padding: 2rem;
  }

  @media (max-width: ${breakpoint.mobile}) {
    padding: 1.5rem;
  }
`

export const FeaturedTitle = styled(T.H2)`
  margin: 0 0 0.5rem;
`

export const MetaInfo = styled(T.P3)`
  color: ${colors.green.green600};
  margin-bottom: 1rem;
  font-style: italic;
`

export const Grid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 2.5rem;

  @media (max-width: ${breakpointNum.mobile}px) {
    grid-template-columns: 1fr; /* Forza una singola colonna perfetta su smartphone */
  }
`

export const Card = styled.article`
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 2px 8px ${colors.green.green600}40;
  background: #fff;
  display: flex;
  flex-direction: column;
  cursor: pointer;
  transition: all 0.3s ease;
  
  &:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 20px ${colors.green.green700}50;
  }
`

export const CardContent = styled.div`
  padding: 1.5rem;
  flex: 1;
  display: flex;
  flex-direction: column;
`

export const CardTitle = styled(T.H3)`
  margin: 0 0 0.5rem;
  line-height: 1.3;
`

export const CardExcerpt = styled(T.P3)`
  margin: 0;
  color: ${colors.green.green900};
  display: -webkit-box;
  -webkit-line-clamp: 3; /* Tronca il testo dopo 3 righe */
  -webkit-box-orient: vertical;
  overflow: hidden;
`

/* --- NUOVI STILI PER LA PAGINAZIONE --- */
export const PaginationWrapper = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  margin-top: 4rem;
`

export const PageButton = styled.button<{ $active?: boolean }>`
  background-color: ${({ $active }) => ($active ? colors.green.green600 : colors.green.green200)};
  color: ${({ $active }) => ($active ? colors.green.green50 : colors.green.green900)};
  border: none;
  border-radius: 8px;
  width: 45px;
  height: 45px;
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;

  &:hover:not(:disabled) {
    background-color: ${({ $active }) => ($active ? colors.green.green700 : colors.green.green300)};
    transform: translateY(-2px);
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/icons/index.tsx
========================================

import React from "react"
import { ReactComponent as LogoSVG } from "./../../icons/LogoFull.svg"
import { ReactComponent as HamburgerMenu } from "./../../icons/hamburger-menu.svg"
import { ReactComponent as Chevron } from "./../../icons/chevron.svg"
import { ReactComponent as Phone } from "./../../icons/phone.svg"
import { ReactComponent as Email } from "./../../icons/email.svg"
import { ReactComponent as Facebook } from "./../../icons/facebook.svg"
import { ReactComponent as Whatsapp } from "./../../icons/whatsapp.svg"
import { ReactComponent as Youtube } from "./../../icons/youtube.svg"
import { ReactComponent as WIP } from "./../../icons/wip.svg"
import { ReactComponent as SadFace } from "./../../icons/sad-face.svg"
import { ReactComponent as PiggyBank } from "./../../icons/piggy-bank.svg"
import { ReactComponent as DogPoo } from "./../../icons/dog-poo.svg"
import { ReactComponent as DogLeash } from "./../../icons/dog-leash.svg"
import { ReactComponent as Litter } from "./../../icons/litter.svg"
import { ReactComponent as Crop } from "./../../icons/crop.svg"
import { ReactComponent as ElectricDanger } from "./../../icons/electric-fence.svg"
import { ReactComponent as UpRightArrow } from "./../../icons/arrow-up-right.svg"
import { ReactComponent as DownRightArrow } from "./../../icons/arrow-down-right.svg"
import { ReactComponent as RoundArrow } from "./../../icons/round-arrow.svg"
import { ReactComponent as Clock } from "./../../icons/clock.svg"
import { ReactComponent as RightArrow } from "./../../icons/arrow-right.svg"
import { ReactComponent as Hiker } from "./../../icons/hiker.svg"

interface IconsProps {
  type: string
  width?: number
  height?: number
}

const Icon: React.FC<IconsProps> = ({ type, ...props }) => {
  switch (type) {
    case "logo":
      return <LogoSVG viewBox="0 0 299 182" {...props} />
    case "hamburger-menu":
      return <HamburgerMenu viewBox="0 0 40 40" {...props} />
    case "chevron":
      return <Chevron viewBox="0 0 407.437 407.437" {...props} />
    case "phone":
      return <Phone viewBox="0 0 24 24" {...props} />
    case "email":
      return <Email viewBox="0 0 54.1 54.1" {...props} />
    case "whatsapp":
      return <Whatsapp viewBox="0 0 20 20" {...props} />
    case "facebook":
      return <Facebook viewBox="0 0 960 960" {...props} />
    case "youtube":
      return <Youtube viewBox="0 0 310 310" {...props} />
    case "wip":
      return <WIP viewBox="0 0 312 246" {...props} />
    case "sad-face":
      return <SadFace viewBox="0 0 369.946 369.946" {...props} />
    case "bank":
      return <PiggyBank viewBox="0 0 1024 1024" {...props} />
    case "dog-poo":
      return <DogPoo viewBox="0 0 417 417" {...props} />
    case "dog-leash":
      return <DogLeash viewBox="0 0 238 238" {...props} />
    case "litter":
      return <Litter viewBox="0 0 322 322" {...props} />
    case "crop":
      return <Crop viewBox="0 0 365 367" {...props} />
    case "electric-fence":
      return <ElectricDanger viewBox="0 0 592 879" {...props} />
    case "time":
      return <Clock viewBox="0 0 24 24" {...props} />
    case "difficulty":
    case "posElevation":
      return <UpRightArrow viewBox="0 0 24 24" {...props} />
    case "negElevation":
      return <DownRightArrow viewBox="0 0 24 24" {...props} />
    case "andata":
    case "totDistance":
      return <RightArrow viewBox="0 0 24 24" {...props} />
    case "andata-ritorno":
      return <RoundArrow viewBox="0 0 520 520" {...props} />
    case "hiker":
      return <Hiker viewBox="0 0 115 130" {...props} />
    default:
      return null
  }
}

export default Icon
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/map-narcisi/index.tsx
========================================

import "leaflet-css"
import React, { useEffect, useMemo, useState } from "react"
import { MapContainer, Marker, TileLayer } from "react-leaflet"
import { Location } from "../../types"
import * as T from "./../typography"
import * as S from "./styled"

import { Marker as MarkerLeaflet, icon } from "leaflet"
import ExtendedPolyline from "../custom-polyline"

//// MARKERS RELATED CODE
import markerIcon2x from "./../../markers/default/marker-icon-2x.png"
import markerIcon from "./../../markers/default/marker-icon.png"
import markerShadow from "./../../markers/default/marker-shadow.png"

import parkMarker from "./../../markers/parking/park-marker-32x32.png"
import parkMarker2x from "./../../markers/parking/park-marker-64x64.png"

import daffodilMarker from "./../../markers/daffodil/daffodil-marker-32x32.png"
import daffodilMarker2x from "./../../markers/daffodil/daffodil-marker-64x64.png"

import Icon from "../icons"

const chaletColDArtent = [
  46.00799922503996, 12.023267973535743,
] as LocationMarker

type LocationMarker = [lat: number, lon: number]
interface ComponentProps {
  markers: Location[]
  paths: {
    legend: string
    key: string
    path: [number, number][]
    color: string
    notes?: string
    time?: string
    totDistance?: string
    posElevation?: string
    negElevation?: string
    difficulty?: string
    type?: string
    mean: "car" | "foot"
  }[]
}

const MapComponent: React.FC<ComponentProps> = ({ markers, paths }) => {
  const [isClient, setIsClient] = useState(false)
  const [selectedPath, setSelectedPath] = useState(
    "piazza-lentiai-chalet-col-d-artent",
  )

  // Enable rendering on the client side
  useEffect(() => {
    setIsClient(true)
  }, [])

  const showPathInfo = useMemo(() => {
    const path = paths.find(path => path.key === selectedPath)
    if (!path) return null
    const {
      notes,
      time,
      totDistance,
      posElevation,
      negElevation,
      difficulty,
      type,
    } = path
    if (
      !notes ||
      !time ||
      !totDistance ||
      !posElevation ||
      !negElevation ||
      !difficulty ||
      !type
    )
      return null
    return {
      notes,
      time,
      totDistance,
      posElevation,
      negElevation,
      difficulty,
      type,
    }
  }, [selectedPath])

  if (!isClient) {
    return <p>Loading map...</p>
  }

  ///////// MARKERS RELATED STUFF
  const DefaultIcon = icon({
    iconUrl: markerIcon,
    iconRetinaUrl: markerIcon2x,
    shadowUrl: markerShadow,
    iconSize: [25, 41],
    iconAnchor: [12, 41],
  })
  MarkerLeaflet.prototype.options.icon = DefaultIcon
  const ParkIcon = icon({
    iconUrl: parkMarker,
    iconRetinaUrl: parkMarker2x,
    shadowUrl: markerShadow,
    iconSize: [33, 41],
    iconAnchor: [12, 41],
  })
  const DaffodilIcon = icon({
    iconUrl: daffodilMarker,
    iconRetinaUrl: daffodilMarker2x,
    shadowUrl: markerShadow,
    iconSize: [33, 41],
    iconAnchor: [12, 41],
  })

  const mapToMarker = (IconType?: string) => {
    switch (IconType) {
      case "park":
        return ParkIcon
      case "daffodil":
        return DaffodilIcon
      default:
        return DefaultIcon
    }
  }
  //////////////////////////////////////

  return (
    <S.Wrapper>
      <S.Legend>
        {paths.map(path => (
          <S.LegendElement
            key={path.key}
            $isSelected={selectedPath === path.key}
            onClick={() => setSelectedPath(path.key)}
          >
            <S.Dot $color={path.color} />
            <T.H3 style={{ textAlign: "center" }}>{path.legend}</T.H3>
          </S.LegendElement>
        ))}
      </S.Legend>
      <S.PathInfo>
        {showPathInfo && (
          <>
            <S.PathInfoUpper>
              <S.PathInfoElement>
                <S.PathInfoIcon>
                  <Icon type="time" />
                </S.PathInfoIcon>
                <T.P2 style={{ fontWeight: "bold" }}>{showPathInfo.time}</T.P2>
              </S.PathInfoElement>
              <S.PathInfoElement>
                <S.PathInfoIcon>
                  <Icon type="totDistance" />
                </S.PathInfoIcon>
                <T.P2 style={{ fontWeight: "bold" }}>
                  {showPathInfo.totDistance}
                </T.P2>
              </S.PathInfoElement>
              <S.PathInfoElement>
                <S.PathInfoIcon>
                  <Icon
                    type={
                      showPathInfo.type === "andata"
                        ? "andata"
                        : "andata-ritorno"
                    }
                  />
                </S.PathInfoIcon>
                <T.P2 style={{ fontWeight: "bold" }}>{showPathInfo.type}</T.P2>
              </S.PathInfoElement>
              <S.PathInfoElement>
                <S.PathInfoIcon>
                  <Icon type="posElevation" />
                </S.PathInfoIcon>
                <T.P2 style={{ fontWeight: "bold" }}>
                  {showPathInfo.posElevation}
                </T.P2>
              </S.PathInfoElement>
              <S.PathInfoElement>
                <S.PathInfoIcon>
                  <Icon type="negElevation" />
                </S.PathInfoIcon>
                <T.P2 style={{ fontWeight: "bold" }}>
                  {showPathInfo.negElevation}
                </T.P2>
              </S.PathInfoElement>
              <S.PathInfoElement>
                <S.PathInfoIcon>
                  <Icon type="hiker" />
                </S.PathInfoIcon>
                <T.P2 style={{ fontWeight: "bold" }}>
                  {showPathInfo.difficulty}
                </T.P2>
              </S.PathInfoElement>
            </S.PathInfoUpper>
            <T.P2>{showPathInfo.notes}</T.P2>
          </>
        )}
      </S.PathInfo>
      <MapContainer
        style={{ height: "500px", width: "100%" }}
        center={chaletColDArtent}
        zoom={12}
        scrollWheelZoom={true}
      >
        <TileLayer
          attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
        />
        {markers.map((marker, idx) => (
          <Marker
            key={`marker-${idx}`}
            position={[marker.lat, marker.lon]}
            icon={mapToMarker(marker.iconType)}
          >
            <S.LeafletPopupStyled offset={[-15, 20]}>
              {marker.name}
              {marker.name === "Parcheggio" && (
                <a
                  href={`https://www.google.com/maps?q=${marker.lat},${marker.lon}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  style={{ color: "blue", textDecoration: "underline" }}
                >
                  <br />
                  Apri Google Maps
                </a>
              )}
            </S.LeafletPopupStyled>
          </Marker>
        ))}

        {/* Static paths */}
        {paths.map(path => (
          <ExtendedPolyline
            pathOptions={{
              weight: path.key === selectedPath ? 8 : 4,
              dashArray: path.key === selectedPath ? "1, 0" : "1, 5",
              opacity: path.key === selectedPath ? 1 : 0.4,
            }}
            key={path.key}
            positions={path.path}
            color={path.color}
            hitTolerance={1000} // Expands the tap/click area // NOT WORKING
          />
        ))}
      </MapContainer>
    </S.Wrapper>
  )
}

export default MapComponent
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/map-narcisi/styled.ts
========================================

import styled from "styled-components"
import { breakpointNum, colors } from "../../styles"
import { Popup } from "react-leaflet"

export const Wrapper = styled.div`
  padding: 16px;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  gap: 10px;
`

export const LeafletPopupStyled = styled(Popup)`
  .leaflet-popup-tip-container {
    margin: 0;
  }
`

export const Legend = styled.div`
  display: flex;
  flex-direction: row;
  justify-content: space-around;
  padding: 24px;
  background-color: ${colors.green.green200};
  border-radius: 8px;
  column-gap: 1em;
  justify-content: center;
  @media (max-width: ${breakpointNum.tablet}px) {
    justify-content: space-between;
    padding: 16px;
    flex-wrap: wrap;
    row-gap: 1em;
  }
`

export const LegendElement = styled.div<{ $isSelected: boolean }>`
  cursor: pointer;
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 8px;
  ${({ $isSelected }) => ($isSelected ? "opacity: 1;" : "opacity: 0.4;")}
  transition: all 0.5s;
  > h3 {
    margin-top: 0px;
  }
  @media (max-width: ${breakpointNum.mobile}px) {
    gap: 4px;
  }
`

export const Dot = styled.div<{ $color: string }>`
  width: 12px;
  height: 12px;
  ${({ $color }) => `background-color: ${$color};`}
  border-radius: 50%;
`

export const PathInfo = styled.div`
  background-color: ${colors.green.green100};
  padding: 1em;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 110px;
`

export const PathInfoUpper = styled.div`
  display: flex;
  flex-direction: row;
  gap: 1em;
  width: 100%;
  justify-content: space-around;
`

export const PathInfoElement = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: center;
`

export const PathInfoIcon = styled.div`
  width: 24px;
  height: 24px;
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/sponsors/index.tsx
========================================

import React from "react"
import { graphql, useStaticQuery } from "gatsby"
import { GatsbyImage, getImage } from "gatsby-plugin-image"
import * as S from "./styled"

const sponsorsBase = [
  {
    name: 'AUSER Lentiai "Il Narciso"',
    fileName: "auser.png",
    url: "https://www.auser.veneto.it/belluno-alnarciso/dove-siamo.html",
  },
  {
    name: "Unifarco",
    fileName: "unifarco.png",
    url: "https://www.unifarco.it/",
  },
  {
    name: "Geometrie D'Arredo",
    fileName: "geometrie-d-arredo.png",
    url: "https://www.geometriedarredo.it/",
  },
  {
    name: "FPB Cassa di Fassa Primiero Belluno",
    fileName: "fpb-cassa.png",
    url: "https://www.fpbcassa.it/",
  },
  {
    name: "Farmacia Dr. A. Zampol",
    fileName: "farmacia-zampol.png",
    url: "https://www.farmaciedelpiave.it/farmacia-zampol-d-ortia.php",
  },
  {
    name: "Bon Tajer",
    fileName: "bon-tajer.png",
    url: "https://bontajer.it/",
  },
  {
    name: "Offredi Ofsolar",
    fileName: "offredi.png",
    url: "https://www.offrediofsolar.it/",
  },
  {
    name: "Supermercati Walber",
    fileName: "superw.png",
    url: "https://www.walber.it/punto-vendita/lentiai",
  },
  {
    name: "Dolomiti Canapa",
    fileName: "dolomiti-canapa.png",
    url: "https://www.dolomiticanapa.com/",
  },
]

const Sponsors = () => {
  const data = useStaticQuery(graphql`
    query {
      allFile(filter: { sourceInstanceName: { eq: "logos" }, extension: { in: ["png", "jpg", "jpeg", "webp"] } }) {
        nodes {
          base
          childImageSharp {
            gatsbyImageData(
              width: 200
              placeholder: NONE
              formats: [AUTO, WEBP, AVIF]
              layout: CONSTRAINED
            )
          }
        }
      }
    }
  `)

  const images = data.allFile.nodes

  return (
    <S.SponsorGrid>
      {sponsorsBase.map((sponsor, idx) => {
        const imgNode = images.find((img: any) => img.base === sponsor.fileName)
        const gatsbyImg = imgNode ? getImage(imgNode.childImageSharp) : null

        return (
          <a
            href={sponsor.url}
            target="_blank"
            rel="noopener noreferrer"
            title={sponsor.name}
            key={`sponsor-${idx}`}
          >
            <S.Sponsor>
              {gatsbyImg && (
                <GatsbyImage
                  image={gatsbyImg}
                  alt={sponsor.name}
                  objectFit="contain"
                  style={{ maxHeight: "50px", maxWidth: "120px" }}
                />
              )}
            </S.Sponsor>
          </a>
        )
      })}
    </S.SponsorGrid>
  )
}

export default SponsorsGenerated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/sponsors/styled.ts
========================================

import styled from "styled-components"

export const Sponsor = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  height: 50px;
  width: 120px;
  
  .gatsby-image-wrapper {
    max-height: 100%;
    max-width: 100%;
  }
`

export const SponsorGrid = styled.div`
  width: 100%;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 0.7rem;
  justify-items: center;
  a {
    display: ruby;
  }
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/sustain-us/index.tsx
========================================

import Icon from "../icons"
import sustainUs from "./../../data/sustain-us.json"
import React from "react"
import * as S from "./styled"
import * as T from "./../typography"

const bankDetails = {
  IBAN: sustainUs["IBAN"].account,
  bank: sustainUs["IBAN"].bank,
  icon: <Icon type="bank" />,
}

const SustainUs = () => {
  return (
    <S.Wrapper>
      <S.HeaderWrapper>
        <T.H2>Ti piace quello che facciamo e condividi i nostri ideali?</T.H2>
        <T.H1 $font="Caveat">Sostienici!</T.H1>
      </S.HeaderWrapper>
      <S.ContentWrapper>
        <S.IconWrapper>{bankDetails.icon}</S.IconWrapper>
        <S.IBANWrapper>
          <T.H2>{bankDetails.IBAN}</T.H2>
          <T.P3>{bankDetails.bank}</T.P3>
        </S.IBANWrapper>
      </S.ContentWrapper>
    </S.Wrapper>
  )
}

export default SustainUs
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/sustain-us/styled.ts
========================================

import styled from "styled-components"
import { breakpointNum } from "../../styles"

export const Wrapper = styled.div`
  padding: 32px;
  @media (max-width: ${breakpointNum.tablet}px) {
    padding: 24px;
  }
  @media (max-width: ${breakpointNum.mobile}px) {
    padding: 16px;
  }
`

export const HeaderWrapper = styled.div`
  justify-items: center;
  text-align: center;
`

export const ContentWrapper = styled.div`
  display: flex;
  flex-direction: row;
  gap: 1.5em;
  justify-content: center;
  padding-top: 4em;
`

export const IconWrapper = styled.div`
  > svg {
    width: 4em !important;
    height: 4em !important;
    @media (max-width: ${breakpointNum.tablet}px) {
      width: 2.5em !important;
      height: 2.5em !important;
    }
  }
  align-content: center;
`

export const IBANWrapper = styled.div`
  display: flex;
  align-items: center;
  justify-items: center;
  flex-direction: column;
  > h2 {
    margin-top: 0;
  }
  > p {
    align-self: start;
  }
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/work-in-progress/index.tsx
========================================

import React from "react"
import Icon from "../icons"
import * as S from "./styled"
import * as T from "./../typography"

const WorkInProgress = () => (
  <S.Wrapper>
    <Icon type="wip" width={300} />
    <T.H1 style={{ marginTop: 0 }} $font="Caveat">
      Stiamo lavorando per voi...!
    </T.H1>
  </S.Wrapper>
)

export default WorkInProgress
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/work-in-progress/styled.ts
========================================

import styled from "styled-components"
import { colors } from "../../styles"

export const Wrapper = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  > svg > * {
    fill: ${colors.green.green900};
  }
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/map-laghetti/helpers.ts
========================================

// This function is to be used to decode the polyline

const decodePolyline = (encoded: string) => {
  let points = []
  let index = 0
  let lat = 0
  let lng = 0

  while (index < encoded.length) {
    let b,
      shift = 0,
      result = 0
    do {
      b = encoded.charCodeAt(index++) - 63
      result |= (b & 0x1f) << shift
      shift += 5
    } while (b >= 0x20)
    let deltaLat = result & 1 ? ~(result >> 1) : result >> 1
    lat += deltaLat

    shift = 0
    result = 0
    do {
      b = encoded.charCodeAt(index++) - 63
      result |= (b & 0x1f) << shift
      shift += 5
    } while (b >= 0x20)
    let deltaLng = result & 1 ? ~(result >> 1) : result >> 1
    lng += deltaLng

    points.push([lat / 1e5, lng / 1e5])
  }

  return points
}
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/map-laghetti/index.tsx
========================================

import "leaflet-css"
import React, { useEffect, useState } from "react"
import { MapContainer, Marker, TileLayer } from "react-leaflet"
import { Location } from "../../types"
import * as T from "./../typography"
import * as S from "./styled"

import { Marker as MarkerLeaflet, icon } from "leaflet"
import ExtendedPolyline from "../custom-polyline"

//// MARKERS RELATED CODE
import markerIcon2x from "./../../markers/default/marker-icon-2x.png"
import markerIcon from "./../../markers/default/marker-icon.png"
import markerShadow from "./../../markers/default/marker-shadow.png"

import parkMarker from "./../../markers/parking/park-marker-32x32.png"
import parkMarker2x from "./../../markers/parking/park-marker-64x64.png"

const piazzaCenter = [46.04523644005277, 12.023334355216095] as LocationMarker

type LocationMarker = [lat: number, lon: number]
interface ComponentProps {
  markers: Location[]
  paths: {
    legend: string
    key: string
    path: [number, number][]
    color: string
  }[]
}

const MapComponent: React.FC<ComponentProps> = ({ markers, paths }) => {
  const [isClient, setIsClient] = useState(false)
  const [hoveredPath, setHoveredPath] = useState("")

  // Enable rendering on the client side
  useEffect(() => {
    setIsClient(true)
  }, [])

  if (!isClient) {
    return <p>Loading map...</p>
  }

  ///////// MARKERS RELATED STUFF
  const DefaultIcon = icon({
    iconUrl: markerIcon,
    iconRetinaUrl: markerIcon2x,
    shadowUrl: markerShadow,
    iconSize: [25, 41],
    iconAnchor: [12, 41],
  })
  MarkerLeaflet.prototype.options.icon = DefaultIcon
  const ParkIcon = icon({
    iconUrl: parkMarker,
    iconRetinaUrl: parkMarker2x,
    shadowUrl: markerShadow,
    iconSize: [33, 41],
    iconAnchor: [12, 41],
  })

  const mapToMarker = (IconType?: string) => {
    switch (IconType) {
      case "park":
        return ParkIcon
      default:
        return DefaultIcon
    }
  }
  //////////////////////////////////////

  return (
    <S.Wrapper>
      <S.Legend>
        {paths.map(path => (
          <S.LegendElement
            key={path.key}
            $isHovered={!hoveredPath || hoveredPath === path.key}
            onMouseOver={() => setHoveredPath(path.key)}
            onMouseOut={() => setHoveredPath("")}
          >
            <S.Dot $color={path.color} />
            <T.H3>{path.legend}</T.H3>
          </S.LegendElement>
        ))}
      </S.Legend>
      <MapContainer
        style={{ height: "500px", width: "100%" }}
        center={piazzaCenter}
        zoom={14}
        scrollWheelZoom={true}
      >
        <TileLayer
          attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
        />
        {markers.map((marker, idx) => (
          <Marker
            key={`marker-${idx}`}
            position={[marker.lat, marker.lon]}
            icon={mapToMarker(marker.iconType)}
          >
            <S.LeafletPopupStyled offset={[-15, 20]}>
              {marker.name}
              <a
                href={`https://www.google.com/maps?q=${marker.lat},${marker.lon}`}
                target="_blank"
                rel="noopener noreferrer"
                style={{ color: "blue", textDecoration: "underline" }}
              >
                <br />
                Apri Google Maps
              </a>
            </S.LeafletPopupStyled>
          </Marker>
        ))}

        {/* Static paths */}
        {paths.map(path => (
          <ExtendedPolyline
            eventHandlers={{
              mouseover: _ => {
                setHoveredPath(path.key)
              },
              mouseout: _ => {
                setHoveredPath("")
              },
              click: _ => {
                setHoveredPath(path.key)
              },
            }}
            pathOptions={{
              weight: path.key === hoveredPath ? 8 : 4,
              dashArray: path.key === hoveredPath ? "1, 0" : "1, 5",
            }}
            key={path.key}
            positions={path.path as [number, number][]}
            color={path.color}
            opacity={0.8}
            hitTolerance={1000} // Expands the tap/click area // NOT WORKING
          />
        ))}

        {/* Dynamic paths */}
        {/* {pathCoordinates.length >= 2 && (
          <RouteControl
            waypoints={pathCoordinates}
          />
        )} */}
      </MapContainer>
    </S.Wrapper>
  )
}

/////// CODE TO RENDER DYNAMIC COMPONENTS
// Route Control Component for Road Path
// import "leaflet-routing-machine"

// Extend RoutingControlOptions to include createMarker
// interface ExtendedRoutingControlOptions
//   extends L.Routing.RoutingControlOptions {
//   createMarker?: (
//     i: number,
//     waypoint: L.Routing.Waypoint,
//     n: number,
//   ) => L.Marker | null
// }

// const RouteControl: React.FC<{ waypoints: [number, number][] }> = ({
//   waypoints,
// }) => {
//   const map = useMap()
//   const routingControlRef = React.useRef<L.Routing.Control | null>(null)

//   useEffect(() => {
//     if (typeof window === "undefined" || waypoints.length < 2) return

//     const routingControl = L.Routing.control({
//       waypoints: waypoints.map(coords => L.latLng(coords[0], coords[1])),
//       routeWhileDragging: false,
//       show: false,
//       addWaypoints: false,
//       createMarker: () => null, // Prevent default markers from being added
//       router: new L.Routing.OSRMv1({
//         serviceUrl: "https://router.project-osrm.org/route/v1", // OSRM service URL
//         profile: "foot", // Use the 'foot' profile for pedestrian routes
//       }),
//     } as ExtendedRoutingControlOptions).addTo(map)

//     routingControlRef.current = routingControl

//     // Hide the summary box after the control is added
//     const controlContainer = routingControl.getContainer()
//     if (controlContainer) {
//       controlContainer.style.display = "none"
//     }

//     return () => {
//       map.removeControl(routingControl)
//       routingControlRef.current = null
//     }
//   }, [map, waypoints])

//   return null
// }

export default MapComponent
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/map-laghetti/styled.ts
========================================

import styled from "styled-components"
import { breakpointNum, colors } from "../../styles"
import { Popup } from "react-leaflet"

export const Wrapper = styled.div`
  padding: 16px;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  gap: 10px;
`

export const LeafletPopupStyled = styled(Popup)`
  .leaflet-popup-tip-container {
    margin: 0;
  }
`

export const Legend = styled.div`
  display: flex;
  flex-direction: row;
  justify-content: space-around;
  padding: 24px;
  background-color: ${colors.green.green200};
  border-radius: 8px;
  column-gap: 1em;
  justify-content: center;
  @media (max-width: ${breakpointNum.tablet}px) {
    justify-content: space-between;
    padding: 16px;
    flex-wrap: wrap;
    row-gap: 1em;
  }
`

export const LegendElement = styled.div<{ $isHovered: boolean }>`
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 8px;
  ${({ $isHovered }) => ($isHovered ? "opacity: 1;" : "opacity: 0.4;")}
  transition: all 0.5s;
  > h3 {
    margin-top: 0px;
  }
  @media (max-width: ${breakpointNum.mobile}px) {
    gap: 4px;
  }
`

export const Dot = styled.div<{ $color: string }>`
  width: 12px;
  height: 12px;
  ${({ $color }) => `background-color: ${$color};`}
  border-radius: 50%;
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/contact-us/index.tsx
========================================

import React from "react"
import * as S from "./styled"
import Icon from "../icons"
import * as T from "./../typography"
import contacts from "./../../data/contacts.json"

const ContactUs = () => {
  const contactData = [
    {
      icon: <Icon type="facebook" width={32} />,
      text: "I Laghetti della Rimonta - Bardies ",
      linkURL: contacts["facebook-laghetti"],
      onClickHandler: undefined,
    },
    {
      icon: <Icon type="facebook" width={32} />,
      text: "Borgo Valbelluna-montagna-narcisi ",
      linkURL: contacts["facebook-narcisi"],
      onClickHandler: undefined,
    },
    {
      icon: <Icon type="youtube" width={32} />,
      text: "Gruppo Natura Lentiai",
      linkURL: contacts["youtube"],
      onClickHandler: undefined,
    },
    {
      icon: <Icon type="phone" width={32} />,
      text: contacts["phone"].join(" "),
      linkURL: undefined,
      onClickHandler: () => {
        window.location.href = `tel:${contacts["phone"].join("")}`
      },
    },
    {
      icon: <Icon type="whatsapp" width={32} />,
      text: contacts["phone"].join(" "),
      linkURL: undefined,
      onClickHandler: () => {
        window.open(
          `https://wa.me/${contacts["phone"].join("").replace(/\D/g, "")}`,
          "_blank",
        )
      },
    },
    {
      icon: <Icon type="email" width={32} />,
      text: contacts["email"].join(""),
      linkURL: undefined,
      onClickHandler: () => {
        window.location.href = `mailto:${contacts["email"].join("")}`
      },
    },
  ]

  return (
    <S.Wrapper>
      <S.Title $font="Caveat">Contattaci!</S.Title>
      <S.ContactsWrapper>
        {contactData.map((el, idx) => (
          <S.Row key={idx}>
            {el.linkURL ? (
              <a href={el.linkURL} target="_blank" rel="noopener noreferrer">
                <S.IconWrapper onClick={el.onClickHandler}>
                  {el.icon}
                </S.IconWrapper>
              </a>
            ) : (
              <S.IconWrapper onClick={el.onClickHandler}>
                {el.icon}
              </S.IconWrapper>
            )}
            <S.LinkText onClick={el.onClickHandler}>
              {el.linkURL ? (
                <a href={el.linkURL} target="_blank" rel="noopener noreferrer">
                  <T.H2>{el.text}</T.H2>
                </a>
              ) : (
                <T.H2>{el.text}</T.H2>
              )}
            </S.LinkText>
          </S.Row>
        ))}
      </S.ContactsWrapper>
    </S.Wrapper>
  )
}

export default ContactUs
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/contact-us/styled.ts
========================================

import styled from "styled-components"
import * as T from "./../typography"
import { colors } from "../../styles"

export const Wrapper = styled.div`
  padding: 32px;
`

export const Title = styled(T.H1)`
  text-align: center;
`

export const IconWrapper = styled.div`
  cursor: pointer;
  margin-top: 8px;
  transition: all 0.5s;
  > * {
    transition: all 0.5s;
    fill: ${colors.green.green800};
    &:hover {
      fill: ${colors.green.green900};
    }
    &:focus {
      fill: ${colors.green.green950};
    }
    > * {
      transition: all 0.5s;
      fill: ${colors.green.green800};
      &:hover {
        fill: ${colors.green.green900};
      }
      &:focus {
        fill: ${colors.green.green950};
      }
      > * {
        transition: all 0.5s;
        fill: ${colors.green.green800};
        &:hover {
          fill: ${colors.green.green900};
        }
        &:focus {
          fill: ${colors.green.green950};
        }
      }
    }
  }
`

export const LinkText = styled.div`
  cursor: pointer;

  > a {
    text-decoration: none;
    color: ${colors.green.green800};
    > h2 {
      margin: 0;
    }
  }

  > h2 {
    margin: 0;
  }
`

export const ContactsWrapper = styled.div`
  display: flex;
  flex-direction: column;
  gap: 20px;
  justify-content: center;
  padding: 32px;
`

export const Row = styled.div`
  display: flex;
  flex-direction: row;
  gap: 20px;
  align-items: center;
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/portable-text-components/index.tsx
========================================

import {
  PortableTextComponentProps,
  PortableTextMarkComponentProps,
  PortableTextReactComponents,
} from "@portabletext/react"
import React from "react"
import { getSanityImageUrl } from "../../helpers"
import * as S from "./styled"
import * as T from "../typography"

const InlineText = ({ children }: { children: React.ReactNode }) => (
  <T.P1 as="span" style={{ display: "inline", margin: 0, lineHeight: "2em" }}>
    {children}
  </T.P1>
)

const Components: PortableTextReactComponents = {
  types: {
    image: ({ value }: { value: any }) => {
      if (!value.asset || !value.asset._ref) return null

      const imageUrl = getSanityImageUrl(value.asset._ref)
      if (!imageUrl) return null

      return (
        <S.ImageWrapper $position={value.position ?? "center"}>
          <S.ResponsiveImg
            src={imageUrl}
            alt={value.textAlt || "Content image"}
            style={{
              height: "auto",
              display: "block",
              margin: "1em 0",
            }}
          />
          {value.undertext && (
            <S.ImgDescription>{value.undertext}</S.ImgDescription>
          )}
        </S.ImageWrapper>
      )
    },
  },
  block: {
    normal: ({ children }) => (
      <T.P1 style={{ lineHeight: "1.6", margin: "1em 0" }}>{children}</T.P1>
    ),
    h1: ({ children }) => (
      <T.H1 style={{ margin: "1.2em 0 0.6em" }}>{children}</T.H1>
    ),
    h2: ({ children }) => (
      <T.H2 style={{ margin: "1.2em 0 0.6em" }}>{children}</T.H2>
    ),
    h3: ({ children }) => (
      <T.H3 style={{ margin: "1.2em 0 0.6em" }}>{children}</T.H3>
    ),
  },
  marks: {
    link: ({ value, children }: PortableTextMarkComponentProps<any>) => {
      const { href } = value
      return (
        <a
          href={href}
          target="_blank"
          rel="noopener noreferrer"
          style={{ color: "blue" }}
        >
          {children}
        </a>
      )
    },
  },
  list: {
    bullet: ({ children }: PortableTextComponentProps<any>) => (
      <ul>{children}</ul>
    ),
    number: ({ children }: PortableTextComponentProps<any>) => (
      <ol>{children}</ol>
    ),
  },
  listItem: {
    bullet: ({ children }) => (
      <li>
        <InlineText>{children}</InlineText>
      </li>
    ),
    number: ({ children }) => (
      <li>
        <InlineText>{children}</InlineText>
      </li>
    ),
  },
  hardBreak: () => <br />,
  unknownMark: ({ children }: PortableTextMarkComponentProps<any>) => (
    <span style={{ backgroundColor: "yellow" }}>{children}</span>
  ),
  unknownType: ({ value }: { value: any }) => (
    <div style={{ border: "1px solid red", padding: "10px" }}>
      Unknown type: {JSON.stringify(value)}
    </div>
  ),
  unknownBlockStyle: ({ children }: PortableTextComponentProps<any>) => (
    <div style={{ fontStyle: "italic", color: "gray" }}>{children}</div>
  ),
  unknownList: ({ children }: PortableTextComponentProps<any>) => (
    <ul style={{ listStyle: "square" }}>{children}</ul>
  ),
  unknownListItem: ({ children }: PortableTextComponentProps<any>) => (
    <li style={{ color: "red" }}>{children}</li>
  ),
}

export default Components
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/portable-text-components/styled.ts
========================================

import styled from "styled-components"
import * as T from "../typography"
import { breakpointNum } from "../../styles"

export const ImageWrapper = styled.div<{
  $position?: "left" | "right" | "center"
}>`
  display: flex;
  flex-direction: column;
  align-items: ${({ $position }) => {
    switch ($position) {
      case "left":
        return "flex-start"
      case "right":
        return "flex-end"
      default:
        return "center"
    }
  }};
  text-align: ${({ $position }) =>
    $position === "center" ? "center" : "inherit"};
`

export const ResponsiveImg = styled.img`
  height: auto;
  display: block;
  margin: 1em 0;
  max-width: 50%;
  object-fit: contain;
  @media (max-width: ${breakpointNum.bigtablet}px) {
    max-width: 80%;
  }
  @media (max-width: ${breakpointNum.smalltablet}px) {
    max-width: 100%;
  }
`

export const ImgDescription = styled(T.P4)`
  font-style: italic;
  text-align: center;
  margin-block-start: 0.5em;
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/carousel/index.tsx
========================================

import React, { useCallback, useEffect, useState } from "react"
import { ImageData } from "../../types"
import * as T from "./../typography"
import * as S from "./styled"
import Icon from "../icons"
import useSwipe from "../../hooks/useSwipe"
import useResponsiveClickHandler from "../../hooks/useResponsiveClickHandler"
import { breakpoint, breakpointNum, horizBreakpointsHeight } from "../../styles"
import usePreventScrollOnImageView from "../../hooks/usePreventDragAndWheel"

interface CarouselProps {
  images: ImageData[]
}

const Carousel: React.FC<CarouselProps> = ({ images }) => {
  const [currentIndex, setCurrentIndex] = useState(0)
  const [showLargeImage, setShowLargeImage] = useState(false)
  const swipeHandlers = useSwipe({
    onSwipedLeft: () => {
      setCurrentIndex(prev => (prev === images.length - 1 ? 0 : prev + 1))
    },
    onSwipedRight: () => {
      setCurrentIndex(prev => (prev === 0 ? images.length - 1 : prev - 1))
    },
  })

  const handlePrev = () => {
    setCurrentIndex(prev => (prev === 0 ? images.length - 1 : prev - 1))
  }

  const handleNext = () => {
    setCurrentIndex(prev => (prev === images.length - 1 ? 0 : prev + 1))
  }

  const onClickImage = () => {
    setShowLargeImage(true)
  }

  const closeImage = () => {
    setShowLargeImage(false)
  }

  // Use arrows to move back and forth
  const handleKeyDown = useCallback(
    (event: KeyboardEvent) => {
      if (event.key === "ArrowLeft") {
        handlePrev()
      } else if (event.key === "ArrowRight") {
        handleNext()
      }
    },
    [handlePrev, handleNext],
  )
  useEffect(() => {
    window.addEventListener("keydown", handleKeyDown)
    return () => {
      window.removeEventListener("keydown", handleKeyDown)
    }
  }, [handleKeyDown])

  // If we are seeing an image, prevent the
  // the user to scroll and drag up/down
  usePreventScrollOnImageView(showLargeImage)

  const getStyles = (index: number) => {
    const distance = Math.abs(index - currentIndex)
    const isExtreme = distance >= 2
    const isCentralImage = distance === 0
    const isSideImage = distance === 1
    return {
      scale: isExtreme ? 0.25 : isSideImage ? 0.5 : 1,
      zIndex: isCentralImage ? 3 : isSideImage ? 2 : 1,
      opacity: isCentralImage ? 1 : isSideImage ? 0.66 : 0.33,
      x: `${(index - currentIndex) * 33}%`,
    }
  }

  return (
    <>
      <S.OuterWrapper>
        <S.ButtonWrapper $position="left" onClick={handlePrev}>
          <Icon type="chevron" width={24} />
        </S.ButtonWrapper>
        <S.Wrapper>
          {images.map((image, index) => (
            <S.CarouselItem
              $isCurrentImage={currentIndex === index}
              key={index}
              animate={getStyles(index)}
              transition={{ duration: 0.5, ease: "easeInOut" }}
              {...(currentIndex === index ? swipeHandlers : {})}
            >
              <T.H2
                className="title"
                dangerouslySetInnerHTML={{ __html: image.title }}
              />
              <S.ImgWrapper
                $showZoom={currentIndex === index}
                onClick={currentIndex === index ? onClickImage : undefined}
              >
                {image.image && (
                  <S.StyledGatsbyImage
                    key={`img-${index}`}
                    image={image.image}
                    alt={image.alt || "Content Data"}
                  />
                )}
              </S.ImgWrapper>
              <S.Shadow />
              {image.copyright ? (
                <T.P4 className="copyright">Foto di {image.copyright}</T.P4>
              ) : (
                <T.P4 className="copyright">Autore sconosciuto</T.P4>
              )}
              <T.P2
                className="caption"
                dangerouslySetInnerHTML={{ __html: image.description }}
              />
            </S.CarouselItem>
          ))}
        </S.Wrapper>
        <S.ButtonWrapper $position="right" onClick={handleNext}>
          <Icon type="chevron" width={24} />
        </S.ButtonWrapper>
      </S.OuterWrapper>
      {showLargeImage && images[currentIndex].image && (
        <S.ImageOverlay className={showLargeImage ? "visible" : ""}>
          <S.CloseImageCaption onClick={closeImage}>
            Chiudi X
          </S.CloseImageCaption>
          <S.LargeImageWrapper>
            {images[currentIndex].title && (
              <T.H2
                className="title"
                dangerouslySetInnerHTML={{ __html: images[currentIndex].title }}
                style={{ marginBottom: 4 }}
              />
            )}
            <S.StyledGatsbyImageLarge
              image={images[currentIndex].image}
              alt={images[currentIndex].alt || "Enlarged Image"}
              style={{ overflow: "visible", maxHeight: "80vh" }}
            />
            {images[currentIndex].copyright ? (
              <T.P4 className="copyright">
                Foto di {images[currentIndex].copyright}
              </T.P4>
            ) : (
              <T.P4 className="copyright">Autore sconosciuto</T.P4>
            )}
            {images[currentIndex].description && (
              <T.P2
                className="caption"
                dangerouslySetInnerHTML={{
                  __html: images[currentIndex].description,
                }}
              />
            )}
          </S.LargeImageWrapper>
        </S.ImageOverlay>
      )}
    </>
  )
}

export default Carousel
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/carousel/styled.ts
========================================

import { motion } from "framer-motion"
import { GatsbyImage } from "gatsby-plugin-image"
import styled from "styled-components"
import { breakpointNum, colors, horizBreakpointsHeight } from "../../styles"
import * as T from "./../typography"

export const OuterWrapper = styled.div`
  justify-content: space-between;
  overflow: hidden;
  align-items: center;
  display: flex;
  flex-direction: row;
  min-width: calc(100vw - 82px);
  min-height: 85vh;
  @media (max-width: ${breakpointNum.tablet}px) {
    min-width: calc(100vw - 60px);
    min-height: 78vh;
  }
  @media (max-width: ${breakpointNum.mobile}px) {
    min-height: 70vh;
  }
  @media (max-height: ${horizBreakpointsHeight.medium}px) {
    min-height: 350px;
  }
`

export const Wrapper = styled.div`
  position: relative;
  width: 90%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
`

export const ButtonWrapper = styled.div<{ $position: "left" | "right" }>`
  background-color: ${colors.green.green400};
  border-radius: 50%;
  border: 1px solid ${colors.green.green800};
  z-index: 13;
  width: 36px;
  height: 36px;
  cursor: pointer;
  transition: all 0.5s;
  margin: 0 1em;
  @media (max-width: ${breakpointNum.mobile}px) {
    width: 24px;
    height: 24px;
  }

  ${({ $position }) =>
    $position === "left"
      ? `box-shadow: -2px 2px 4px ${colors.green.green950};`
      : `box-shadow: 2px 2px 4px ${colors.green.green950};`}

  > svg {
    ${({ $position }) =>
      $position === "left"
        ? "transform: rotate(90deg);"
        : "transform: rotate(-90deg);"}
    fill: ${colors.green.green700};
    margin-top: 6px;
    ${({ $position }) =>
      $position === "left" ? "margin-left: 3px;" : "margin-left: 8px;"}
    transition: all 0.5s;

    @media (max-width: ${breakpointNum.mobile}px) {
      ${({ $position }) =>
        $position === "left" ? "margin-left: -2px;" : "margin-left: 1px;"}
      height: 12px;
    }
  }
  &:hover {
    background-color: ${colors.green.green500};
    > svg {
      fill: ${colors.green.green800};
    }
  }
  &:active {
    background-color: ${colors.green.green550};
    > svg {
      fill: ${colors.green.green900};
    }
  }
`

export const Shadow = styled.div`
  padding: 5px;
  width: 50%;
  height: 10px;
  background: radial-gradient(
    ellipse at center,
    ${colors.green.green900},
    transparent
  );
  filter: blur(8px);
  opacity: 0.8;
`

export const CarouselItem = styled(motion.div)<{ $isCurrentImage: boolean }>`
  position: absolute;
  transform: translate(-50%, -50%);
  max-height: 700px;
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  .title {
    padding-bottom: 5px;
    width: 100%;
    text-align: center;
    ${({ $isCurrentImage }) => !$isCurrentImage && "opacity: 0.6;"}
  }
  .caption {
    margin-top: 1.5em;
    text-align: center;
    ${({ $isCurrentImage }) => !$isCurrentImage && "opacity: 0.6;"}
  }
  .copyright {
    margin-top: 1em;
    text-align: center;
    ${({ $isCurrentImage }) => !$isCurrentImage && "opacity: 0.6;"}
  }
`

export const ImgWrapper = styled.div<{ $showZoom: boolean }>`
  ${({ $showZoom }) => $showZoom && "cursor: zoom-in;"}
`

export const StyledGatsbyImage = styled(GatsbyImage)`
  img {
    max-height: 55vh;
    @media (max-width: ${breakpointNum.bigtablet}px) {
      max-height: 50vh;
    }
    @media (max-width: ${breakpointNum.tablet}px) {
      max-height: 50vh;
    }
    @media (max-width: ${breakpointNum.mobile}px) {
      max-height: 50vh;
    }
    @media (max-height: ${horizBreakpointsHeight.medium}px) {
      max-height: 50vh;
    }
  }
`

export const ImageOverlay = styled.div`
  position: fixed;
  top: 0;
  width: 100vw;
  height: 100vh;
  background-color: ${colors.green.green950};
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  flex-direction: column;
  animation: fadeIn 0.5s ease-in-out forwards;
  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
`

export const CloseImageCaption = styled(T.H2)`
  position: absolute;
  top: 0px;
  right: 1.8em;
  color: ${colors.green.green50};
  cursor: pointer;
  transition: all 0.5s ease-in;
  @media (max-width: ${breakpointNum.mobile}px) {
    right: 1em;
  }
  &:hover {
    color: ${colors.green.green200};
  }
  &:active {
    color: ${colors.green.green300};
  }
`

export const LargeImageWrapper = styled.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  > * {
    color: ${colors.green.green100};
    text-align: center;
  }
`

export const StyledGatsbyImageLarge = styled(GatsbyImage)`
  border: solid 2px ${colors.green.green50};
  max-height: 70vh;
  max-width: 95vw;
  @media (max-width: ${breakpointNum.tablet}px) {
    max-height: 75vh;
    max-width: 90vw;
  }
  @media (max-width: ${breakpointNum.mobile}px) {
    max-height: 70vh;
    max-width: 90vw;
  }

  img {
    max-width: 100%;
    max-height: 80vh;
    transition: transform 0.3s ease-in-out;
    @media (max-width: ${breakpointNum.tablet}px) {
      max-height: 75vh;
      max-width: 90vw;
    }
    @media (max-width: ${breakpointNum.mobile}px) {
      max-height: 70vh;
      max-width: 90vw;
    }
    @media (max-height: ${horizBreakpointsHeight.thin}px) {
      max-height: 60vh;
      max-width: 80vw;
    }
  }
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/seo/index.tsx
========================================

import React from "react"
import { useStaticQuery, graphql } from "gatsby"

interface SEOProps {
  title?: string
  description?: string
  pathname?: string
  image?: string // Aggiungiamo l'immagine
  children?: React.ReactNode
}

export const SEO: React.FC<SEOProps> = ({
  title,
  description,
  pathname,
  image,
  children,
}) => {
  const { site } = useStaticQuery(graphql`
    query {
      site {
        siteMetadata {
          title
          description
          siteUrl
        }
      }
    }
  `)

  const seo = {
    title: title || site.siteMetadata.title,
    description: description || site.siteMetadata.description,
    image: image ? `${site.siteMetadata.siteUrl}${image}` : `${site.siteMetadata.siteUrl}/default-share-image.jpg`, // Inserisci un'immagine generica di fallback in static/
    url: `${site.siteMetadata.siteUrl}${pathname || ""}`,
  }

  return (
    <>
      <title>{seo.title}</title>
      <meta name="description" content={seo.description} />
      <link rel="canonical" href={seo.url} />

      {/* Open Graph / Facebook / WhatsApp */}
      <meta property="og:type" content="website" />
      <meta property="og:url" content={seo.url} />
      <meta property="og:title" content={seo.title} />
      <meta property="og:description" content={seo.description} />
      {seo.image && <meta property="og:image" content={seo.image} />}

      {/* Twitter */}
      <meta name="twitter:card" content="summary_large_image" />
      <meta name="twitter:url" content={seo.url} />
      <meta name="twitter:title" content={seo.title} />
      <meta name="twitter:description" content={seo.description} />
      {seo.image && <meta name="twitter:image" content={seo.image} />}

      {children}
    </>
  )
}Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/cookie-banner/index.tsx
========================================

import React, { useEffect, useState } from "react"
import CookiePreferences from "../cookie-preferences"
import * as S from "./styled"
import { colors } from "../../styles"

const CookieBanner = () => {
  const [visible, setVisible] = useState(false)
  const [showPreferences, setShowPreferences] = useState(false)

  useEffect(() => {
    const preferences = localStorage.getItem("cookie-preferences")
    const { analytics, lastUpdated } = JSON.parse(preferences || "{}")

    const shouldShowBanner = () => {
      // If keys are not present, show banner
      if (analytics === undefined || lastUpdated === undefined) return true
      // If keys are present, check if preferences are expired
      const lastConsentDate = new Date(lastUpdated)
      const now = new Date()
      const daysSinceConsent =
        (now.getTime() - lastConsentDate.getTime()) / (1000 * 60 * 60 * 24)
      // If preferences are expired, remove them and show banner
      const expiredPreferences = daysSinceConsent > 30
      if (expiredPreferences) {
        localStorage.removeItem("cookie-preferences")
      }
      return expiredPreferences
    }

    if (shouldShowBanner()) {
      setVisible(true)
    }
  }, [])

  const saveConsent = (consentType: "all" | "necessary") => {
    const preferences = {
      analytics: consentType === "all",
      lastUpdated: new Date().toISOString(),
    }

    localStorage.setItem("cookie-preferences", JSON.stringify(preferences))
    setVisible(false)

    if (consentType === "necessary") {
      clearAnalyticsCookies()
    }
  }

  const clearAnalyticsCookies = () => {
    const cookies = document.cookie.split(";")
    cookies.forEach(cookie => {
      const name = cookie.split("=")[0].trim()
      // Clear Google Analytics and Gatsby cookies
      if (
        name.startsWith("_") ||
        name.startsWith("ga") ||
        name.startsWith("_ga") ||
        name.startsWith("_gid") ||
        name.startsWith("_gat") ||
        name.startsWith("gatsby")
      ) {
        document.cookie = `${name}=; Max-Age=0; path=/; domain=${window.location.hostname};`
      }
    })
  }

  return (
    <>
      {visible && (
        <S.BannerContainer>
          <S.BannerText>
            Utilizziamo cookie tecnici necessari per il funzionamento del sito e
            cookie analitici per migliorare la tua esperienza. I cookie tecnici
            sono sempre attivi, mentre quelli analitici richiedono il tuo
            consenso.
          </S.BannerText>
          <S.ButtonRow>
            <S.BannerButton
              onClick={() => saveConsent("all")}
              color={colors.green.green600}
              aria-label="Accetta tutti i cookie"
            >
              <S.ButtonText>Accetta tutti</S.ButtonText>
            </S.BannerButton>
            <S.BannerButton
              onClick={() => saveConsent("necessary")}
              color={colors.green.green800}
              aria-label="Rifiuta tutti i cookie tranne quelli tecnici"
            >
              <S.ButtonText>Accetta solo necessari</S.ButtonText>
            </S.BannerButton>
            <S.BannerButton
              onClick={() => setShowPreferences(true)}
              color="transparent"
              border={`1px solid ${colors.green.green600}`}
              aria-label="Gestisci le preferenze dei cookie"
            >
              <S.ButtonText>Personalizza</S.ButtonText>
            </S.BannerButton>
          </S.ButtonRow>
        </S.BannerContainer>
      )}
      {showPreferences && (
        <CookiePreferences
          onClose={() => {
            setShowPreferences(false)
            // Also hide the banner when preferences are saved
            const prefs = localStorage.getItem("cookie-preferences")
            if (prefs) {
              setVisible(false)
            }
          }}
        />
      )}
    </>
  )
}

export default CookieBanner
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/cookie-banner/styled.ts
========================================

import styled from "styled-components"
import { breakpoint, colors } from "../../styles"
import * as T from "../typography"

// Styled Components
export const BannerContainer = styled.div`
  position: fixed;
  bottom: 0;
  width: 100%;
  background-color: ${colors.green.green900};
  color: white;
  padding: 1rem;
  text-align: center;
  z-index: 1000;
  @media (max-width: ${breakpoint.verylarge}) {
    width: 100%;
    padding: 1rem 0;
  }
`

export const BannerText = styled(T.P2)`
  margin: 0 0 1rem 0;
  color: ${colors.green.green50};
`

export const ButtonRow = styled.div`
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  flex-wrap: wrap;
`

export const ButtonText = styled(T.P2)`
  margin: 0;
  color: white;
`

export const BannerButton = styled.button<{ color: string; border?: string }>`
  background-color: ${props => props.color};
  color: white;
  padding: 0.5rem 1rem;
  border: ${props => props.border || "none"};
  border-radius: 5px;
  cursor: pointer;
  &:hover {
    background-color: ${props => `${props.color}cc`};
    transition: all 0.3s ease;
  }
  &:active {
    background-color: ${props => `${props.color}80`};
    transition: all 0.3s ease;
  }
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/header/index.tsx
========================================

import { Link } from "gatsby"
import React, { useState } from "react"
import Icon from "../icons"
import * as T from "../typography"
import { navItems } from "./../../data/sections"
import * as S from "./styled"
import { useLocation } from "@reach/router"

import { ReactComponent as FaiLogo } from "../../logos/fai-logo.svg"

const Header: React.FC = () => {
  const [menuOpen, setMenuOpen] = useState<string>("")
  const [mobileMenuOpen, setMobileMenuOpen] = useState<boolean>(false)
  const rootPath = useLocation().pathname.split("/").slice(0, 2).join("/")

  return (
    <>
      <S.Header>
        <S.LeftWrapper>
          <Link to="/" aria-label="Vai alla home">
            <Icon type="logo" />
          </Link>
        </S.LeftWrapper>
        <S.RightWrapper>
          <S.NavBarList>
            {navItems.map(el => (
              <S.NavBarItem
                key={el.label}
                $isActive={rootPath === el.url}
                onMouseOver={() => setMenuOpen(el.label)}
                onMouseLeave={() => setMenuOpen("")}
              >
                <Link to={el.url}>
                  <T.H5>{el.label}</T.H5>
                </Link>
                {el.subsections && (
                  <S.SubsectionList
                    onMouseLeave={() => setMenuOpen("")}
                    $isOpen={el.label === menuOpen}
                  >
                    {el.subsections.map(subSection => (
                      <S.SubsectionItem key={subSection.url}>
                        <Link to={subSection.url}>
                          <T.H5>{subSection.label}</T.H5>
                        </Link>
                      </S.SubsectionItem>
                    ))}
                  </S.SubsectionList>
                )}
              </S.NavBarItem>
            ))}
          </S.NavBarList>

          <S.FaiWrapper>
            <a href="https://fondoambiente.it" target="_blank" rel="noopener noreferrer">
              <S.FaiLogoDesktop>
                <FaiLogo />
              </S.FaiLogoDesktop>
            </a>
          </S.FaiWrapper>

        </S.RightWrapper>
      </S.Header>
      <S.HeaderMobile>
        <S.LeftWrapper>
          <Link to="/" onClick={() => setMobileMenuOpen(false)}>
            <Icon type="logo" />
          </Link>
        </S.LeftWrapper>
        <S.RightWrapper
          className="mobile"
          onClick={() => {
            setMobileMenuOpen(val => !val)
          }}
        >
          <Icon type="hamburger-menu" width={40} />
        </S.RightWrapper>
        <S.RightSidebar $isOpen={mobileMenuOpen}>
          <S.CloseButton onClick={() => setMobileMenuOpen(false)}>
            <T.P1>X</T.P1>
          </S.CloseButton>
          <S.MobileNavBarList>
            {navItems.map(el => (
              <S.MobileNavBarItem
                key={el.label}
                $isActive={rootPath === el.url}
              >
                {el.subsections ? (
                  <S.LinkIcon $isActive={rootPath === el.url}>
                    <S.IconWrapper
                      $isActive={rootPath === el.url}
                      $isOpen={el.label === menuOpen}
                      onClick={() =>
                        setMenuOpen(old => (el.label === old ? "" : el.label))
                      }
                    >
                      <Icon type="chevron" height={15} />
                    </S.IconWrapper>
                    <Link
                      to={el.url}
                      onClick={() => {
                        setMobileMenuOpen(false)
                        setMenuOpen("")
                      }}
                    >
                      <T.H3>{el.label}</T.H3>
                    </Link>
                  </S.LinkIcon>
                ) : (
                  <Link
                    to={el.url}
                    onClick={() => {
                      setMobileMenuOpen(false)
                      setMenuOpen("")
                    }}
                  >
                    <T.H3>{el.label}</T.H3>
                  </Link>
                )}
                {el.subsections && (
                  <S.MobileSubsectionList $show={el.label === menuOpen}>
                    {el.subsections.map(subSection => (
                      <li key={subSection.label}>
                        <Link
                          to={subSection.url}
                          onClick={() => setMobileMenuOpen(false)}
                        >
                          <T.H4>{subSection.label}</T.H4>
                        </Link>
                      </li>
                    ))}
                  </S.MobileSubsectionList>
                )}
              </S.MobileNavBarItem>
            ))}
          </S.MobileNavBarList>

          <S.FaiLogoMobile>
            <a href="https://fondoambiente.it/" target="_blank" rel="noopener noreferrer" title="Con il patrocinio di FAI Veneto">
              <FaiLogo />
            </a>
          </S.FaiLogoMobile>

        </S.RightSidebar>
      </S.HeaderMobile>
    </>
  )
}

export default Header
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/header/styled.ts
========================================

import styled from "styled-components"
import {
  breakpoint,
  breakpointNum,
  colors,
  horizBreakpointsHeight,
} from "../../styles"

export const Header = styled.header`
  height: 80px;
  background-color: ${colors.green.green200};
  display: flex;
  flex-direction: row;
  gap: 16px;
  padding: 0 32px;
  align-items: center;
  justify-content: space-between;
  @media (max-width: ${breakpoint.tablet}) {
    display: none;
  }
  position: sticky;
  top: 0;
  left: 0;
  z-index: 9998;
  box-shadow: 0px 1px 6px ${colors.green.green700};
  @media (max-height: ${horizBreakpointsHeight.medium}px) {
    padding: 16px;
    height: 40px;
    gap: 8px;
    position: unset;
  }
`

export const LeftWrapper = styled.div`
  min-width: 120px;
  @media (max-height: ${horizBreakpointsHeight.medium}px) {
    min-width: 80px;
  }
  > a:hover > svg {
    scale: 1.02;
    transition: all 0.2s ease-in-out;
  }
`

export const RightWrapper = styled.nav`
  display: flex;
  flex-direction: row;
  gap: 32px;
  align-items: center;
  &.mobile {
    cursor: pointer;
  }

  @media (max-width: ${breakpointNum.medium}px) {
    gap: 16px;
  }
`

export const NavBarList = styled.ul`
  list-style: none;
  display: flex;
  margin: 0;
  padding: 0;
`

export const NavBarItem = styled.li<{ $isActive: boolean }>`
  position: relative;
  margin: 0 1rem;
  cursor: pointer;
  z-index: 10;
  text-align: center;
  align-items: center;
  align-self: center;
  
  @media (max-width: ${breakpointNum.medium}px) {
    margin: 0 0.4rem; 
    
    > a > * {
      font-size: 13px;
    }
  }

  > a {
    text-decoration: none;
    ${({ $isActive }) => $isActive && `color: ${colors.green.green550}`};
    font-weight: bold;
    &:hover {
      text-decoration: underline;
      text-decoration-color: ${({ $isActive }) =>
    $isActive ? `${colors.green.green550}` : `${colors.green.green900}`};
    }

    &:active {
      color: ${colors.green.green600};
    }

    > * {
      margin-top: 0;
      ${({ $isActive }) => $isActive && `color: ${colors.green.green550}`};
      &:active {
        color: ${colors.green.green600};
      }
      @media (max-height: ${horizBreakpointsHeight.medium}px) {
        margin-top: 0px;
      }
    }
  }

  &:last-child > a {
    background-color: ${colors.green.green700};
    padding: 8px 16px;
    border-radius: 20px;
    transition: all 0.3s;
    display: flex;
    align-items: center;

    > * {
      color: ${colors.green.green50} !important;
      margin: 0;
    }
    
    &:hover {
      background-color: ${colors.green.green800};
      text-decoration: none; 
      transform: scale(1.05);
    }
  }
`

export const SubsectionList = styled.ul<{ $isOpen: boolean }>`
  width: 100%;
  padding-inline-start: 0;
  list-style: none;
  min-width: 110px;
  margin: 0;
  position: absolute;
  top: calc(100% + 20px); 
  left: 0px;
  background-color: ${colors.green.green400};
  box-shadow: 0 4px 6px ${colors.green.green950}60;
  border-radius: 4px;
  opacity: 0;
  visibility: hidden;
  transform: translateY(-10px);
  transition: all 0.3s ease-in-out;

  &::before {
    content: '';
    position: absolute;
    top: -20px; 
    left: 0;
    width: 100%;
    height: 20px;
    background: transparent;
  }

  ${({ $isOpen }) =>
    $isOpen &&
    `
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
  `}
`

export const SubsectionItem = styled.div`
  > a {
    text-decoration: none;
    > * {
      margin: 1em;
      color: ${colors.green.green700};
      &:hover {
        color: ${colors.green.green100};
        transition: all 0.2s ease-in-out;
      }
      &:active {
        color: ${colors.green.green200};
      }
    }
  }
`

// MOBILE CODE
export const HeaderMobile = styled.div`
  height: 50px;
  background-color: ${colors.green.green200};
  display: flex;
  flex-direction: row;
  gap: 16px;
  padding: 32px 18px;
  justify-content: space-between;
  @media (min-width: ${breakpointNum.tablet + 1}px) {
    display: none;
  }
  position: sticky;
  top: 0;
  left: 0;
  z-index: 9998;
  box-shadow: 0px 1px 6px ${colors.green.green700};
  @media (max-height: ${horizBreakpointsHeight.thin}px) {
    padding: 12px 8px;
    height: 40px;
    gap: 8px;
    position: unset;
  }
`

export const RightSidebar = styled.div<{ $isOpen: boolean }>`
  position: fixed;
  top: 0;
  right: 0;
  width: 85%;
  max-width: 300px;
  height: 100%;
  background-color: ${colors.green.green900};
  box-shadow: -2px 0 5px ${colors.green.green950}03;
  transform: ${({ $isOpen }) =>
    $isOpen ? "translateX(0)" : "translateX(100%)"};
  transition: transform 0.3s ease-in-out;
  z-index: 1000;
  display: flex;
  flex-direction: column;
  padding: 2rem;

  @media (min-width: 768px) {
    display: none;
  }
`

export const CloseButton = styled.button`
  background: none;
  border: none;
  font-size: 2rem;
  align-self: flex-end;
  cursor: pointer;
  &:hover {
    transition: all 0.5s;
    color: ${colors.green.green200};
  }
  &:active {
    transition: all 0.5s;
    color: ${colors.green.green400};
  }
  > * {
    color: ${colors.green.green50};
  }
`

export const MobileNavBarList = styled.ul`
  list-style: none;
  margin: 2rem 0;
  padding: 0;
`

export const MobileNavBarItem = styled.li<{ $isActive: boolean }>`
  margin: 1rem 0;
  > a {
    text-decoration: none;
    > * {
      margin-top: 0;
      color: ${({ $isActive }) =>
    $isActive ? colors.green.green500 : colors.green.green300};
      &:active {
        transition: all 0.5s;
        color: ${({ $isActive }) =>
    $isActive ? colors.green.green600 : colors.green.green500};
      }
      font-weight: bold;
    }
  }
`

export const LinkIcon = styled.div<{ $isActive: boolean }>`
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 15px;
  > a {
    text-decoration: none;
    > * {
      margin-top: 0px;
      color: ${({ $isActive }) =>
    $isActive ? colors.green.green500 : colors.green.green300};
      &:active {
        transition: all 0.5s;
        color: ${({ $isActive }) =>
    $isActive ? colors.green.green600 : colors.green.green500};
      }
      font-weight: bold;
    }
  }
`

export const IconWrapper = styled.div<{ $isActive: boolean; $isOpen: boolean }>`
  margin-top: 5px;
  cursor: pointer;
  > svg {
    fill: ${({ $isActive }) =>
    $isActive ? colors.green.green500 : colors.green.green300};

    &:active {
      transition: all 0.5s;
      fill: ${({ $isActive }) =>
    $isActive ? colors.green.green600 : colors.green.green500};
    }
    transform: ${({ $isOpen }) =>
    $isOpen ? "rotate(0deg)" : "rotate(-90deg)"};
    transition: all 0.7s;
  }
`

export const MobileSubsectionList = styled.ul<{ $show: boolean }>`
  ${({ $show }) => !$show && "display: none;"}
  list-style: none;
  margin-top: 0.5rem;
  padding: 0;
  padding-left: 36px;

  > li {
    margin: 0.5rem 0;

    > a {
      text-decoration: none;
      > * {
        color: ${colors.green.green200};
        &:hover {
          color: ${colors.green.green300};
          transition: all 0.5s;
        }
        &:active {
          transition: all 0.5s;
          color: ${colors.green.green500};
        }
      }
    }
  }
`

export const FaiWrapper = styled.div`
  display: flex;
  align-items: center;
  margin-left: 10px;
  padding-left: 20px;
  border-left: 1px solid ${colors.green.green400};

  @media (max-width: ${breakpointNum.medium}px) {
    margin-left: 0;
    padding-left: 0;
  }
  
  a {
    display: flex;
    align-items: center;
  }

  svg {
    height: 55px; 
    width: auto;  
    display: block;
  }

  @media (max-width: ${breakpointNum.tablet}) {
    display: none; 
  }
`

export const FaiLogoDesktop = styled.div`
  height: 55px;
  width: auto;
  object-fit: contain;
  align-self: center;
  margin-left: 20px;
  cursor: pointer;
  transition: transform 0.3s ease;

  &:hover {
    transform: scale(1.05);
  }

  @media (max-width: ${breakpointNum.medium}px) {
    height: 30px;
  }
`

export const FaiLogoMobile = styled.div`
  margin-top: auto;
  display: flex;
  justify-content: center;
  padding-top: 2rem;
  padding-bottom: 1rem;
  margin-bottom: 30px;

  a {
    display: flex;
    justify-content: center;
  }

  svg {
    height: 50px;
    width: auto;
  }
`Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/custom-polyline/index.tsx
========================================

import { Polyline, PolylineProps } from "react-leaflet"
import L from "leaflet"
import React, { useEffect, useRef } from "react"

// Extend PolylineProps to include hitTolerance
interface ExtendedPolylineProps extends PolylineProps {
  hitTolerance?: number
}

const ExtendedPolyline: React.FC<ExtendedPolylineProps> = ({
  hitTolerance,
  ...props
}) => {
  const polylineRef = useRef<L.Polyline | null>(null)

  useEffect(() => {
    if (polylineRef.current && hitTolerance !== undefined) {
      ;(polylineRef.current.options as any).hitTolerance = hitTolerance
    }
  }, [hitTolerance])

  return <Polyline ref={polylineRef} {...props} />
}

export default ExtendedPolyline
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/default-layout/index.tsx
========================================

import React from "react"
import Footer from "../footer"
import Header from "../header"
import CookieBanner from "../cookie-banner"
import * as S from "./styled"


const DefaultLayout: React.FC<{ children: any }> = ({ children }) => {
  return (
    <>

      <Header />
      <S.Wrapper>{children}</S.Wrapper>
      <CookieBanner />
      <Footer />
    </>
  )
}

export default DefaultLayout
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/default-layout/styled.ts
========================================

import styled from "styled-components"
import { breakpointNum, colors, horizBreakpointsHeight } from "../../styles"

export const Wrapper = styled.main`
  border-radius: 8px;
  min-height: 500px;
  background-color: ${colors.green.green50};
  justify-self: center;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-shrink: 0;
  flex-direction: column;
  @media (max-width: ${breakpointNum.bigtablet}px) {
    min-width: 480px;
  }
  @media (max-width: ${breakpointNum.mobile}px) {
    min-width: 280px;
    min-height: 380px;
  }
  @media (max-height: ${horizBreakpointsHeight.medium}px) {
    min-height: 300px;
  }
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/mobile-pagedata-text-components/index.tsx
========================================

import React, { useState } from "react"
import {
  DataJSONType,
  ImageContentData,
  ImageData,
  TemplateTwoColumnsData,
  TextContentData,
} from "../../types"
import * as T from "./../typography"
import { renderImage, ExpandableText } from "./helpers"
import * as S from "./styled"

const renderComponents =
  (images: ImageData[]) =>
  (content: DataJSONType[number], key: Number | string): any => {
    const keyString = key.toString()
    switch (content.type) {
      case "image":
        const castedImgContent = content as ImageContentData
        return renderImage(castedImgContent, images, keyString)

      case "text":
        const castedTextContent = content as TextContentData
        return (
          <ExpandableText
            key={`expandable-${keyString}`}
            content={castedTextContent}
            innerKey={keyString}
          />
        )

      case "two-columns": {
        const castedTwoColsComponent = content as TemplateTwoColumnsData
        const [leftComponents, rightComponents] = castedTwoColsComponent.content
        return (
          <S.TwoWrapperMobile key={keyString}>
            {[...leftComponents, ...rightComponents].map((lc, idx) =>
              renderComponents(images)(lc, `two-cols-seq-${keyString}-${idx}`),
            )}
          </S.TwoWrapperMobile>
        )
      }
      default:
        return <T.H1 key={keyString}>Content type Not Found</T.H1>
    }
  }

const MobileContentToComponent: React.FC<{
  pageData: DataJSONType
  images: ImageData[]
}> = ({ pageData, images }) => {
  return <S.MainWrapper>{pageData.map(renderComponents(images))}</S.MainWrapper>
}
export default MobileContentToComponent
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/mobile-pagedata-text-components/styled.ts
========================================

import styled, { keyframes } from "styled-components"
import { breakpoint, breakpointNum, colors } from "../../styles"
import * as T from "./../typography"
import { color } from "framer-motion"

export const MainWrapper = styled.div`
  display: flex;
  flex-direction: column;
  gap: 20px;
  padding: 32px;
  justify-content: center;
  @media (min-width: ${breakpointNum.bigtablet + 1}px) {
    display: none;
  }
  @media (max-width: ${breakpointNum.tablet}px) {
    padding: 24px;
  }
  @media (max-width: ${breakpointNum.mobile}px) {
    padding: 16px;
  }
`

export const ImageWrapper = styled.div`
  display: flex;
  gap: 40px;
  flex-wrap: wrap;
  justify-content: center;
`

export const TwoWrapperMobile = styled.div`
  @media (min-width: ${breakpointNum.bigtablet + 1}px) {
    display: none;
  }
  min-height: 100px;
`

export const ContinueReading = styled(T.P2)`
  color: ${colors.green.green700};
`

export const TextWrapper = styled.div<{ $isExpanded: boolean }>`
  position: relative;
  overflow: hidden;
  max-height: ${({ $isExpanded }) => ($isExpanded ? "2000px" : "4.5em")};
  @media (max-width: ${breakpointNum.mobile}px) {
    max-height: ${({ $isExpanded }) => ($isExpanded ? "2000px" : "6em")};
  }
  transition: max-height 0.8s ease-in-out;
`

export const TextContainer = styled.div`
  position: relative;
`

export const FadeOut = styled.div<{ $isExpanded: boolean; $isShort: boolean }>`
  ${({ $isShort }) => $isShort && "display:none;"}
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 2em;
  background: linear-gradient(to bottom, transparent, ${colors.green.green500});
  pointer-events: none;

  opacity: ${({ $isExpanded }) => ($isExpanded ? 0 : 1)};
  transition: opacity 0.8s ease-in-out;
`

export const ReadMoreWrapper = styled.div<{
  $isExpanded: boolean
  $isShort: boolean
}>`
  ${({ $isShort }) => $isShort && "display:none;"}
  cursor: pointer;
  position: absolute;
  top: 1.3em;
  z-index: 10;
  justify-self: anchor-center;
  ${({ $isExpanded }) => $isExpanded && "position: unset;"}

  h3 {
    color: ${colors.green.green950};
    opacity: 0;
    animation: fadeIn 1s ease-in-out forwards;
    animation-delay: 0.5s;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  @media (min-width: ${breakpointNum.tablet + 1}px) {
    top: 2em;
  }
  @media (max-width: ${breakpointNum.mobile}px) {
    top: 3.2em;
  }
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/mobile-pagedata-text-components/helpers.tsx
========================================

import React, { useRef, useState } from "react"
import { ImageContentData, ImageData, TextContentData } from "../../types"
import ImageWithCredits from "../image-with-credits"
import * as T from "../typography"
import * as S from "./styled"

export const renderImage = (
  content: ImageContentData,
  images: ImageData[],
  key: string,
) => {
  const filteredImages = content.content.map(imgFilename =>
    images.find(img => img.fileName === imgFilename),
  )
  return (
    <S.ImageWrapper key={key}>
      {filteredImages.map((img, index) =>
        img ? (
          img.image && (
            <ImageWithCredits
              key={index}
              title={img.title}
              description={img.description}
              alt={img.alt || img.description}
              image={img.image}
              copyright={img.copyright}
              minHeight={content.minHeight}
              minWidth={content.minWidth}
              maxHeight={content.maxHeight}
              maxWidth={content.maxWidth}
              noDescription={content.noDescription}
              noCopyright={content.noCopyright}
            />
          )
        ) : (
          <T.H2 key={`img-${index}`}>Image not found</T.H2>
        ),
      )}
    </S.ImageWrapper>
  )
}

const renderTextInner =
  (
    size: string,
    font: T.FontFamilies | undefined,
    position: "center" | "left" | "right" | undefined,
  ) =>
  (text: string) => {
    const addProps = {
      $textAlign: position,
      $font: font,
      dangerouslySetInnerHTML: { __html: text },
    }
    switch (size) {
      case "h1":
        return <T.H1 {...addProps} />
      case "h2":
        return <T.H2 {...addProps} />
      case "h3":
        return <T.H3 {...addProps} />
      case "h4":
        return <T.H4 {...addProps} />
      case "h5":
        return <T.H5 {...addProps} />
      case "h6":
        return <T.H6 {...addProps} />
      case "h7":
        return <T.H7 {...addProps} />
      case "p1":
        return <T.P1 {...addProps} />
      case "p2":
        return <T.P2 {...addProps} />
      case "p3":
        return <T.P3 {...addProps} />
      case "p4":
        return <T.P1 {...addProps} />
      case "p5":
        return <T.P1 {...addProps} />
      case "note":
        return <T.Notes {...addProps} />
      default:
        return <T.H2>Text size not found</T.H2>
    }
  }

export const ExpandableText: React.FC<{
  content: TextContentData
  innerKey: string
}> = ({ content, innerKey }) => {
  const [isExpanded, setIsExpanded] = useState(false)

  const theText = content.content.join(" <br /> ")
  if (!theText) return <T.H2 key={innerKey}>Text not found</T.H2>

  const textRef = useRef<HTMLDivElement | null>(null)

  const isShortText = theText.length <= 135

  const { font, position, collapsible } = content
  const textRenderer = renderTextInner(content.size, font, position)

  if (collapsible === false)
    return (
      <React.Fragment key={innerKey}>{textRenderer(theText)}</React.Fragment>
    )

  return (
    <S.TextWrapper $isExpanded={isExpanded} key={innerKey} ref={textRef}>
      <S.TextContainer
        onClick={() => {
          setIsExpanded(true)
        }}
      >
        {textRenderer(theText)}
      </S.TextContainer>
      <S.FadeOut $isExpanded={isExpanded} $isShort={isShortText} />
      <S.ReadMoreWrapper
        $isExpanded={isExpanded}
        $isShort={isShortText}
        onClick={() => {
          setIsExpanded(!isExpanded)
        }}
      >
        <T.H3 key={isExpanded ? "chiudi" : "leggi-di-piu"}>
          {isExpanded ? "Chiudi" : "Leggi di pi√π"}
        </T.H3>
      </S.ReadMoreWrapper>
    </S.TextWrapper>
  )
}
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/post/index.tsx
========================================

import { GatsbyImage, IGatsbyImageData } from "gatsby-plugin-image"
import React from "react"
import * as T from "../typography"
import { PortableText } from "@portabletext/react"
import Components from "../portable-text-components"
import * as S from "./styled"
import { Link } from "gatsby"

interface PostProps {
  renderTitle: string
  renderPublishedAt: string
  gatsbyImage?: IGatsbyImageData
  renderImageUrl?: string
  renderBody: any
  author: string
  coverImageAlt: string
  prevPost?: { slug: string, title: string | null } | null
  nextPost?: { slug: string, title: string | null } | null
}

const Post: React.FC<PostProps> = ({
  renderTitle,
  renderPublishedAt,
  gatsbyImage,
  renderImageUrl,
  renderBody,
  author,
  coverImageAlt,
  prevPost,
  nextPost,
}) => {
  return (
    <S.Article>
      <S.BackLink to="/blog" state={{ fromPost: true }}>
        ‚Üê Torna al blog
      </S.BackLink>
      <T.H1>{renderTitle}</T.H1>
      <S.AuthorDateWrapper>
        {author && (
          <T.P3>
            Di <span style={{ fontWeight: "bold" }}>{author}</span>
          </T.P3>
        )}
        <T.P3>{" | "}</T.P3>
        {renderPublishedAt && (
          <T.P3>
            {new Date(renderPublishedAt).toLocaleDateString("it-IT", {
              weekday: "long",
              year: "numeric",
              month: "long",
              day: "numeric",
            })}
          </T.P3>
        )}
      </S.AuthorDateWrapper>
      <S.CoverImageWrp>
        {gatsbyImage && <GatsbyImage image={gatsbyImage} alt={coverImageAlt} />}
        {!gatsbyImage && renderImageUrl && (
          <img
            src={renderImageUrl}
            alt={coverImageAlt}
            style={{ maxWidth: "100%", height: "auto", objectFit: "cover" }}
          />
        )}
      </S.CoverImageWrp>
      <PortableText value={renderBody} components={Components} />

      <S.PostNavigation>
        <S.NavSide className="left">
          {prevPost && (
            <S.NavButton $align="left">
              <Link to={prevPost.slug.startsWith('/') ? prevPost.slug : `/${prevPost.slug}`}>
                <T.P4 className="nav-label">Articolo precedente</T.P4>
                <T.H4 className="nav-title">‚Üê {prevPost.title}</T.H4>
              </Link>
            </S.NavButton>
          )}
        </S.NavSide>

        <S.BackToBlogButton to="/blog" state={{ fromPost: true }}>
          <T.H5>Torna all'elenco</T.H5>
        </S.BackToBlogButton>

        <S.NavSide className="right">
          {nextPost && (
            <S.NavButton $align="right">
              <Link to={nextPost.slug.startsWith('/') ? nextPost.slug : `/${nextPost.slug}`}>
                <T.P4 className="nav-label">Articolo successivo</T.P4>
                <T.H4 className="nav-title">{nextPost.title} ‚Üí</T.H4>
              </Link>
            </S.NavButton>
          )}
        </S.NavSide>
      </S.PostNavigation>

    </S.Article>
  )
}

export default Post
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/post/styled.ts
========================================

import styled from "styled-components"
import { breakpoint, colors } from "../../styles"
import { Link } from "gatsby"

export const Article = styled.article`
  padding: 64px;
  
  width: 100%;
  max-width: 1400px; 
  box-sizing: border-box; 
  overflow-wrap: break-word; 

  @media (max-width: ${breakpoint.tablet}) {
    padding: 32px;
  }
  @media (max-width: ${breakpoint.mobile}) {
    padding: 16px;
  }
`

export const AuthorDateWrapper = styled.div`
  display: flex;
  flex-direction: row;
  gap: 1em;
  align-items: center;
  flex-wrap: wrap; 
`

export const CoverImageWrp = styled.div`
  padding: 2em 0;
  width: 100%;
  max-width: 1000px; 
  margin: 0 auto; 
  
  .gatsby-image-wrapper, img {
    border-radius: 12px;
    max-height: 550px; 
    width: 100%;
    object-fit: cover;
  }

  @media (max-width: ${breakpoint.tablet}) {
    max-width: 100%;
    padding: 1.5em 0;
  }
`

export const BackLink = styled(Link)`
  display: inline-flex;
  align-items: center;
  margin-bottom: 0.5rem; 
  color: ${colors.green.green600}; 
  text-decoration: none;
  font-weight: bold;
  font-size: 0.85rem; 
  text-transform: uppercase; 
  letter-spacing: 1px;
  font-family: 'Funnel Sans', sans-serif;
  transition: all 0.3s ease;

  &:hover {
    color: ${colors.green.green900};
    transform: translateX(-5px);
  }
`

export const PostNavigation = styled.div`
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  margin-top: 5rem;
  padding-top: 3rem;
  border-top: 2px solid ${colors.green.green200};
  width: 100%; /* Assicura che il contenitore non sbordi */
  box-sizing: border-box;

  @media (max-width: ${breakpoint.bigtablet}) {
    flex-direction: column;
    gap: 2rem;
  }
`

export const NavSide = styled.div`
  /* LA CHIAVE DEL SUCCESSO: Max-width rigido su desktop */
  flex: 1;
  max-width: 40%; /* Impedisce ai lati di occupare troppo spazio, lasciando respiro al bottone centrale */
  display: flex;
  min-width: 0; 
  
  &.left {
    justify-content: flex-start;
  }
  
  &.right {
    justify-content: flex-end;
  }

  @media (max-width: ${breakpoint.bigtablet}) {
    width: 100%;
    max-width: 100%; /* Su mobile togliamo il limite */
    &.left, &.right {
      justify-content: center;
    }
  }
`

export const NavButton = styled.div<{ $align: "left" | "right" }>`
  max-width: 100%;
  
  a {
    text-decoration: none;
    transition: transform 0.3s ease;
    display: flex;
    flex-direction: column;
    align-items: ${({ $align }) => ($align === "left" ? "flex-start" : "flex-end")};
    text-align: ${({ $align }) => $align};
    max-width: 100%;

    &:hover {
      transform: ${({ $align }) => ($align === "left" ? "translateX(-5px)" : "translateX(5px)")};
      .nav-title {
        color: ${colors.green.green500};
      }
    }

    @media (max-width: ${breakpoint.bigtablet}) {
      align-items: center;
      text-align: center;
    }
  }

  .nav-label {
    color: ${colors.green.green600};
    margin: 0 0 0.5rem 0;
    text-transform: uppercase;
    font-size: 0.8rem;
    letter-spacing: 1px;
    white-space: nowrap;
  }

  .nav-title {
    color: ${colors.green.green900};
    margin: 0;
    transition: color 0.3s ease;
    
    /* TRONCAMENTO AGGRESSIVO */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
  }
`

export const BackToBlogButton = styled(Link)`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background-color: ${colors.green.green100};
  color: ${colors.green.green900};
  padding: 12px 24px;
  border-radius: 30px;
  text-decoration: none;
  transition: all 0.3s ease;
  white-space: nowrap;
  font-family: 'Funnel Sans', sans-serif;

  > * {
    margin: 0;
    color: inherit;
  }

  &:hover {
    background-color: ${colors.green.green200};
    transform: translateY(-2px);
    box-shadow: 0 4px 12px ${colors.green.green900}20;
  }

  &:active {
    transform: translateY(0);
  }
`Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/typography/index.tsx
========================================

import styled from "styled-components"
import { breakpoint, colors, horizBreakpointsHeight } from "../../styles"

export const fontSizes = {
  h1: 42,
  h2: 28,
  h3: 22,
  h4: 18,
  h5: 15,
  h6: 13,
  h7: 11,
  h8: 10,
  p1: 22,
  p2: 18,
  p3: 16,
  p4: 14,
  p5: 12,
  notes: 10,
}

export const globalStylesTypography = `
  margin-bottom: 0;
  color: ${colors.green.green900};
`
export const globalHeaderStylesTypography = `
  ${globalStylesTypography}
  font-family: 'Funnel Sans';
  font-weight: bold;
`

export const globalParagraphStylesTypography = `
  ${globalStylesTypography}
  font-family: 'Funnel Sans';
`

export type FontFamilies =
  | "Condiment"
  | "Funnel-Sans"
  | "Caveat"
  | "Cedarville Cursive"

export const H1 = styled.h1<{
  $font?: FontFamilies
  $textAlign?: "left" | "right" | "center"
}>`
  ${globalHeaderStylesTypography}
  font-size: ${fontSizes.h1}px;
  ${({ $font }) => $font && `font-family: ${$font};`}
  ${({ $textAlign }) => $textAlign && `text-align: ${$textAlign};`}
  @media (max-width: ${breakpoint.tablet}) {
    font-size: ${fontSizes.h2}px;
  }
  @media (max-width: ${breakpoint.mobile}),
    (max-height: ${horizBreakpointsHeight.medium}px) {
    font-size: ${fontSizes.h3}px;
  }
`

export const H2 = styled.h2<{
  $font?: FontFamilies
  $textAlign?: "left" | "right" | "center"
}>`
  ${globalHeaderStylesTypography}
  font-size: ${fontSizes.h2}px;
  ${({ $font }) => $font && `font-family: ${$font};`}
  ${({ $textAlign }) => $textAlign && `text-align: ${$textAlign};`}
  @media (max-width: ${breakpoint.tablet}) {
    font-size: ${fontSizes.h3}px;
  }
  @media (max-width: ${breakpoint.mobile}),
    (max-height: ${horizBreakpointsHeight.medium}px) {
    font-size: ${fontSizes.h4}px;
  }
`

export const H3 = styled.h3<{
  $font?: FontFamilies
  $textAlign?: "left" | "right" | "center"
}>`
  ${globalHeaderStylesTypography}
  font-size: ${fontSizes.h3}px;
  ${({ $font }) => $font && `font-family: ${$font};`}
  ${({ $textAlign }) => $textAlign && `text-align: ${$textAlign};`}
  @media (max-width: ${breakpoint.tablet}) {
    font-size: ${fontSizes.h3}px;
  }
  @media (max-width: ${breakpoint.mobile}),
    (max-height: ${horizBreakpointsHeight.medium}px) {
    font-size: ${fontSizes.h4}px;
  }
`

export const H4 = styled.h4<{
  $font?: FontFamilies
  $textAlign?: "left" | "right" | "center"
}>`
  ${globalHeaderStylesTypography}
  font-size: ${fontSizes.h4}px;
  ${({ $font }) => $font && `font-family: ${$font};`}
  ${({ $textAlign }) => $textAlign && `text-align: ${$textAlign};`}
  @media (max-width: ${breakpoint.tablet}) {
    font-size: ${fontSizes.h5}px;
  }
  @media (max-width: ${breakpoint.mobile}),
    (max-height: ${horizBreakpointsHeight.medium}px) {
    font-size: ${fontSizes.h6}px;
  }
`
export const H5 = styled.h5<{
  $font?: FontFamilies
  $textAlign?: "left" | "right" | "center"
}>`
  ${globalHeaderStylesTypography}
  font-size: ${fontSizes.h5}px;
  ${({ $font }) => $font && `font-family: ${$font};`}
  ${({ $textAlign }) => $textAlign && `text-align: ${$textAlign};`}
  @media (max-width: ${breakpoint.tablet}) {
    font-size: ${fontSizes.h6}px;
  }
  @media (max-width: ${breakpoint.mobile}),
    (max-height: ${horizBreakpointsHeight.medium}px) {
    font-size: ${fontSizes.h7}px;
  }
`

export const H6 = styled.h6<{
  $font?: FontFamilies
  $textAlign?: "left" | "right" | "center"
}>`
  ${globalHeaderStylesTypography}
  font-size: ${fontSizes.h6}px;
  ${({ $font }) => $font && `font-family: ${$font};`}
  ${({ $textAlign }) => $textAlign && `text-align: ${$textAlign};`}
  @media (max-width: ${breakpoint.tablet}) {
    font-size: ${fontSizes.h7}px;
  }
`

export const H7 = styled.h6<{
  $font?: FontFamilies
  $textAlign?: "left" | "right" | "center"
}>`
  ${globalHeaderStylesTypography}
  font-size: ${fontSizes.h7}px;
  ${({ $font }) => $font && `font-family: ${$font};`}
  ${({ $textAlign }) => $textAlign && `text-align: ${$textAlign};`}
  @media (max-width: ${breakpoint.tablet}) {
    font-size: ${fontSizes.h8}px;
  }
`

export const P1 = styled.p<{
  $font?: FontFamilies
  $textAlign?: "left" | "right" | "center"
}>`
  ${globalParagraphStylesTypography}
  font-size: ${fontSizes.p1}px;
  ${({ $font }) => $font && `font-family: ${$font};`}
  ${({ $textAlign }) => $textAlign && `text-align: ${$textAlign};`}
  @media (max-width: ${breakpoint.tablet}) {
    font-size: ${fontSizes.p2}px;
  }
  @media (max-width: ${breakpoint.mobile}),
    (max-height: ${horizBreakpointsHeight.medium}px) {
    font-size: ${fontSizes.p3}px;
  }
`

export const P2 = styled.p<{
  $font?: FontFamilies
  $textAlign?: "left" | "right" | "center"
}>`
  ${globalParagraphStylesTypography}
  font-size: ${fontSizes.p2}px;
  ${({ $font }) => $font && `font-family: ${$font};`}
  ${({ $textAlign }) => $textAlign && `text-align: ${$textAlign};`}
  @media (max-width: ${breakpoint.tablet}) {
    font-size: ${fontSizes.p3}px;
  }
  @media (max-width: ${breakpoint.mobile}),
    (max-height: ${horizBreakpointsHeight.medium}px) {
    font-size: ${fontSizes.p4}px;
  }
`
export const P3 = styled.p<{
  $font?: FontFamilies
  $textAlign?: "left" | "right" | "center"
}>`
  ${globalParagraphStylesTypography}
  font-size: ${fontSizes.p3}px;
  ${({ $font }) => $font && `font-family: ${$font};`}
  ${({ $textAlign }) => $textAlign && `text-align: ${$textAlign};`}
  @media (max-width: ${breakpoint.tablet}) {
    font-size: ${fontSizes.p4}px;
  }
  @media (max-width: ${breakpoint.mobile}),
    (max-height: ${horizBreakpointsHeight.medium}px) {
    font-size: ${fontSizes.p5}px;
  }
`

export const P4 = styled.p<{
  $font?: FontFamilies
  $textAlign?: "left" | "right" | "center"
}>`
  ${globalParagraphStylesTypography}
  font-size: ${fontSizes.p4}px;
  ${({ $font }) => $font && `font-family: ${$font};`}
  ${({ $textAlign }) => $textAlign && `text-align: ${$textAlign};`}
  @media (max-width: ${breakpoint.tablet}) {
    font-size: ${fontSizes.p5}px;
  }
`

export const P5 = styled.p<{
  $font?: FontFamilies
  $textAlign?: "left" | "right" | "center"
}>`
  ${globalParagraphStylesTypography}
  font-size: ${fontSizes.p5}px;
  ${({ $font }) => $font && `font-family: ${$font};`}
  ${({ $textAlign }) => $textAlign && `text-align: ${$textAlign};`}
  @media (max-width: ${breakpoint.tablet}) {
    font-size: 12px;
  }
`

export const Notes = styled.p<{
  $font?: FontFamilies
  $textAlign?: "left" | "right" | "center"
}>`
  ${globalParagraphStylesTypography}
  font-size: ${fontSizes.notes}px;
  ${({ $font }) => $font && `font-family: ${$font};`}
  ${({ $textAlign }) => $textAlign && `text-align: ${$textAlign};`}
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/404/index.tsx
========================================

import React from "react"
import Icon from "../icons"
import * as S from "./styled"
import * as T from "./../typography"

const Component404 = () => (
  <S.Wrapper>
    <Icon type="sad-face" width={300} />
    <T.H1 style={{ marginTop: 0 }} $font="Caveat">
      Questa pagina non esiste!
    </T.H1>
  </S.Wrapper>
)

export default Component404
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/404/styled.ts
========================================

import styled from "styled-components"
import { breakpointNum } from "../../styles"

export const Wrapper = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  padding: 32px;
  gap: 20px;
  @media (max-width: ${breakpointNum.mobile}px) {
    > svg {
      max-width: 200px;
    }
  }
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/button-link/index.tsx
========================================

import { Link } from "gatsby"
import React from "react"
import * as T from "./../typography"
import * as S from "./styled"

interface ButtonLinkProps {
  to: string
  label: string
}

const ButtonLink = ({ to, label }: ButtonLinkProps) => (
  <S.Wrapper>
    <Link style={{ textDecoration: "none" }} to={to}>
      <S.ButtonWrapper>
        <T.P2>{label}</T.P2>
      </S.ButtonWrapper>
    </Link>
  </S.Wrapper>
)

export default ButtonLink
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/button-link/styled.ts
========================================

import styled from "styled-components"
import { colors } from "../../styles"

export const Wrapper = styled.div`
  width: 100%;
  display: flex;
  flex-direction: row;
  justify-content: center;
  margin: 2em 0 2em 0;
`

export const ButtonWrapper = styled.div`
  text-align: center;
  background-color: ${colors.green.green400};
  padding: 0.8em;
  max-width: 125px;
  border-radius: 8px;
  transition: all 0.5s;
  &:hover {
    background-color: ${colors.green.green500};
  }
  &:active {
    background-color: ${colors.green.green600};
  }
  > p {
    margin-top: 0;
  }
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/hero-main/index.tsx
========================================

import React from "react"
import { ImageData } from "../../types"
import * as S from "./styled"
import * as T from "./../typography"

interface HeroMainProps {
  img: ImageData
  content: {
    quote: string
    signature: string
  }
}

const HeroMain: React.FC<HeroMainProps> = ({ img, content }: HeroMainProps) => {
  const { quote, signature } = content

  return (
    <S.Wrapper>
      <S.TextWrapper>
        <T.P1 $font="Caveat">{quote}</T.P1>
        <T.H3
          className="signature"
          $font={"Cedarville Cursive"}
          $textAlign={"right"}
          dangerouslySetInnerHTML={{ __html: signature }}
        />
      </S.TextWrapper>
      {img.image && (
        <S.StyledImg
          image={img.image}
          alt={img.alt ?? ""}
          style={{ borderRadius: "8px", marginTop: 4 }}
        />
      )}
    </S.Wrapper>
  )
}

export default HeroMain
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/hero-main/styled.ts
========================================

import styled from "styled-components"
import { breakpointNum, colors } from "../../styles"
import { GatsbyImage } from "gatsby-plugin-image"

export const Wrapper = styled.div`
  padding: 32px;
  @media (max-width: ${breakpointNum.smalltablet}px) {
    padding: 0 24px;
  }
  @media (max-width: ${breakpointNum.mobile}px) {
    padding: 16px;
  }
  animation: fadeIn 1s ease-in-out forwards;
  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
`

export const TextWrapper = styled.div`
  margin-top: 10px;
  position: absolute;
  z-index: 4;
  max-width: calc(100% - 75px);
  text-align: center;
  user-select: none;

  animation: fadeIn 3s ease-in-out forwards;
  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  > p {
    margin-top: 0;
  }
  > * {
    color: ${colors.green.green100};
    position: relative;
    max-width: 1025px;
    padding-left: 5px;
  }

  @media (max-width: ${breakpointNum.medium}px) {
    .signature {
      margin-top: 4px;
    }
  }

  @media (max-width: ${breakpointNum.bigtablet + 10}px) {
    .signature {
      margin-top: 1em;
    }
    margin-top: none;
    position: unset;
    max-width: none;
    > * {
      color: ${colors.green.green950};
      padding-left: none;
    }
  }

  @media (max-width: ${breakpointNum.mobile}px) {
    padding: 8px;
  }
`

export const StyledImg = styled(GatsbyImage)``
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/footer/index.tsx
========================================

import React from "react"
import * as S from "./styled"
import * as T from "../typography"
import { footerSections } from "./../../data/sections"
import contacts from "./../../data/contacts.json"

import Icon from "../icons"
import { Link } from "gatsby"
import Sponsors from "../sponsors"

const contactData = [
  {
    icon: <Icon type="facebook" width={25} />,
    text: "FB - Laghetti della Rimonta",
    linkURL: contacts["facebook-laghetti"],
  },
  {
    icon: <Icon type="facebook" width={25} />,
    text: "FB - Progetto Narcisi",
    linkURL: contacts["facebook-narcisi"],
  },
  {
    icon: <Icon type="youtube" width={25} />,
    text: "Youtube - Gruppo Natura Lentiai",
    linkURL: contacts["youtube"],
  },
  {
    icon: <Icon type="whatsapp" width={25} />,
    text: "Whatsapp",
    onClick: () => {
      const whatsappUrl = `https://wa.me/${contacts["phone"].join("").replace(/\D/g, "")}`
      window.open(whatsappUrl, "_blank")
    },
  },
]

const Footer: React.FC = () => {
  return (
    <>
      <S.Footer>
        <S.UpperContent>
          <S.LogoWrapper>
            <Link to="/" aria-label="Vai alla home">
              <Icon type="logo" width={200} />
            </Link>
            <S.ContactsIcons>
              {contactData.map((contact, idx) => (
                <S.IconWrapper
                  title={contact.text}
                  onClick={contact.onClick}
                  key={`contact-${idx}`}
                >
                  {contact.linkURL ? (
                    <a
                      href={contact.linkURL}
                      target="_blank"
                      rel="noopener noreferrer"
                      aria-label={contact.text}
                    >
                      {contact.icon}
                    </a>
                  ) : (
                    <>{contact.icon}</>
                  )}
                </S.IconWrapper>
              ))}
            </S.ContactsIcons>
            <S.ContactsLong>
              <S.ContactsLongText>
                <T.H3>Email: </T.H3>
                <T.H4
                  onClick={() => {
                    window.location.href = `mailto:${contacts["email"].join("")}`
                  }}
                >
                  {contacts["email"]}
                </T.H4>
              </S.ContactsLongText>
              <S.ContactsLongText>
                <T.H3>Telefono: </T.H3>
                <T.H4
                  onClick={() => {
                    window.location.href = `tel:${contacts["phone"].join("")}`
                  }}
                >
                  {contacts["phone"].join(" ")}
                </T.H4>
              </S.ContactsLongText>
            </S.ContactsLong>
          </S.LogoWrapper>
          <S.SitemapWrapper>
            {footerSections.map((main, idx) => (
              <S.LinksColumn key={`footer-sec-${idx}`}>
                {main.url ? (
                  <Link to={main.url}>
                    <T.H3 $font="Caveat">{main.label}</T.H3>
                  </Link>
                ) : (
                  <T.H3 $font="Caveat" key={`footer-sec-${idx}`}>
                    {main.label}
                  </T.H3>
                )}
                {main.subsections.map((subsec, idx) => (
                  <Link to={subsec.url} key={`footer-subsec-${idx}`}>
                    <T.H4>{subsec.label}</T.H4>
                  </Link>
                ))}
              </S.LinksColumn>
            ))}
          </S.SitemapWrapper>
          <S.SponsorsWrapper>
            <T.H2 $font="Caveat">I nostri sponsor</T.H2>
            <Sponsors />
          </S.SponsorsWrapper>
        </S.UpperContent>
        <S.HorizontalSeparator />
        <S.LowerContent>
          <S.TextLink to="/cookies-policy">
            <T.P2 className="text-link">Politica dei Cookies</T.P2>
          </S.TextLink>
          <T.P2>
            ¬© Copyright Andrea Nicolai - GNL Lentiai 2025 - Tutti i diritti
            riservati.
          </T.P2>
        </S.LowerContent>
      </S.Footer>
      <S.MobileFooter>
        <S.UpperContent>
          <S.LogoWrapper>
            <Link to="/" aria-label="Vai alla home">
              <Icon type="logo" width={200} />
            </Link>
            <S.ContactsIcons>
              {contactData.map((contact, idx) => (
                <S.IconWrapper
                  title={contact.text}
                  onClick={contact.onClick}
                  key={`contact-${idx}`}
                >
                  {contact.linkURL ? (
                    <a
                      href={contact.linkURL}
                      target="_blank"
                      rel="noopener noreferrer"
                      aria-label={contact.text}
                    >
                      {contact.icon}
                    </a>
                  ) : (
                    <>{contact.icon}</>
                  )}
                </S.IconWrapper>
              ))}
            </S.ContactsIcons>
            <S.ContactsLong>
              <S.ContactsLongText>
                <T.H3>Email: </T.H3>
                <T.H4
                  onClick={() => {
                    window.location.href = `mailto:${contacts["email"].join("")}`
                  }}
                >
                  {contacts["email"]}
                </T.H4>
              </S.ContactsLongText>
              <S.ContactsLongText>
                <T.H3>Telefono: </T.H3>
                <T.H4
                  onClick={() => {
                    window.location.href = `tel:${contacts["phone"].join("")}`
                  }}
                >
                  {contacts["phone"].join(" ")}
                </T.H4>
              </S.ContactsLongText>
            </S.ContactsLong>
          </S.LogoWrapper>
          <S.SponsorsWrapper>
            <T.H2 $font="Caveat">I nostri sponsor</T.H2>
            <Sponsors />
          </S.SponsorsWrapper>
          <S.SitemapWrapper>
            {footerSections.map((main, idx) => (
              <S.LinksColumn key={`sec-mob-${idx}`}>
                {main.url ? (
                  <Link to={main.url}>
                    <T.H3 $font="Caveat">{main.label}</T.H3>
                  </Link>
                ) : (
                  <T.H3 $font="Caveat" key={`sec-mob-${idx}`}>
                    {main.label}
                  </T.H3>
                )}
                {main.subsections.map((subsec, idx) => (
                  <Link to={subsec.url} key={`subsec-mob-${idx}`}>
                    <T.H4>{subsec.label}</T.H4>
                  </Link>
                ))}
              </S.LinksColumn>
            ))}
          </S.SitemapWrapper>
        </S.UpperContent>
        <S.HorizontalSeparator />
        <S.LowerContent>
          <S.TextLink to="/cookies-policy">
            <T.P2 className="text-link">Politica dei Cookies</T.P2>
          </S.TextLink>
          <T.P2>
            ¬© Copyright Andrea Nicolai - GNL Lentiai 2025 - Tutti i diritti
            riservati.
          </T.P2>
        </S.LowerContent>
      </S.MobileFooter>
    </>
  )
}

export default Footer
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/footer/styled.ts
========================================

import styled from "styled-components"
import { breakpointNum, colors } from "../../styles"
import { Link } from "gatsby"

export const Footer = styled.footer`
  background-color: ${colors.green.green400};
  padding: 32px;
  min-height: 32px;
  display: flex;
  flex-direction: column;
  align-items: center;
  @media (max-width: ${breakpointNum.bigtablet + 1}px) {
    display: none;
  }
`

export const MobileFooter = styled.footer`
  background-color: ${colors.green.green400};
  padding: 24px;
  min-height: 32px;
  display: flex;
  flex-direction: column;
  align-items: center;
  @media (min-width: ${breakpointNum.bigtablet}px) {
    display: none;
  }
`

export const UpperContent = styled.div`
  width: 100%;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  flex-wrap: wrap;
  row-gap: 20px;
  column-gap: 30px;
  @media (max-width: ${breakpointNum.medium}px) {
    justify-content: center;
    column-gap: 50px;
  }
  @media (max-width: ${breakpointNum.large}px) {
    & > *:nth-child(3) {
      display: flex;
      justify-content: center;
      flex-basis: 100%;
    }
  }

  @media (max-width: ${breakpointNum.bigtablet}px) {
    justify-content: center;
  }
`

export const LogoWrapper = styled.div`
  min-width: 300px;
  @media (max-width: ${breakpointNum.mobile}px) {
    min-width: 200px;
  }
`

export const ContactsIcons = styled.div`
  gap: 10px;
  display: flex;
  flex-direction: row;
  padding-left: 10px;
`

export const IconWrapper = styled.div`
  cursor: pointer;
  transition: all 0.5s;
  fill: ${colors.green.green800};
  &:hover {
    fill: ${colors.green.green900};
  }
  &:focus {
    fill: ${colors.green.green950};
  }
  > * {
    transition: all 0.5s;
    fill: ${colors.green.green800};
    &:hover {
      fill: ${colors.green.green900};
    }
    &:focus {
      fill: ${colors.green.green950};
    }
    > * {
      transition: all 0.5s;
      fill: ${colors.green.green800};
      &:hover {
        fill: ${colors.green.green900};
      }
      &:focus {
        fill: ${colors.green.green950};
      }
      > * {
        transition: all 0.5s;
        fill: ${colors.green.green800};
        &:hover {
          fill: ${colors.green.green900};
        }
        &:focus {
          fill: ${colors.green.green950};
        }
      }
    }
  }
`

export const ContactsLong = styled.div`
  gap: 10px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  padding-left: 10px;
`

export const ContactsLongText = styled.div`
  display: flex;
  justify-content: space-between;
  margin-top: 5px;
  padding-left: 2px;
  > h4 {
    text-decoration: underline;
    cursor: pointer;
  }
  > * {
    margin-top: 5px;
  }
`

export const SitemapWrapper = styled.div`
  display: flex;
  flex-direction: row;
  gap: 32px;
`

export const LinksColumn = styled.div`
  > * {
    text-align: center;
  }
  > a {
    text-decoration-color: ${colors.green.green900};
    &:active {
      text-decoration-color: ${colors.green.green950};
    }
  }
`

export const SponsorsWrapper = styled.div`
  display: flex;
  flex-direction: column;
  gap: 15px;
  text-align: center;
  align-items: center;
  min-width: 300px;
  > h3 {
    margin-top: 0;
  }
`

export const SponsorPlaceholder = styled.div`
  background-color: ${colors.green.green800};
  min-height: 40px;
  min-width: 100px;
`

export const HorizontalSeparator = styled.div`
  margin-top: 1em;
  margin-bottom: 1em;
  width: 100%;
  border-bottom: 2px solid ${colors.green.green300};
`

export const LowerContent = styled.div`
  text-align: center;
  display: flex;
  flex-direction: row;
  gap: 1em;
  > p {
    margin-top: 0px;
  }
`

export const TextLink = styled(Link)`
  > * {
    margin-top: 0px;
  }

  color: ${colors.green.green800};
  transition: all 0.5s;
  &:active {
    color: ${colors.green.green950};
  }
  &:hover {
    color: ${colors.green.green900};
  }

  .text-link {
    font-weight: bold;
    color: ${colors.green.green800};
    transition: all 0.5s;
    &:active {
      color: ${colors.green.green950};
    }
    &:hover {
      color: ${colors.green.green900};
    }
  }
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/access-warnings/index.tsx
========================================

import React from "react"
import Icon from "../icons"
import * as T from "./../typography"
import * as S from "./styled"

const content = {
  laghetti: {
    icons: ["dog-poo", "litter", "dog-leash"],
    text: {
      header: "LAGHETTI DELLA RIMONTA",
      subheader: "Avvertenze di accesso",
      rules: [
        "L'area √® un biotopo, non un parco giochi. Va percorsa in silenzio per non disturbare l'avifauna",
        "Le biciclette vanno parcheggiate sotto il cavalcavia su una apposita barra di fissaggio. Il sentiero va percorso possibilmente a piedi",
        "Si prega di non lasciare tracce del proprio passaggio (rifiuti, ecc...)",
        "I cani non vanno lasciati liberi",
        "Si prega di raccogliere i bisogni dei vostri animali e di smaltirli nell'apposito bidone situato nella piazza della fontana di Bardies",
      ],
      end: "Grazie per l'attenzione. Buona passeggiata!",
    },
  },
  narcisi: {
    icons: ["crop", "dog-poo", "litter", "dog-leash", "electric-fence"],
    text: {
      header: "AREA FIORITURA NARCISI",
      subheader: "Avvertenze di accesso",
      rules: [
        "I prati sono propriet√† private. Si prega di non entrare nei terreni",
        "I fiori vanno osservati, fotografati, ma non raccolti",
        "Si prega di non uscire dalla strada e di non parcheggiare l'auto sui prati",
        "Si prega di non lasciare tracce del proprio passaggio (rifiuti, ecc...)",
        "I cani non vanno lasciati liberi: attenzione ai recinti elettrificati contro i cinghiali",
        "Si prega di raccogliere i bisogni dei vostri animali",
      ],
      end: "Grazie per l'attenzione. Buona passeggiata!",
    },
  },
}

interface AccessWarningsProps {
  type: "laghetti" | "narcisi"
}

const AccessWarnings = ({ type }: AccessWarningsProps) => {
  const data = content[type]
  if (!data) return <T.H1>Access warnings not found!</T.H1>

  return (
    <S.Wrapper>
      <S.HeaderWrapper>
        <T.H1>{data.text.header}</T.H1>
      </S.HeaderWrapper>

      <S.IconsWrapper>
        {data.icons.map((icon, idx) => (
          <S.IconWrapper key={`icon-${idx}`}>
            <Icon type={icon} />
          </S.IconWrapper>
        ))}
      </S.IconsWrapper>

      <S.HeaderWrapper>
        <T.H2 className="subheader">{data.text.subheader}</T.H2>
      </S.HeaderWrapper>

      <S.ContentWrapper>
        {data.text.rules.map((t, idx) => (
          <S.SingleRuleWrapper key={`rule-${idx}`}>
            <T.P1>{`${idx + 1})`}</T.P1>
            <T.P1>{t}</T.P1>
          </S.SingleRuleWrapper>
        ))}
      </S.ContentWrapper>
    </S.Wrapper>
  )
}

export default AccessWarnings
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/access-warnings/styled.ts
========================================

import styled from "styled-components"
import { breakpointNum, colors } from "../../styles"

export const Wrapper = styled.div`
  display: flex;
  flex-direction: column;
  border: solid 2px ${colors.green.green900};
  border-radius: 8px;
  justify-items: center;
  margin: 32px;
  padding: 32px;
  user-select: none;
  @media (max-width: ${breakpointNum.bigtablet}px) {
    margin: 24px;
    padding: 24px;
  }
  @media (max-width: ${breakpointNum.mobile}px) {
    margin: 16px;
    padding: 16px;
  }
`

export const HeaderWrapper = styled.div`
  justify-items: center;
  text-align: center;
  .subheader {
    color: ${colors.red.warning};
  }
`

export const ContentWrapper = styled.div`
  display: flex;
  flex-direction: column;
  height: 75%;
  justify-content: space-around;
`

export const SingleRuleWrapper = styled.div`
  display: flex;
  flex-direction: row;
  gap: 1em;
`

export const IconsWrapper = styled.div`
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
  gap: 0.5em;
  padding: 16px;
  height: 10%;
  @media (max-width: ${breakpointNum.bigtablet}px) {
    min-height: 120px;
    min-width: 120px;
  }
  @media (max-width: ${breakpointNum.tablet}px) {
    min-height: 100px;
    min-width: 100px;
  }
  @media (max-width: ${breakpointNum.smalltablet}px) {
    min-height: 90px;
    min-width: 90px;
  }
  @media (max-width: ${breakpointNum.mobile}px) {
    padding: 8px;
    min-height: 80px;
  }
`

export const IconWrapper = styled.div`
  display: flex;
  flex-direction: row;
  min-width: 150px;
  min-height: 150px;
  @media (max-width: ${breakpointNum.bigtablet}px) {
    min-width: 120px;
    min-height: 120px;
  }
  @media (max-width: ${breakpointNum.tablet}px) {
    min-width: 100px;
    min-height: 100px;
  }
  @media (max-width: ${breakpointNum.mobile}px) {
    min-width: 50px;
    min-height: 50px;
  }
`
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/pagedata-text-components/index.tsx
========================================

import React from "react"
import { DataJSONType, ImageData } from "../../types"
import { renderComponents } from "./helpers"
import * as S from "./styled"

const ContentToComponent: React.FC<{
  pageData: DataJSONType
  images: ImageData[]
}> = ({ pageData, images }) => (
  <S.MainWrapper>{pageData.map(renderComponents(images))}</S.MainWrapper>
)

export default ContentToComponent
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/pagedata-text-components/styled.ts
========================================

import styled from "styled-components"
import { breakpoint, breakpointNum } from "../../styles"

export const MainWrapper = styled.div`
  display: flex;
  flex-direction: column;
  gap: 60px; 
  padding: 32px;
  justify-content: center;

  width: 100%;
  max-width: 1200px;
  box-sizing: border-box;
  
  @media (max-width: ${breakpointNum.bigtablet}px) {
    display: none;
  }
`

export const ImageWrapper = styled.div`
  display: flex;
  gap: 40px;
  flex-wrap: wrap;
  justify-content: center;
  width: 100%;
`

export const TwoColsWrapper = styled.div`
  display: flex;
  align-items: center;
  gap: 40px; 
  width: 100%;

  @media (max-width: ${breakpoint.bigtablet}) {
    display: none;
  }
  &:nth-child(odd) {
    flex-direction: row;
  }
  &:nth-child(even) {
    flex-direction: row-reverse;
  }
`

export const LeftTwoColsWrapper = styled.div`
  flex: 1;
  padding: 16px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center; /* Centra perfettamente i contenuti orizzontalmente */
`

export const RightTwoColsWrapper = styled.div`
  flex: 1;
  padding: 16px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/components/pagedata-text-components/helpers.tsx
========================================

import {
  DataJSONType,
  ImageContentData,
  ImageData,
  TemplateTwoColumnsData,
  TextContentData,
} from "../../types"
import ImageWithCredits from "../image-with-credits"
import * as S from "./styled"
import * as T from "./../typography"
import React, { Fragment } from "react"

const renderTextInner =
  (
    size: string,
    font: T.FontFamilies | undefined,
    position: "center" | "left" | "right" | undefined,
  ) =>
    (text: string) => {
      const addProps = {
        $textAlign: position,
        $font: font,
        dangerouslySetInnerHTML: { __html: text },
      }
      switch (size) {
        case "h1":
          return <T.H1 {...addProps} />
        case "h2":
          return <T.H2 {...addProps} />
        case "h3":
          return <T.H3 {...addProps} />
        case "h4":
          return <T.H4 {...addProps} />
        case "h5":
          return <T.H5 {...addProps} />
        case "h6":
          return <T.H6 {...addProps} />
        case "h7":
          return <T.H7 {...addProps} />
        case "p1":
          return <T.P1 {...addProps} />
        case "p2":
          return <T.P2 {...addProps} />
        case "p3":
          return <T.P3 {...addProps} />
        case "p4":
          return <T.P1 {...addProps} />
        case "p5":
          return <T.P1 {...addProps} />
        case "note":
          return <T.Notes {...addProps} />
        default:
          return <T.H2>Text size not found</T.H2>
      }
    }

export const renderComponents =
  (images: ImageData[]) =>
    (content: DataJSONType[number], key: Number | string): any => {
      const keyString = key.toString()

      switch (content.type) {
        case "image":
          const castedImgContent = content as ImageContentData
          const filteredImages = castedImgContent.content.map(imgFilename =>
            images.find(img => img.fileName === imgFilename),
          )
          return (
            <S.ImageWrapper key={keyString}>
              {filteredImages.map((img, index) =>
                img ? (
                  img.image && (
                    <ImageWithCredits
                      key={index}
                      title={img.title}
                      description={img.description}
                      alt={img.alt || img.description}
                      image={img.image}
                      copyright={img.copyright}
                      minHeight={content.minHeight}
                      minWidth={content.minWidth}
                      maxHeight={content.maxHeight}
                      maxWidth={content.maxWidth}
                      noDescription={content.noDescription}
                      noCopyright={content.noCopyright}
                      objectFit={content.objectFit}
                    />
                  )
                ) : (
                  <T.H2 key={`img-${index}`}>Image not found</T.H2>
                ),
              )}
            </S.ImageWrapper>
          )
        case "text":
          const castedTextContent = content as TextContentData
          const theText = castedTextContent.content.join(" <br /> ")
          if (!theText) return <T.H2 key={keyString}>Text not found</T.H2>

          const { font, position, size } = castedTextContent
          const textRenderer = renderTextInner(size, font, position)
          return <Fragment key={keyString}>{textRenderer(theText)}</Fragment>

        case "two-columns": {
          const castedTwoColsComponent = content as TemplateTwoColumnsData
          const [leftComponents, rightComponents] = castedTwoColsComponent.content
          return (
            <S.TwoColsWrapper key={keyString}>
              <S.LeftTwoColsWrapper>
                {leftComponents.map((lc, idx) =>
                  renderComponents(images)(lc, `two-cols-left-${idx}`),
                )}
              </S.LeftTwoColsWrapper>
              <S.RightTwoColsWrapper>
                {rightComponents.map((lc, idx) =>
                  renderComponents(images)(lc, `two-cols-right-${idx}`),
                )}
              </S.RightTwoColsWrapper>
            </S.TwoColsWrapper>
          )
        }
        default:
          return <T.H1 key={keyString}>Content type Not Found</T.H1>
      }
    }
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/types/index.ts
========================================

import { IGatsbyImageData } from "gatsby-plugin-image"
import * as T from "../components/typography"

export type ImageData = {
  fileName: string
  title: string
  description: string
  image: IGatsbyImageData | undefined
  copyright: string | undefined
  alt: string | undefined
}

export type ImageContentData = {
  type: "image"
  content: string[]
  maxWidth?: number
  maxHeight?: number
  minWidth?: number
  minHeight?: number
  noDescription?: boolean
  noCopyright?: boolean
  objectFit?: "cover" | "contain" | "fill" | "none" | "scale-down"
}

export type TextContentData = {
  type: "text"
  position?: "left" | "right" | "center"
  content: [string]
  size:
  | "h1"
  | "h2"
  | "h3"
  | "h4"
  | "h5"
  | "h6"
  | "h7"
  | "p1"
  | "p2"
  | "p3"
  | "p4"
  | "p5"
  | "note"
  font?: T.FontFamilies
  collapsible?: boolean
}

export type TemplateTwoColumnsData = {
  type: "two-columns"
  content: [
    (ImageContentData | TextContentData)[],
    (ImageContentData | TextContentData)[],
  ]
}

export type DataJSONType = (
  | ImageContentData
  | TextContentData
  | TemplateTwoColumnsData
)[]

export type Location = {
  iconType?: "default" | "park" | "daffodil"
  name: string
  lat: number
  lon: number
  type: string
}
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/svg.d.ts
========================================

declare module "*.svg" {
  import * as React from "react"

  export const ReactComponent: React.FunctionComponent<
    React.SVGProps<SVGSVGElement> & { title?: string }
  >
}
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/gatsby-types.d.ts
========================================

/* eslint-disable */

/* prettier-ignore */

/* THIS FILE IS AUTOGENERATED. CHANGES WILL BE LOST ON SUBSEQUENT RUNS. */

declare namespace Queries {

type Maybe<T> = T | null;
type InputMaybe<T> = T | null;
type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
type Scalars = {
  /** The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. */
  ID: string;
  /** The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. */
  String: string;
  /** The `Boolean` scalar type represents `true` or `false`. */
  Boolean: boolean;
  /** The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. */
  Int: number;
  /** The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). */
  Float: number;
  /** A date string, such as 2007-12-03, compliant with the ISO 8601 standard for representation of dates and times using the Gregorian calendar. */
  Date: string;
  GatsbyImageData: import('gatsby-plugin-image').IGatsbyImageData;
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: Record<string, unknown>;
};

type AVIFOptions = {
  readonly lossless: InputMaybe<Scalars['Boolean']>;
  readonly quality: InputMaybe<Scalars['Int']>;
  readonly speed: InputMaybe<Scalars['Int']>;
};

type BlurredOptions = {
  /** Force the output format for the low-res preview. Default is to use the same format as the input. You should rarely need to change this */
  readonly toFormat: InputMaybe<ImageFormat>;
  /** Width of the generated low-res preview. Default is 20px */
  readonly width: InputMaybe<Scalars['Int']>;
};

type BooleanQueryOperatorInput = {
  readonly eq: InputMaybe<Scalars['Boolean']>;
  readonly in: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Boolean']>>>;
  readonly ne: InputMaybe<Scalars['Boolean']>;
  readonly nin: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Boolean']>>>;
};

type DataJson = Node & {
  readonly IBAN: Maybe<DataJsonIBAN>;
  readonly children: ReadonlyArray<Node>;
  readonly email: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly facebook_laghetti: Maybe<Scalars['String']>;
  readonly facebook_narcisi: Maybe<Scalars['String']>;
  readonly id: Scalars['ID'];
  readonly internal: Internal;
  readonly parent: Maybe<Node>;
  readonly phone: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly youtube: Maybe<Scalars['String']>;
};

type DataJsonConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<DataJsonEdge>;
  readonly group: ReadonlyArray<DataJsonGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<DataJson>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type DataJsonConnection_distinctArgs = {
  field: DataJsonFieldSelector;
};


type DataJsonConnection_groupArgs = {
  field: DataJsonFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type DataJsonConnection_maxArgs = {
  field: DataJsonFieldSelector;
};


type DataJsonConnection_minArgs = {
  field: DataJsonFieldSelector;
};


type DataJsonConnection_sumArgs = {
  field: DataJsonFieldSelector;
};

type DataJsonEdge = {
  readonly next: Maybe<DataJson>;
  readonly node: DataJson;
  readonly previous: Maybe<DataJson>;
};

type DataJsonFieldSelector = {
  readonly IBAN: InputMaybe<DataJsonIBANFieldSelector>;
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly email: InputMaybe<FieldSelectorEnum>;
  readonly facebook_laghetti: InputMaybe<FieldSelectorEnum>;
  readonly facebook_narcisi: InputMaybe<FieldSelectorEnum>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly parent: InputMaybe<NodeFieldSelector>;
  readonly phone: InputMaybe<FieldSelectorEnum>;
  readonly youtube: InputMaybe<FieldSelectorEnum>;
};

type DataJsonFilterInput = {
  readonly IBAN: InputMaybe<DataJsonIBANFilterInput>;
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly email: InputMaybe<StringQueryOperatorInput>;
  readonly facebook_laghetti: InputMaybe<StringQueryOperatorInput>;
  readonly facebook_narcisi: InputMaybe<StringQueryOperatorInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
  readonly phone: InputMaybe<StringQueryOperatorInput>;
  readonly youtube: InputMaybe<StringQueryOperatorInput>;
};

type DataJsonFilterListInput = {
  readonly elemMatch: InputMaybe<DataJsonFilterInput>;
};

type DataJsonGroupConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<DataJsonEdge>;
  readonly field: Scalars['String'];
  readonly fieldValue: Maybe<Scalars['String']>;
  readonly group: ReadonlyArray<DataJsonGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<DataJson>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type DataJsonGroupConnection_distinctArgs = {
  field: DataJsonFieldSelector;
};


type DataJsonGroupConnection_groupArgs = {
  field: DataJsonFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type DataJsonGroupConnection_maxArgs = {
  field: DataJsonFieldSelector;
};


type DataJsonGroupConnection_minArgs = {
  field: DataJsonFieldSelector;
};


type DataJsonGroupConnection_sumArgs = {
  field: DataJsonFieldSelector;
};

type DataJsonIBAN = {
  readonly account: Maybe<Scalars['String']>;
  readonly bank: Maybe<Scalars['String']>;
};

type DataJsonIBANFieldSelector = {
  readonly account: InputMaybe<FieldSelectorEnum>;
  readonly bank: InputMaybe<FieldSelectorEnum>;
};

type DataJsonIBANFilterInput = {
  readonly account: InputMaybe<StringQueryOperatorInput>;
  readonly bank: InputMaybe<StringQueryOperatorInput>;
};

type DataJsonIBANSortInput = {
  readonly account: InputMaybe<SortOrderEnum>;
  readonly bank: InputMaybe<SortOrderEnum>;
};

type DataJsonSortInput = {
  readonly IBAN: InputMaybe<DataJsonIBANSortInput>;
  readonly children: InputMaybe<NodeSortInput>;
  readonly email: InputMaybe<SortOrderEnum>;
  readonly facebook_laghetti: InputMaybe<SortOrderEnum>;
  readonly facebook_narcisi: InputMaybe<SortOrderEnum>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly parent: InputMaybe<NodeSortInput>;
  readonly phone: InputMaybe<SortOrderEnum>;
  readonly youtube: InputMaybe<SortOrderEnum>;
};

type DateQueryOperatorInput = {
  readonly eq: InputMaybe<Scalars['Date']>;
  readonly gt: InputMaybe<Scalars['Date']>;
  readonly gte: InputMaybe<Scalars['Date']>;
  readonly in: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Date']>>>;
  readonly lt: InputMaybe<Scalars['Date']>;
  readonly lte: InputMaybe<Scalars['Date']>;
  readonly ne: InputMaybe<Scalars['Date']>;
  readonly nin: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Date']>>>;
};

type Directory = Node & {
  readonly absolutePath: Scalars['String'];
  readonly accessTime: Scalars['Date'];
  readonly atime: Scalars['Date'];
  readonly atimeMs: Scalars['Float'];
  readonly base: Scalars['String'];
  readonly birthTime: Scalars['Date'];
  /** @deprecated Use `birthTime` instead */
  readonly birthtime: Maybe<Scalars['Date']>;
  /** @deprecated Use `birthTime` instead */
  readonly birthtimeMs: Maybe<Scalars['Float']>;
  readonly changeTime: Scalars['Date'];
  readonly children: ReadonlyArray<Node>;
  readonly ctime: Scalars['Date'];
  readonly ctimeMs: Scalars['Float'];
  readonly dev: Scalars['Int'];
  readonly dir: Scalars['String'];
  readonly ext: Scalars['String'];
  readonly extension: Scalars['String'];
  readonly gid: Scalars['Int'];
  readonly id: Scalars['ID'];
  readonly ino: Scalars['Float'];
  readonly internal: Internal;
  readonly mode: Scalars['Int'];
  readonly modifiedTime: Scalars['Date'];
  readonly mtime: Scalars['Date'];
  readonly mtimeMs: Scalars['Float'];
  readonly name: Scalars['String'];
  readonly nlink: Scalars['Int'];
  readonly parent: Maybe<Node>;
  readonly prettySize: Scalars['String'];
  readonly rdev: Scalars['Int'];
  readonly relativeDirectory: Scalars['String'];
  readonly relativePath: Scalars['String'];
  readonly root: Scalars['String'];
  readonly size: Scalars['Int'];
  readonly sourceInstanceName: Scalars['String'];
  readonly uid: Scalars['Int'];
};


type Directory_accessTimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type Directory_atimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type Directory_birthTimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type Directory_changeTimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type Directory_ctimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type Directory_modifiedTimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type Directory_mtimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};

type DirectoryConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<DirectoryEdge>;
  readonly group: ReadonlyArray<DirectoryGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<Directory>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type DirectoryConnection_distinctArgs = {
  field: DirectoryFieldSelector;
};


type DirectoryConnection_groupArgs = {
  field: DirectoryFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type DirectoryConnection_maxArgs = {
  field: DirectoryFieldSelector;
};


type DirectoryConnection_minArgs = {
  field: DirectoryFieldSelector;
};


type DirectoryConnection_sumArgs = {
  field: DirectoryFieldSelector;
};

type DirectoryEdge = {
  readonly next: Maybe<Directory>;
  readonly node: Directory;
  readonly previous: Maybe<Directory>;
};

type DirectoryFieldSelector = {
  readonly absolutePath: InputMaybe<FieldSelectorEnum>;
  readonly accessTime: InputMaybe<FieldSelectorEnum>;
  readonly atime: InputMaybe<FieldSelectorEnum>;
  readonly atimeMs: InputMaybe<FieldSelectorEnum>;
  readonly base: InputMaybe<FieldSelectorEnum>;
  readonly birthTime: InputMaybe<FieldSelectorEnum>;
  readonly birthtime: InputMaybe<FieldSelectorEnum>;
  readonly birthtimeMs: InputMaybe<FieldSelectorEnum>;
  readonly changeTime: InputMaybe<FieldSelectorEnum>;
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly ctime: InputMaybe<FieldSelectorEnum>;
  readonly ctimeMs: InputMaybe<FieldSelectorEnum>;
  readonly dev: InputMaybe<FieldSelectorEnum>;
  readonly dir: InputMaybe<FieldSelectorEnum>;
  readonly ext: InputMaybe<FieldSelectorEnum>;
  readonly extension: InputMaybe<FieldSelectorEnum>;
  readonly gid: InputMaybe<FieldSelectorEnum>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly ino: InputMaybe<FieldSelectorEnum>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly mode: InputMaybe<FieldSelectorEnum>;
  readonly modifiedTime: InputMaybe<FieldSelectorEnum>;
  readonly mtime: InputMaybe<FieldSelectorEnum>;
  readonly mtimeMs: InputMaybe<FieldSelectorEnum>;
  readonly name: InputMaybe<FieldSelectorEnum>;
  readonly nlink: InputMaybe<FieldSelectorEnum>;
  readonly parent: InputMaybe<NodeFieldSelector>;
  readonly prettySize: InputMaybe<FieldSelectorEnum>;
  readonly rdev: InputMaybe<FieldSelectorEnum>;
  readonly relativeDirectory: InputMaybe<FieldSelectorEnum>;
  readonly relativePath: InputMaybe<FieldSelectorEnum>;
  readonly root: InputMaybe<FieldSelectorEnum>;
  readonly size: InputMaybe<FieldSelectorEnum>;
  readonly sourceInstanceName: InputMaybe<FieldSelectorEnum>;
  readonly uid: InputMaybe<FieldSelectorEnum>;
};

type DirectoryFilterInput = {
  readonly absolutePath: InputMaybe<StringQueryOperatorInput>;
  readonly accessTime: InputMaybe<DateQueryOperatorInput>;
  readonly atime: InputMaybe<DateQueryOperatorInput>;
  readonly atimeMs: InputMaybe<FloatQueryOperatorInput>;
  readonly base: InputMaybe<StringQueryOperatorInput>;
  readonly birthTime: InputMaybe<DateQueryOperatorInput>;
  readonly birthtime: InputMaybe<DateQueryOperatorInput>;
  readonly birthtimeMs: InputMaybe<FloatQueryOperatorInput>;
  readonly changeTime: InputMaybe<DateQueryOperatorInput>;
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly ctime: InputMaybe<DateQueryOperatorInput>;
  readonly ctimeMs: InputMaybe<FloatQueryOperatorInput>;
  readonly dev: InputMaybe<IntQueryOperatorInput>;
  readonly dir: InputMaybe<StringQueryOperatorInput>;
  readonly ext: InputMaybe<StringQueryOperatorInput>;
  readonly extension: InputMaybe<StringQueryOperatorInput>;
  readonly gid: InputMaybe<IntQueryOperatorInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly ino: InputMaybe<FloatQueryOperatorInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly mode: InputMaybe<IntQueryOperatorInput>;
  readonly modifiedTime: InputMaybe<DateQueryOperatorInput>;
  readonly mtime: InputMaybe<DateQueryOperatorInput>;
  readonly mtimeMs: InputMaybe<FloatQueryOperatorInput>;
  readonly name: InputMaybe<StringQueryOperatorInput>;
  readonly nlink: InputMaybe<IntQueryOperatorInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
  readonly prettySize: InputMaybe<StringQueryOperatorInput>;
  readonly rdev: InputMaybe<IntQueryOperatorInput>;
  readonly relativeDirectory: InputMaybe<StringQueryOperatorInput>;
  readonly relativePath: InputMaybe<StringQueryOperatorInput>;
  readonly root: InputMaybe<StringQueryOperatorInput>;
  readonly size: InputMaybe<IntQueryOperatorInput>;
  readonly sourceInstanceName: InputMaybe<StringQueryOperatorInput>;
  readonly uid: InputMaybe<IntQueryOperatorInput>;
};

type DirectoryGroupConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<DirectoryEdge>;
  readonly field: Scalars['String'];
  readonly fieldValue: Maybe<Scalars['String']>;
  readonly group: ReadonlyArray<DirectoryGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<Directory>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type DirectoryGroupConnection_distinctArgs = {
  field: DirectoryFieldSelector;
};


type DirectoryGroupConnection_groupArgs = {
  field: DirectoryFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type DirectoryGroupConnection_maxArgs = {
  field: DirectoryFieldSelector;
};


type DirectoryGroupConnection_minArgs = {
  field: DirectoryFieldSelector;
};


type DirectoryGroupConnection_sumArgs = {
  field: DirectoryFieldSelector;
};

type DirectorySortInput = {
  readonly absolutePath: InputMaybe<SortOrderEnum>;
  readonly accessTime: InputMaybe<SortOrderEnum>;
  readonly atime: InputMaybe<SortOrderEnum>;
  readonly atimeMs: InputMaybe<SortOrderEnum>;
  readonly base: InputMaybe<SortOrderEnum>;
  readonly birthTime: InputMaybe<SortOrderEnum>;
  readonly birthtime: InputMaybe<SortOrderEnum>;
  readonly birthtimeMs: InputMaybe<SortOrderEnum>;
  readonly changeTime: InputMaybe<SortOrderEnum>;
  readonly children: InputMaybe<NodeSortInput>;
  readonly ctime: InputMaybe<SortOrderEnum>;
  readonly ctimeMs: InputMaybe<SortOrderEnum>;
  readonly dev: InputMaybe<SortOrderEnum>;
  readonly dir: InputMaybe<SortOrderEnum>;
  readonly ext: InputMaybe<SortOrderEnum>;
  readonly extension: InputMaybe<SortOrderEnum>;
  readonly gid: InputMaybe<SortOrderEnum>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly ino: InputMaybe<SortOrderEnum>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly mode: InputMaybe<SortOrderEnum>;
  readonly modifiedTime: InputMaybe<SortOrderEnum>;
  readonly mtime: InputMaybe<SortOrderEnum>;
  readonly mtimeMs: InputMaybe<SortOrderEnum>;
  readonly name: InputMaybe<SortOrderEnum>;
  readonly nlink: InputMaybe<SortOrderEnum>;
  readonly parent: InputMaybe<NodeSortInput>;
  readonly prettySize: InputMaybe<SortOrderEnum>;
  readonly rdev: InputMaybe<SortOrderEnum>;
  readonly relativeDirectory: InputMaybe<SortOrderEnum>;
  readonly relativePath: InputMaybe<SortOrderEnum>;
  readonly root: InputMaybe<SortOrderEnum>;
  readonly size: InputMaybe<SortOrderEnum>;
  readonly sourceInstanceName: InputMaybe<SortOrderEnum>;
  readonly uid: InputMaybe<SortOrderEnum>;
};

type DuotoneGradient = {
  readonly highlight: Scalars['String'];
  readonly opacity: InputMaybe<Scalars['Int']>;
  readonly shadow: Scalars['String'];
};

type FieldSelectorEnum =
  | 'SELECT';

type File = Node & {
  readonly absolutePath: Scalars['String'];
  readonly accessTime: Scalars['Date'];
  readonly atime: Scalars['Date'];
  readonly atimeMs: Scalars['Float'];
  readonly base: Scalars['String'];
  readonly birthTime: Scalars['Date'];
  /** @deprecated Use `birthTime` instead */
  readonly birthtime: Maybe<Scalars['Date']>;
  /** @deprecated Use `birthTime` instead */
  readonly birthtimeMs: Maybe<Scalars['Float']>;
  readonly blksize: Maybe<Scalars['Int']>;
  readonly blocks: Maybe<Scalars['Int']>;
  readonly changeTime: Scalars['Date'];
  /** Returns the first child node of type DataJson or null if there are no children of given type on this node */
  readonly childDataJson: Maybe<DataJson>;
  /** Returns the first child node of type ImageMetadataJson or null if there are no children of given type on this node */
  readonly childImageMetadataJson: Maybe<ImageMetadataJson>;
  /** Returns the first child node of type ImageSharp or null if there are no children of given type on this node */
  readonly childImageSharp: Maybe<ImageSharp>;
  readonly children: ReadonlyArray<Node>;
  /** Returns all children nodes filtered by type DataJson */
  readonly childrenDataJson: Maybe<ReadonlyArray<Maybe<DataJson>>>;
  /** Returns all children nodes filtered by type ImageMetadataJson */
  readonly childrenImageMetadataJson: Maybe<ReadonlyArray<Maybe<ImageMetadataJson>>>;
  /** Returns all children nodes filtered by type ImageSharp */
  readonly childrenImageSharp: Maybe<ReadonlyArray<Maybe<ImageSharp>>>;
  readonly ctime: Scalars['Date'];
  readonly ctimeMs: Scalars['Float'];
  readonly dev: Scalars['Int'];
  readonly dir: Scalars['String'];
  readonly ext: Scalars['String'];
  readonly extension: Scalars['String'];
  readonly gid: Scalars['Int'];
  readonly id: Scalars['ID'];
  readonly ino: Scalars['Float'];
  readonly internal: Internal;
  readonly mode: Scalars['Int'];
  readonly modifiedTime: Scalars['Date'];
  readonly mtime: Scalars['Date'];
  readonly mtimeMs: Scalars['Float'];
  readonly name: Scalars['String'];
  readonly nlink: Scalars['Int'];
  readonly parent: Maybe<Node>;
  readonly prettySize: Scalars['String'];
  /** Copy file to static directory and return public url to it */
  readonly publicURL: Maybe<Scalars['String']>;
  readonly rdev: Scalars['Int'];
  readonly relativeDirectory: Scalars['String'];
  readonly relativePath: Scalars['String'];
  readonly root: Scalars['String'];
  readonly size: Scalars['Int'];
  readonly sourceInstanceName: Scalars['String'];
  readonly uid: Scalars['Int'];
};


type File_accessTimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type File_atimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type File_birthTimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type File_changeTimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type File_ctimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type File_modifiedTimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type File_mtimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};

type FileConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<FileEdge>;
  readonly group: ReadonlyArray<FileGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<File>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type FileConnection_distinctArgs = {
  field: FileFieldSelector;
};


type FileConnection_groupArgs = {
  field: FileFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type FileConnection_maxArgs = {
  field: FileFieldSelector;
};


type FileConnection_minArgs = {
  field: FileFieldSelector;
};


type FileConnection_sumArgs = {
  field: FileFieldSelector;
};

type FileEdge = {
  readonly next: Maybe<File>;
  readonly node: File;
  readonly previous: Maybe<File>;
};

type FileFieldSelector = {
  readonly absolutePath: InputMaybe<FieldSelectorEnum>;
  readonly accessTime: InputMaybe<FieldSelectorEnum>;
  readonly atime: InputMaybe<FieldSelectorEnum>;
  readonly atimeMs: InputMaybe<FieldSelectorEnum>;
  readonly base: InputMaybe<FieldSelectorEnum>;
  readonly birthTime: InputMaybe<FieldSelectorEnum>;
  readonly birthtime: InputMaybe<FieldSelectorEnum>;
  readonly birthtimeMs: InputMaybe<FieldSelectorEnum>;
  readonly blksize: InputMaybe<FieldSelectorEnum>;
  readonly blocks: InputMaybe<FieldSelectorEnum>;
  readonly changeTime: InputMaybe<FieldSelectorEnum>;
  readonly childDataJson: InputMaybe<DataJsonFieldSelector>;
  readonly childImageMetadataJson: InputMaybe<ImageMetadataJsonFieldSelector>;
  readonly childImageSharp: InputMaybe<ImageSharpFieldSelector>;
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly childrenDataJson: InputMaybe<DataJsonFieldSelector>;
  readonly childrenImageMetadataJson: InputMaybe<ImageMetadataJsonFieldSelector>;
  readonly childrenImageSharp: InputMaybe<ImageSharpFieldSelector>;
  readonly ctime: InputMaybe<FieldSelectorEnum>;
  readonly ctimeMs: InputMaybe<FieldSelectorEnum>;
  readonly dev: InputMaybe<FieldSelectorEnum>;
  readonly dir: InputMaybe<FieldSelectorEnum>;
  readonly ext: InputMaybe<FieldSelectorEnum>;
  readonly extension: InputMaybe<FieldSelectorEnum>;
  readonly gid: InputMaybe<FieldSelectorEnum>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly ino: InputMaybe<FieldSelectorEnum>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly mode: InputMaybe<FieldSelectorEnum>;
  readonly modifiedTime: InputMaybe<FieldSelectorEnum>;
  readonly mtime: InputMaybe<FieldSelectorEnum>;
  readonly mtimeMs: InputMaybe<FieldSelectorEnum>;
  readonly name: InputMaybe<FieldSelectorEnum>;
  readonly nlink: InputMaybe<FieldSelectorEnum>;
  readonly parent: InputMaybe<NodeFieldSelector>;
  readonly prettySize: InputMaybe<FieldSelectorEnum>;
  readonly publicURL: InputMaybe<FieldSelectorEnum>;
  readonly rdev: InputMaybe<FieldSelectorEnum>;
  readonly relativeDirectory: InputMaybe<FieldSelectorEnum>;
  readonly relativePath: InputMaybe<FieldSelectorEnum>;
  readonly root: InputMaybe<FieldSelectorEnum>;
  readonly size: InputMaybe<FieldSelectorEnum>;
  readonly sourceInstanceName: InputMaybe<FieldSelectorEnum>;
  readonly uid: InputMaybe<FieldSelectorEnum>;
};

type FileFilterInput = {
  readonly absolutePath: InputMaybe<StringQueryOperatorInput>;
  readonly accessTime: InputMaybe<DateQueryOperatorInput>;
  readonly atime: InputMaybe<DateQueryOperatorInput>;
  readonly atimeMs: InputMaybe<FloatQueryOperatorInput>;
  readonly base: InputMaybe<StringQueryOperatorInput>;
  readonly birthTime: InputMaybe<DateQueryOperatorInput>;
  readonly birthtime: InputMaybe<DateQueryOperatorInput>;
  readonly birthtimeMs: InputMaybe<FloatQueryOperatorInput>;
  readonly blksize: InputMaybe<IntQueryOperatorInput>;
  readonly blocks: InputMaybe<IntQueryOperatorInput>;
  readonly changeTime: InputMaybe<DateQueryOperatorInput>;
  readonly childDataJson: InputMaybe<DataJsonFilterInput>;
  readonly childImageMetadataJson: InputMaybe<ImageMetadataJsonFilterInput>;
  readonly childImageSharp: InputMaybe<ImageSharpFilterInput>;
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly childrenDataJson: InputMaybe<DataJsonFilterListInput>;
  readonly childrenImageMetadataJson: InputMaybe<ImageMetadataJsonFilterListInput>;
  readonly childrenImageSharp: InputMaybe<ImageSharpFilterListInput>;
  readonly ctime: InputMaybe<DateQueryOperatorInput>;
  readonly ctimeMs: InputMaybe<FloatQueryOperatorInput>;
  readonly dev: InputMaybe<IntQueryOperatorInput>;
  readonly dir: InputMaybe<StringQueryOperatorInput>;
  readonly ext: InputMaybe<StringQueryOperatorInput>;
  readonly extension: InputMaybe<StringQueryOperatorInput>;
  readonly gid: InputMaybe<IntQueryOperatorInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly ino: InputMaybe<FloatQueryOperatorInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly mode: InputMaybe<IntQueryOperatorInput>;
  readonly modifiedTime: InputMaybe<DateQueryOperatorInput>;
  readonly mtime: InputMaybe<DateQueryOperatorInput>;
  readonly mtimeMs: InputMaybe<FloatQueryOperatorInput>;
  readonly name: InputMaybe<StringQueryOperatorInput>;
  readonly nlink: InputMaybe<IntQueryOperatorInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
  readonly prettySize: InputMaybe<StringQueryOperatorInput>;
  readonly publicURL: InputMaybe<StringQueryOperatorInput>;
  readonly rdev: InputMaybe<IntQueryOperatorInput>;
  readonly relativeDirectory: InputMaybe<StringQueryOperatorInput>;
  readonly relativePath: InputMaybe<StringQueryOperatorInput>;
  readonly root: InputMaybe<StringQueryOperatorInput>;
  readonly size: InputMaybe<IntQueryOperatorInput>;
  readonly sourceInstanceName: InputMaybe<StringQueryOperatorInput>;
  readonly uid: InputMaybe<IntQueryOperatorInput>;
};

type FileGroupConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<FileEdge>;
  readonly field: Scalars['String'];
  readonly fieldValue: Maybe<Scalars['String']>;
  readonly group: ReadonlyArray<FileGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<File>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type FileGroupConnection_distinctArgs = {
  field: FileFieldSelector;
};


type FileGroupConnection_groupArgs = {
  field: FileFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type FileGroupConnection_maxArgs = {
  field: FileFieldSelector;
};


type FileGroupConnection_minArgs = {
  field: FileFieldSelector;
};


type FileGroupConnection_sumArgs = {
  field: FileFieldSelector;
};

type FileSortInput = {
  readonly absolutePath: InputMaybe<SortOrderEnum>;
  readonly accessTime: InputMaybe<SortOrderEnum>;
  readonly atime: InputMaybe<SortOrderEnum>;
  readonly atimeMs: InputMaybe<SortOrderEnum>;
  readonly base: InputMaybe<SortOrderEnum>;
  readonly birthTime: InputMaybe<SortOrderEnum>;
  readonly birthtime: InputMaybe<SortOrderEnum>;
  readonly birthtimeMs: InputMaybe<SortOrderEnum>;
  readonly blksize: InputMaybe<SortOrderEnum>;
  readonly blocks: InputMaybe<SortOrderEnum>;
  readonly changeTime: InputMaybe<SortOrderEnum>;
  readonly childDataJson: InputMaybe<DataJsonSortInput>;
  readonly childImageMetadataJson: InputMaybe<ImageMetadataJsonSortInput>;
  readonly childImageSharp: InputMaybe<ImageSharpSortInput>;
  readonly children: InputMaybe<NodeSortInput>;
  readonly childrenDataJson: InputMaybe<DataJsonSortInput>;
  readonly childrenImageMetadataJson: InputMaybe<ImageMetadataJsonSortInput>;
  readonly childrenImageSharp: InputMaybe<ImageSharpSortInput>;
  readonly ctime: InputMaybe<SortOrderEnum>;
  readonly ctimeMs: InputMaybe<SortOrderEnum>;
  readonly dev: InputMaybe<SortOrderEnum>;
  readonly dir: InputMaybe<SortOrderEnum>;
  readonly ext: InputMaybe<SortOrderEnum>;
  readonly extension: InputMaybe<SortOrderEnum>;
  readonly gid: InputMaybe<SortOrderEnum>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly ino: InputMaybe<SortOrderEnum>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly mode: InputMaybe<SortOrderEnum>;
  readonly modifiedTime: InputMaybe<SortOrderEnum>;
  readonly mtime: InputMaybe<SortOrderEnum>;
  readonly mtimeMs: InputMaybe<SortOrderEnum>;
  readonly name: InputMaybe<SortOrderEnum>;
  readonly nlink: InputMaybe<SortOrderEnum>;
  readonly parent: InputMaybe<NodeSortInput>;
  readonly prettySize: InputMaybe<SortOrderEnum>;
  readonly publicURL: InputMaybe<SortOrderEnum>;
  readonly rdev: InputMaybe<SortOrderEnum>;
  readonly relativeDirectory: InputMaybe<SortOrderEnum>;
  readonly relativePath: InputMaybe<SortOrderEnum>;
  readonly root: InputMaybe<SortOrderEnum>;
  readonly size: InputMaybe<SortOrderEnum>;
  readonly sourceInstanceName: InputMaybe<SortOrderEnum>;
  readonly uid: InputMaybe<SortOrderEnum>;
};

type FloatQueryOperatorInput = {
  readonly eq: InputMaybe<Scalars['Float']>;
  readonly gt: InputMaybe<Scalars['Float']>;
  readonly gte: InputMaybe<Scalars['Float']>;
  readonly in: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Float']>>>;
  readonly lt: InputMaybe<Scalars['Float']>;
  readonly lte: InputMaybe<Scalars['Float']>;
  readonly ne: InputMaybe<Scalars['Float']>;
  readonly nin: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Float']>>>;
};

type GatsbyImageDataQueryOperatorInput = {
  readonly eq: InputMaybe<Scalars['GatsbyImageData']>;
  readonly in: InputMaybe<ReadonlyArray<InputMaybe<Scalars['GatsbyImageData']>>>;
  readonly ne: InputMaybe<Scalars['GatsbyImageData']>;
  readonly nin: InputMaybe<ReadonlyArray<InputMaybe<Scalars['GatsbyImageData']>>>;
};

type GatsbyImageFormat =
  | 'auto'
  | 'avif'
  | 'jpg'
  | ''
  | 'png'
  | 'webp';

type GatsbyImageLayout =
  | 'constrained'
  | 'fixed'
  | 'fullWidth';

type GatsbyImagePlaceholder =
  | 'blurred'
  | 'dominantColor'
  | 'none'
  | 'tracedSVG';

type ImageCropFocus =
  | 17
  | 0
  | 2
  | 16
  | 1
  | 5
  | 8
  | 3
  | 6
  | 7
  | 4;

type ImageFit =
  | 'contain'
  | 'cover'
  | 'fill'
  | 'inside'
  | 'outside';

type ImageFormat =
  | ''
  | 'avif'
  | 'jpg'
  | ''
  | 'png'
  | 'webp';

type ImageLayout =
  | 'constrained'
  | 'fixed'
  | 'fullWidth';

type ImageMetadataJson = Node & {
  readonly alt: Maybe<Scalars['String']>;
  readonly children: ReadonlyArray<Node>;
  readonly copyright: Maybe<Scalars['String']>;
  readonly description: Maybe<Scalars['String']>;
  readonly fileName: Maybe<Scalars['String']>;
  readonly id: Scalars['ID'];
  readonly internal: Internal;
  readonly parent: Maybe<Node>;
  readonly tags: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly title: Maybe<Scalars['String']>;
};

type ImageMetadataJsonConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<ImageMetadataJsonEdge>;
  readonly group: ReadonlyArray<ImageMetadataJsonGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<ImageMetadataJson>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type ImageMetadataJsonConnection_distinctArgs = {
  field: ImageMetadataJsonFieldSelector;
};


type ImageMetadataJsonConnection_groupArgs = {
  field: ImageMetadataJsonFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type ImageMetadataJsonConnection_maxArgs = {
  field: ImageMetadataJsonFieldSelector;
};


type ImageMetadataJsonConnection_minArgs = {
  field: ImageMetadataJsonFieldSelector;
};


type ImageMetadataJsonConnection_sumArgs = {
  field: ImageMetadataJsonFieldSelector;
};

type ImageMetadataJsonEdge = {
  readonly next: Maybe<ImageMetadataJson>;
  readonly node: ImageMetadataJson;
  readonly previous: Maybe<ImageMetadataJson>;
};

type ImageMetadataJsonFieldSelector = {
  readonly alt: InputMaybe<FieldSelectorEnum>;
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly copyright: InputMaybe<FieldSelectorEnum>;
  readonly description: InputMaybe<FieldSelectorEnum>;
  readonly fileName: InputMaybe<FieldSelectorEnum>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly parent: InputMaybe<NodeFieldSelector>;
  readonly tags: InputMaybe<FieldSelectorEnum>;
  readonly title: InputMaybe<FieldSelectorEnum>;
};

type ImageMetadataJsonFilterInput = {
  readonly alt: InputMaybe<StringQueryOperatorInput>;
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly copyright: InputMaybe<StringQueryOperatorInput>;
  readonly description: InputMaybe<StringQueryOperatorInput>;
  readonly fileName: InputMaybe<StringQueryOperatorInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
  readonly tags: InputMaybe<StringQueryOperatorInput>;
  readonly title: InputMaybe<StringQueryOperatorInput>;
};

type ImageMetadataJsonFilterListInput = {
  readonly elemMatch: InputMaybe<ImageMetadataJsonFilterInput>;
};

type ImageMetadataJsonGroupConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<ImageMetadataJsonEdge>;
  readonly field: Scalars['String'];
  readonly fieldValue: Maybe<Scalars['String']>;
  readonly group: ReadonlyArray<ImageMetadataJsonGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<ImageMetadataJson>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type ImageMetadataJsonGroupConnection_distinctArgs = {
  field: ImageMetadataJsonFieldSelector;
};


type ImageMetadataJsonGroupConnection_groupArgs = {
  field: ImageMetadataJsonFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type ImageMetadataJsonGroupConnection_maxArgs = {
  field: ImageMetadataJsonFieldSelector;
};


type ImageMetadataJsonGroupConnection_minArgs = {
  field: ImageMetadataJsonFieldSelector;
};


type ImageMetadataJsonGroupConnection_sumArgs = {
  field: ImageMetadataJsonFieldSelector;
};

type ImageMetadataJsonSortInput = {
  readonly alt: InputMaybe<SortOrderEnum>;
  readonly children: InputMaybe<NodeSortInput>;
  readonly copyright: InputMaybe<SortOrderEnum>;
  readonly description: InputMaybe<SortOrderEnum>;
  readonly fileName: InputMaybe<SortOrderEnum>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly parent: InputMaybe<NodeSortInput>;
  readonly tags: InputMaybe<SortOrderEnum>;
  readonly title: InputMaybe<SortOrderEnum>;
};

type ImagePlaceholder =
  | 'blurred'
  | 'dominantColor'
  | 'none'
  | 'tracedSVG';

type ImageSharp = Node & {
  readonly children: ReadonlyArray<Node>;
  readonly fixed: Maybe<ImageSharpFixed>;
  readonly fluid: Maybe<ImageSharpFluid>;
  readonly gatsbyImageData: Scalars['GatsbyImageData'];
  readonly id: Scalars['ID'];
  readonly internal: Internal;
  readonly original: Maybe<ImageSharpOriginal>;
  readonly parent: Maybe<Node>;
  readonly resize: Maybe<ImageSharpResize>;
};


type ImageSharp_fixedArgs = {
  background?: InputMaybe<Scalars['String']>;
  base64Width: InputMaybe<Scalars['Int']>;
  cropFocus?: InputMaybe<ImageCropFocus>;
  duotone: InputMaybe<DuotoneGradient>;
  fit?: InputMaybe<ImageFit>;
  grayscale?: InputMaybe<Scalars['Boolean']>;
  height: InputMaybe<Scalars['Int']>;
  jpegProgressive?: InputMaybe<Scalars['Boolean']>;
  jpegQuality: InputMaybe<Scalars['Int']>;
  pngCompressionSpeed?: InputMaybe<Scalars['Int']>;
  pngQuality: InputMaybe<Scalars['Int']>;
  quality: InputMaybe<Scalars['Int']>;
  rotate?: InputMaybe<Scalars['Int']>;
  toFormat?: InputMaybe<ImageFormat>;
  toFormatBase64?: InputMaybe<ImageFormat>;
  traceSVG: InputMaybe<Potrace>;
  trim?: InputMaybe<Scalars['Float']>;
  webpQuality: InputMaybe<Scalars['Int']>;
  width: InputMaybe<Scalars['Int']>;
};


type ImageSharp_fluidArgs = {
  background?: InputMaybe<Scalars['String']>;
  base64Width: InputMaybe<Scalars['Int']>;
  cropFocus?: InputMaybe<ImageCropFocus>;
  duotone: InputMaybe<DuotoneGradient>;
  fit?: InputMaybe<ImageFit>;
  grayscale?: InputMaybe<Scalars['Boolean']>;
  jpegProgressive?: InputMaybe<Scalars['Boolean']>;
  jpegQuality: InputMaybe<Scalars['Int']>;
  maxHeight: InputMaybe<Scalars['Int']>;
  maxWidth: InputMaybe<Scalars['Int']>;
  pngCompressionSpeed?: InputMaybe<Scalars['Int']>;
  pngQuality: InputMaybe<Scalars['Int']>;
  quality: InputMaybe<Scalars['Int']>;
  rotate?: InputMaybe<Scalars['Int']>;
  sizes?: InputMaybe<Scalars['String']>;
  srcSetBreakpoints?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Int']>>>;
  toFormat?: InputMaybe<ImageFormat>;
  toFormatBase64?: InputMaybe<ImageFormat>;
  traceSVG: InputMaybe<Potrace>;
  trim?: InputMaybe<Scalars['Float']>;
  webpQuality: InputMaybe<Scalars['Int']>;
};


type ImageSharp_gatsbyImageDataArgs = {
  aspectRatio: InputMaybe<Scalars['Float']>;
  avifOptions: InputMaybe<AVIFOptions>;
  backgroundColor: InputMaybe<Scalars['String']>;
  blurredOptions: InputMaybe<BlurredOptions>;
  breakpoints: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Int']>>>;
  formats: InputMaybe<ReadonlyArray<InputMaybe<ImageFormat>>>;
  height: InputMaybe<Scalars['Int']>;
  jpgOptions: InputMaybe<JPGOptions>;
  layout?: InputMaybe<ImageLayout>;
  outputPixelDensities: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Float']>>>;
  placeholder: InputMaybe<ImagePlaceholder>;
  pngOptions: InputMaybe<PNGOptions>;
  quality: InputMaybe<Scalars['Int']>;
  sizes: InputMaybe<Scalars['String']>;
  tracedSVGOptions: InputMaybe<Potrace>;
  transformOptions: InputMaybe<TransformOptions>;
  webpOptions: InputMaybe<WebPOptions>;
  width: InputMaybe<Scalars['Int']>;
};


type ImageSharp_resizeArgs = {
  background?: InputMaybe<Scalars['String']>;
  base64?: InputMaybe<Scalars['Boolean']>;
  cropFocus?: InputMaybe<ImageCropFocus>;
  duotone: InputMaybe<DuotoneGradient>;
  fit?: InputMaybe<ImageFit>;
  grayscale?: InputMaybe<Scalars['Boolean']>;
  height: InputMaybe<Scalars['Int']>;
  jpegProgressive?: InputMaybe<Scalars['Boolean']>;
  jpegQuality: InputMaybe<Scalars['Int']>;
  pngCompressionLevel?: InputMaybe<Scalars['Int']>;
  pngCompressionSpeed?: InputMaybe<Scalars['Int']>;
  pngQuality: InputMaybe<Scalars['Int']>;
  quality: InputMaybe<Scalars['Int']>;
  rotate?: InputMaybe<Scalars['Int']>;
  toFormat?: InputMaybe<ImageFormat>;
  traceSVG: InputMaybe<Potrace>;
  trim?: InputMaybe<Scalars['Float']>;
  webpQuality: InputMaybe<Scalars['Int']>;
  width: InputMaybe<Scalars['Int']>;
};

type ImageSharpConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<ImageSharpEdge>;
  readonly group: ReadonlyArray<ImageSharpGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<ImageSharp>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type ImageSharpConnection_distinctArgs = {
  field: ImageSharpFieldSelector;
};


type ImageSharpConnection_groupArgs = {
  field: ImageSharpFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type ImageSharpConnection_maxArgs = {
  field: ImageSharpFieldSelector;
};


type ImageSharpConnection_minArgs = {
  field: ImageSharpFieldSelector;
};


type ImageSharpConnection_sumArgs = {
  field: ImageSharpFieldSelector;
};

type ImageSharpEdge = {
  readonly next: Maybe<ImageSharp>;
  readonly node: ImageSharp;
  readonly previous: Maybe<ImageSharp>;
};

type ImageSharpFieldSelector = {
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly fixed: InputMaybe<ImageSharpFixedFieldSelector>;
  readonly fluid: InputMaybe<ImageSharpFluidFieldSelector>;
  readonly gatsbyImageData: InputMaybe<FieldSelectorEnum>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly original: InputMaybe<ImageSharpOriginalFieldSelector>;
  readonly parent: InputMaybe<NodeFieldSelector>;
  readonly resize: InputMaybe<ImageSharpResizeFieldSelector>;
};

type ImageSharpFilterInput = {
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly fixed: InputMaybe<ImageSharpFixedFilterInput>;
  readonly fluid: InputMaybe<ImageSharpFluidFilterInput>;
  readonly gatsbyImageData: InputMaybe<GatsbyImageDataQueryOperatorInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly original: InputMaybe<ImageSharpOriginalFilterInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
  readonly resize: InputMaybe<ImageSharpResizeFilterInput>;
};

type ImageSharpFilterListInput = {
  readonly elemMatch: InputMaybe<ImageSharpFilterInput>;
};

type ImageSharpFixed = {
  readonly aspectRatio: Maybe<Scalars['Float']>;
  readonly base64: Maybe<Scalars['String']>;
  readonly height: Scalars['Float'];
  readonly originalName: Maybe<Scalars['String']>;
  readonly src: Scalars['String'];
  readonly srcSet: Scalars['String'];
  readonly srcSetWebp: Maybe<Scalars['String']>;
  readonly srcWebp: Maybe<Scalars['String']>;
  readonly tracedSVG: Maybe<Scalars['String']>;
  readonly width: Scalars['Float'];
};

type ImageSharpFixedFieldSelector = {
  readonly aspectRatio: InputMaybe<FieldSelectorEnum>;
  readonly base64: InputMaybe<FieldSelectorEnum>;
  readonly height: InputMaybe<FieldSelectorEnum>;
  readonly originalName: InputMaybe<FieldSelectorEnum>;
  readonly src: InputMaybe<FieldSelectorEnum>;
  readonly srcSet: InputMaybe<FieldSelectorEnum>;
  readonly srcSetWebp: InputMaybe<FieldSelectorEnum>;
  readonly srcWebp: InputMaybe<FieldSelectorEnum>;
  readonly tracedSVG: InputMaybe<FieldSelectorEnum>;
  readonly width: InputMaybe<FieldSelectorEnum>;
};

type ImageSharpFixedFilterInput = {
  readonly aspectRatio: InputMaybe<FloatQueryOperatorInput>;
  readonly base64: InputMaybe<StringQueryOperatorInput>;
  readonly height: InputMaybe<FloatQueryOperatorInput>;
  readonly originalName: InputMaybe<StringQueryOperatorInput>;
  readonly src: InputMaybe<StringQueryOperatorInput>;
  readonly srcSet: InputMaybe<StringQueryOperatorInput>;
  readonly srcSetWebp: InputMaybe<StringQueryOperatorInput>;
  readonly srcWebp: InputMaybe<StringQueryOperatorInput>;
  readonly tracedSVG: InputMaybe<StringQueryOperatorInput>;
  readonly width: InputMaybe<FloatQueryOperatorInput>;
};

type ImageSharpFixedSortInput = {
  readonly aspectRatio: InputMaybe<SortOrderEnum>;
  readonly base64: InputMaybe<SortOrderEnum>;
  readonly height: InputMaybe<SortOrderEnum>;
  readonly originalName: InputMaybe<SortOrderEnum>;
  readonly src: InputMaybe<SortOrderEnum>;
  readonly srcSet: InputMaybe<SortOrderEnum>;
  readonly srcSetWebp: InputMaybe<SortOrderEnum>;
  readonly srcWebp: InputMaybe<SortOrderEnum>;
  readonly tracedSVG: InputMaybe<SortOrderEnum>;
  readonly width: InputMaybe<SortOrderEnum>;
};

type ImageSharpFluid = {
  readonly aspectRatio: Scalars['Float'];
  readonly base64: Maybe<Scalars['String']>;
  readonly originalImg: Maybe<Scalars['String']>;
  readonly originalName: Maybe<Scalars['String']>;
  readonly presentationHeight: Scalars['Int'];
  readonly presentationWidth: Scalars['Int'];
  readonly sizes: Scalars['String'];
  readonly src: Scalars['String'];
  readonly srcSet: Scalars['String'];
  readonly srcSetWebp: Maybe<Scalars['String']>;
  readonly srcWebp: Maybe<Scalars['String']>;
  readonly tracedSVG: Maybe<Scalars['String']>;
};

type ImageSharpFluidFieldSelector = {
  readonly aspectRatio: InputMaybe<FieldSelectorEnum>;
  readonly base64: InputMaybe<FieldSelectorEnum>;
  readonly originalImg: InputMaybe<FieldSelectorEnum>;
  readonly originalName: InputMaybe<FieldSelectorEnum>;
  readonly presentationHeight: InputMaybe<FieldSelectorEnum>;
  readonly presentationWidth: InputMaybe<FieldSelectorEnum>;
  readonly sizes: InputMaybe<FieldSelectorEnum>;
  readonly src: InputMaybe<FieldSelectorEnum>;
  readonly srcSet: InputMaybe<FieldSelectorEnum>;
  readonly srcSetWebp: InputMaybe<FieldSelectorEnum>;
  readonly srcWebp: InputMaybe<FieldSelectorEnum>;
  readonly tracedSVG: InputMaybe<FieldSelectorEnum>;
};

type ImageSharpFluidFilterInput = {
  readonly aspectRatio: InputMaybe<FloatQueryOperatorInput>;
  readonly base64: InputMaybe<StringQueryOperatorInput>;
  readonly originalImg: InputMaybe<StringQueryOperatorInput>;
  readonly originalName: InputMaybe<StringQueryOperatorInput>;
  readonly presentationHeight: InputMaybe<IntQueryOperatorInput>;
  readonly presentationWidth: InputMaybe<IntQueryOperatorInput>;
  readonly sizes: InputMaybe<StringQueryOperatorInput>;
  readonly src: InputMaybe<StringQueryOperatorInput>;
  readonly srcSet: InputMaybe<StringQueryOperatorInput>;
  readonly srcSetWebp: InputMaybe<StringQueryOperatorInput>;
  readonly srcWebp: InputMaybe<StringQueryOperatorInput>;
  readonly tracedSVG: InputMaybe<StringQueryOperatorInput>;
};

type ImageSharpFluidSortInput = {
  readonly aspectRatio: InputMaybe<SortOrderEnum>;
  readonly base64: InputMaybe<SortOrderEnum>;
  readonly originalImg: InputMaybe<SortOrderEnum>;
  readonly originalName: InputMaybe<SortOrderEnum>;
  readonly presentationHeight: InputMaybe<SortOrderEnum>;
  readonly presentationWidth: InputMaybe<SortOrderEnum>;
  readonly sizes: InputMaybe<SortOrderEnum>;
  readonly src: InputMaybe<SortOrderEnum>;
  readonly srcSet: InputMaybe<SortOrderEnum>;
  readonly srcSetWebp: InputMaybe<SortOrderEnum>;
  readonly srcWebp: InputMaybe<SortOrderEnum>;
  readonly tracedSVG: InputMaybe<SortOrderEnum>;
};

type ImageSharpGroupConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<ImageSharpEdge>;
  readonly field: Scalars['String'];
  readonly fieldValue: Maybe<Scalars['String']>;
  readonly group: ReadonlyArray<ImageSharpGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<ImageSharp>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type ImageSharpGroupConnection_distinctArgs = {
  field: ImageSharpFieldSelector;
};


type ImageSharpGroupConnection_groupArgs = {
  field: ImageSharpFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type ImageSharpGroupConnection_maxArgs = {
  field: ImageSharpFieldSelector;
};


type ImageSharpGroupConnection_minArgs = {
  field: ImageSharpFieldSelector;
};


type ImageSharpGroupConnection_sumArgs = {
  field: ImageSharpFieldSelector;
};

type ImageSharpOriginal = {
  readonly height: Maybe<Scalars['Float']>;
  readonly src: Maybe<Scalars['String']>;
  readonly width: Maybe<Scalars['Float']>;
};

type ImageSharpOriginalFieldSelector = {
  readonly height: InputMaybe<FieldSelectorEnum>;
  readonly src: InputMaybe<FieldSelectorEnum>;
  readonly width: InputMaybe<FieldSelectorEnum>;
};

type ImageSharpOriginalFilterInput = {
  readonly height: InputMaybe<FloatQueryOperatorInput>;
  readonly src: InputMaybe<StringQueryOperatorInput>;
  readonly width: InputMaybe<FloatQueryOperatorInput>;
};

type ImageSharpOriginalSortInput = {
  readonly height: InputMaybe<SortOrderEnum>;
  readonly src: InputMaybe<SortOrderEnum>;
  readonly width: InputMaybe<SortOrderEnum>;
};

type ImageSharpResize = {
  readonly aspectRatio: Maybe<Scalars['Float']>;
  readonly height: Maybe<Scalars['Int']>;
  readonly originalName: Maybe<Scalars['String']>;
  readonly src: Maybe<Scalars['String']>;
  readonly tracedSVG: Maybe<Scalars['String']>;
  readonly width: Maybe<Scalars['Int']>;
};

type ImageSharpResizeFieldSelector = {
  readonly aspectRatio: InputMaybe<FieldSelectorEnum>;
  readonly height: InputMaybe<FieldSelectorEnum>;
  readonly originalName: InputMaybe<FieldSelectorEnum>;
  readonly src: InputMaybe<FieldSelectorEnum>;
  readonly tracedSVG: InputMaybe<FieldSelectorEnum>;
  readonly width: InputMaybe<FieldSelectorEnum>;
};

type ImageSharpResizeFilterInput = {
  readonly aspectRatio: InputMaybe<FloatQueryOperatorInput>;
  readonly height: InputMaybe<IntQueryOperatorInput>;
  readonly originalName: InputMaybe<StringQueryOperatorInput>;
  readonly src: InputMaybe<StringQueryOperatorInput>;
  readonly tracedSVG: InputMaybe<StringQueryOperatorInput>;
  readonly width: InputMaybe<IntQueryOperatorInput>;
};

type ImageSharpResizeSortInput = {
  readonly aspectRatio: InputMaybe<SortOrderEnum>;
  readonly height: InputMaybe<SortOrderEnum>;
  readonly originalName: InputMaybe<SortOrderEnum>;
  readonly src: InputMaybe<SortOrderEnum>;
  readonly tracedSVG: InputMaybe<SortOrderEnum>;
  readonly width: InputMaybe<SortOrderEnum>;
};

type ImageSharpSortInput = {
  readonly children: InputMaybe<NodeSortInput>;
  readonly fixed: InputMaybe<ImageSharpFixedSortInput>;
  readonly fluid: InputMaybe<ImageSharpFluidSortInput>;
  readonly gatsbyImageData: InputMaybe<SortOrderEnum>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly original: InputMaybe<ImageSharpOriginalSortInput>;
  readonly parent: InputMaybe<NodeSortInput>;
  readonly resize: InputMaybe<ImageSharpResizeSortInput>;
};

type IntQueryOperatorInput = {
  readonly eq: InputMaybe<Scalars['Int']>;
  readonly gt: InputMaybe<Scalars['Int']>;
  readonly gte: InputMaybe<Scalars['Int']>;
  readonly in: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Int']>>>;
  readonly lt: InputMaybe<Scalars['Int']>;
  readonly lte: InputMaybe<Scalars['Int']>;
  readonly ne: InputMaybe<Scalars['Int']>;
  readonly nin: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Int']>>>;
};

type Internal = {
  readonly content: Maybe<Scalars['String']>;
  readonly contentDigest: Scalars['String'];
  readonly contentFilePath: Maybe<Scalars['String']>;
  readonly description: Maybe<Scalars['String']>;
  readonly fieldOwners: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly ignoreType: Maybe<Scalars['Boolean']>;
  readonly mediaType: Maybe<Scalars['String']>;
  readonly owner: Scalars['String'];
  readonly type: Scalars['String'];
};

type InternalFieldSelector = {
  readonly content: InputMaybe<FieldSelectorEnum>;
  readonly contentDigest: InputMaybe<FieldSelectorEnum>;
  readonly contentFilePath: InputMaybe<FieldSelectorEnum>;
  readonly description: InputMaybe<FieldSelectorEnum>;
  readonly fieldOwners: InputMaybe<FieldSelectorEnum>;
  readonly ignoreType: InputMaybe<FieldSelectorEnum>;
  readonly mediaType: InputMaybe<FieldSelectorEnum>;
  readonly owner: InputMaybe<FieldSelectorEnum>;
  readonly type: InputMaybe<FieldSelectorEnum>;
};

type InternalFilterInput = {
  readonly content: InputMaybe<StringQueryOperatorInput>;
  readonly contentDigest: InputMaybe<StringQueryOperatorInput>;
  readonly contentFilePath: InputMaybe<StringQueryOperatorInput>;
  readonly description: InputMaybe<StringQueryOperatorInput>;
  readonly fieldOwners: InputMaybe<StringQueryOperatorInput>;
  readonly ignoreType: InputMaybe<BooleanQueryOperatorInput>;
  readonly mediaType: InputMaybe<StringQueryOperatorInput>;
  readonly owner: InputMaybe<StringQueryOperatorInput>;
  readonly type: InputMaybe<StringQueryOperatorInput>;
};

type InternalSortInput = {
  readonly content: InputMaybe<SortOrderEnum>;
  readonly contentDigest: InputMaybe<SortOrderEnum>;
  readonly contentFilePath: InputMaybe<SortOrderEnum>;
  readonly description: InputMaybe<SortOrderEnum>;
  readonly fieldOwners: InputMaybe<SortOrderEnum>;
  readonly ignoreType: InputMaybe<SortOrderEnum>;
  readonly mediaType: InputMaybe<SortOrderEnum>;
  readonly owner: InputMaybe<SortOrderEnum>;
  readonly type: InputMaybe<SortOrderEnum>;
};

type JPGOptions = {
  readonly progressive: InputMaybe<Scalars['Boolean']>;
  readonly quality: InputMaybe<Scalars['Int']>;
};

type JSONQueryOperatorInput = {
  readonly eq: InputMaybe<Scalars['JSON']>;
  readonly glob: InputMaybe<Scalars['JSON']>;
  readonly in: InputMaybe<ReadonlyArray<InputMaybe<Scalars['JSON']>>>;
  readonly ne: InputMaybe<Scalars['JSON']>;
  readonly nin: InputMaybe<ReadonlyArray<InputMaybe<Scalars['JSON']>>>;
  readonly regex: InputMaybe<Scalars['JSON']>;
};

type MarkdownExcerptFormats =
  | 'HTML'
  | 'MARKDOWN'
  | 'PLAIN';

type MarkdownHeading = {
  readonly depth: Maybe<Scalars['Int']>;
  readonly id: Maybe<Scalars['String']>;
  readonly value: Maybe<Scalars['String']>;
};

type MarkdownHeadingFieldSelector = {
  readonly depth: InputMaybe<FieldSelectorEnum>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly value: InputMaybe<FieldSelectorEnum>;
};

type MarkdownHeadingFilterInput = {
  readonly depth: InputMaybe<IntQueryOperatorInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly value: InputMaybe<StringQueryOperatorInput>;
};

type MarkdownHeadingFilterListInput = {
  readonly elemMatch: InputMaybe<MarkdownHeadingFilterInput>;
};

type MarkdownHeadingLevels =
  | 'h1'
  | 'h2'
  | 'h3'
  | 'h4'
  | 'h5'
  | 'h6';

type MarkdownHeadingSortInput = {
  readonly depth: InputMaybe<SortOrderEnum>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly value: InputMaybe<SortOrderEnum>;
};

type MarkdownRemark = Node & {
  readonly children: ReadonlyArray<Node>;
  readonly excerpt: Maybe<Scalars['String']>;
  readonly excerptAst: Maybe<Scalars['JSON']>;
  readonly headings: Maybe<ReadonlyArray<Maybe<MarkdownHeading>>>;
  readonly html: Maybe<Scalars['String']>;
  readonly htmlAst: Maybe<Scalars['JSON']>;
  readonly id: Scalars['ID'];
  readonly internal: Internal;
  readonly parent: Maybe<Node>;
  readonly tableOfContents: Maybe<Scalars['String']>;
  readonly timeToRead: Maybe<Scalars['Int']>;
  readonly wordCount: Maybe<MarkdownWordCount>;
};


type MarkdownRemark_excerptArgs = {
  format?: InputMaybe<MarkdownExcerptFormats>;
  pruneLength?: InputMaybe<Scalars['Int']>;
  truncate?: InputMaybe<Scalars['Boolean']>;
};


type MarkdownRemark_excerptAstArgs = {
  pruneLength?: InputMaybe<Scalars['Int']>;
  truncate?: InputMaybe<Scalars['Boolean']>;
};


type MarkdownRemark_headingsArgs = {
  depth: InputMaybe<MarkdownHeadingLevels>;
};


type MarkdownRemark_tableOfContentsArgs = {
  absolute?: InputMaybe<Scalars['Boolean']>;
  heading: InputMaybe<Scalars['String']>;
  maxDepth: InputMaybe<Scalars['Int']>;
  pathToSlugField?: InputMaybe<Scalars['String']>;
};

type MarkdownRemarkConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<MarkdownRemarkEdge>;
  readonly group: ReadonlyArray<MarkdownRemarkGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<MarkdownRemark>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type MarkdownRemarkConnection_distinctArgs = {
  field: MarkdownRemarkFieldSelector;
};


type MarkdownRemarkConnection_groupArgs = {
  field: MarkdownRemarkFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type MarkdownRemarkConnection_maxArgs = {
  field: MarkdownRemarkFieldSelector;
};


type MarkdownRemarkConnection_minArgs = {
  field: MarkdownRemarkFieldSelector;
};


type MarkdownRemarkConnection_sumArgs = {
  field: MarkdownRemarkFieldSelector;
};

type MarkdownRemarkEdge = {
  readonly next: Maybe<MarkdownRemark>;
  readonly node: MarkdownRemark;
  readonly previous: Maybe<MarkdownRemark>;
};

type MarkdownRemarkFieldSelector = {
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly excerpt: InputMaybe<FieldSelectorEnum>;
  readonly excerptAst: InputMaybe<FieldSelectorEnum>;
  readonly headings: InputMaybe<MarkdownHeadingFieldSelector>;
  readonly html: InputMaybe<FieldSelectorEnum>;
  readonly htmlAst: InputMaybe<FieldSelectorEnum>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly parent: InputMaybe<NodeFieldSelector>;
  readonly tableOfContents: InputMaybe<FieldSelectorEnum>;
  readonly timeToRead: InputMaybe<FieldSelectorEnum>;
  readonly wordCount: InputMaybe<MarkdownWordCountFieldSelector>;
};

type MarkdownRemarkFilterInput = {
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly excerpt: InputMaybe<StringQueryOperatorInput>;
  readonly excerptAst: InputMaybe<JSONQueryOperatorInput>;
  readonly headings: InputMaybe<MarkdownHeadingFilterListInput>;
  readonly html: InputMaybe<StringQueryOperatorInput>;
  readonly htmlAst: InputMaybe<JSONQueryOperatorInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
  readonly tableOfContents: InputMaybe<StringQueryOperatorInput>;
  readonly timeToRead: InputMaybe<IntQueryOperatorInput>;
  readonly wordCount: InputMaybe<MarkdownWordCountFilterInput>;
};

type MarkdownRemarkGroupConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<MarkdownRemarkEdge>;
  readonly field: Scalars['String'];
  readonly fieldValue: Maybe<Scalars['String']>;
  readonly group: ReadonlyArray<MarkdownRemarkGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<MarkdownRemark>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type MarkdownRemarkGroupConnection_distinctArgs = {
  field: MarkdownRemarkFieldSelector;
};


type MarkdownRemarkGroupConnection_groupArgs = {
  field: MarkdownRemarkFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type MarkdownRemarkGroupConnection_maxArgs = {
  field: MarkdownRemarkFieldSelector;
};


type MarkdownRemarkGroupConnection_minArgs = {
  field: MarkdownRemarkFieldSelector;
};


type MarkdownRemarkGroupConnection_sumArgs = {
  field: MarkdownRemarkFieldSelector;
};

type MarkdownRemarkSortInput = {
  readonly children: InputMaybe<NodeSortInput>;
  readonly excerpt: InputMaybe<SortOrderEnum>;
  readonly excerptAst: InputMaybe<SortOrderEnum>;
  readonly headings: InputMaybe<MarkdownHeadingSortInput>;
  readonly html: InputMaybe<SortOrderEnum>;
  readonly htmlAst: InputMaybe<SortOrderEnum>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly parent: InputMaybe<NodeSortInput>;
  readonly tableOfContents: InputMaybe<SortOrderEnum>;
  readonly timeToRead: InputMaybe<SortOrderEnum>;
  readonly wordCount: InputMaybe<MarkdownWordCountSortInput>;
};

type MarkdownWordCount = {
  readonly paragraphs: Maybe<Scalars['Int']>;
  readonly sentences: Maybe<Scalars['Int']>;
  readonly words: Maybe<Scalars['Int']>;
};

type MarkdownWordCountFieldSelector = {
  readonly paragraphs: InputMaybe<FieldSelectorEnum>;
  readonly sentences: InputMaybe<FieldSelectorEnum>;
  readonly words: InputMaybe<FieldSelectorEnum>;
};

type MarkdownWordCountFilterInput = {
  readonly paragraphs: InputMaybe<IntQueryOperatorInput>;
  readonly sentences: InputMaybe<IntQueryOperatorInput>;
  readonly words: InputMaybe<IntQueryOperatorInput>;
};

type MarkdownWordCountSortInput = {
  readonly paragraphs: InputMaybe<SortOrderEnum>;
  readonly sentences: InputMaybe<SortOrderEnum>;
  readonly words: InputMaybe<SortOrderEnum>;
};

/** Node Interface */
type Node = {
  readonly children: ReadonlyArray<Node>;
  readonly id: Scalars['ID'];
  readonly internal: Internal;
  readonly parent: Maybe<Node>;
};

type NodeFieldSelector = {
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly parent: InputMaybe<NodeFieldSelector>;
};

type NodeFilterInput = {
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
};

type NodeFilterListInput = {
  readonly elemMatch: InputMaybe<NodeFilterInput>;
};

type NodeSortInput = {
  readonly children: InputMaybe<NodeSortInput>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly parent: InputMaybe<NodeSortInput>;
};

type PNGOptions = {
  readonly compressionSpeed: InputMaybe<Scalars['Int']>;
  readonly quality: InputMaybe<Scalars['Int']>;
};

type PageInfo = {
  readonly currentPage: Scalars['Int'];
  readonly hasNextPage: Scalars['Boolean'];
  readonly hasPreviousPage: Scalars['Boolean'];
  readonly itemCount: Scalars['Int'];
  readonly pageCount: Scalars['Int'];
  readonly perPage: Maybe<Scalars['Int']>;
  readonly totalCount: Scalars['Int'];
};

type Potrace = {
  readonly alphaMax: InputMaybe<Scalars['Float']>;
  readonly background: InputMaybe<Scalars['String']>;
  readonly blackOnWhite: InputMaybe<Scalars['Boolean']>;
  readonly color: InputMaybe<Scalars['String']>;
  readonly optCurve: InputMaybe<Scalars['Boolean']>;
  readonly optTolerance: InputMaybe<Scalars['Float']>;
  readonly threshold: InputMaybe<Scalars['Int']>;
  readonly turdSize: InputMaybe<Scalars['Float']>;
  readonly turnPolicy: InputMaybe<PotraceTurnPolicy>;
};

type PotraceTurnPolicy =
  | 'black'
  | 'left'
  | 'majority'
  | 'minority'
  | 'right'
  | 'white';

type Query = {
  readonly allDataJson: DataJsonConnection;
  readonly allDirectory: DirectoryConnection;
  readonly allFile: FileConnection;
  readonly allImageMetadataJson: ImageMetadataJsonConnection;
  readonly allImageSharp: ImageSharpConnection;
  readonly allMarkdownRemark: MarkdownRemarkConnection;
  readonly allSanityFileAsset: SanityFileAssetConnection;
  readonly allSanityImageAsset: SanityImageAssetConnection;
  readonly allSanityMediaTag: SanityMediaTagConnection;
  readonly allSanityPost: SanityPostConnection;
  readonly allSite: SiteConnection;
  readonly allSiteBuildMetadata: SiteBuildMetadataConnection;
  readonly allSiteFunction: SiteFunctionConnection;
  readonly allSitePage: SitePageConnection;
  readonly allSitePlugin: SitePluginConnection;
  readonly dataJson: Maybe<DataJson>;
  readonly directory: Maybe<Directory>;
  readonly file: Maybe<File>;
  readonly imageMetadataJson: Maybe<ImageMetadataJson>;
  readonly imageSharp: Maybe<ImageSharp>;
  readonly markdownRemark: Maybe<MarkdownRemark>;
  readonly sanityFileAsset: Maybe<SanityFileAsset>;
  readonly sanityImageAsset: Maybe<SanityImageAsset>;
  readonly sanityMediaTag: Maybe<SanityMediaTag>;
  readonly sanityPost: Maybe<SanityPost>;
  readonly site: Maybe<Site>;
  readonly siteBuildMetadata: Maybe<SiteBuildMetadata>;
  readonly siteFunction: Maybe<SiteFunction>;
  readonly sitePage: Maybe<SitePage>;
  readonly sitePlugin: Maybe<SitePlugin>;
};


type Query_allDataJsonArgs = {
  filter: InputMaybe<DataJsonFilterInput>;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
  sort: InputMaybe<ReadonlyArray<InputMaybe<DataJsonSortInput>>>;
};


type Query_allDirectoryArgs = {
  filter: InputMaybe<DirectoryFilterInput>;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
  sort: InputMaybe<ReadonlyArray<InputMaybe<DirectorySortInput>>>;
};


type Query_allFileArgs = {
  filter: InputMaybe<FileFilterInput>;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
  sort: InputMaybe<ReadonlyArray<InputMaybe<FileSortInput>>>;
};


type Query_allImageMetadataJsonArgs = {
  filter: InputMaybe<ImageMetadataJsonFilterInput>;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
  sort: InputMaybe<ReadonlyArray<InputMaybe<ImageMetadataJsonSortInput>>>;
};


type Query_allImageSharpArgs = {
  filter: InputMaybe<ImageSharpFilterInput>;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
  sort: InputMaybe<ReadonlyArray<InputMaybe<ImageSharpSortInput>>>;
};


type Query_allMarkdownRemarkArgs = {
  filter: InputMaybe<MarkdownRemarkFilterInput>;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
  sort: InputMaybe<ReadonlyArray<InputMaybe<MarkdownRemarkSortInput>>>;
};


type Query_allSanityFileAssetArgs = {
  filter: InputMaybe<SanityFileAssetFilterInput>;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
  sort: InputMaybe<ReadonlyArray<InputMaybe<SanityFileAssetSortInput>>>;
};


type Query_allSanityImageAssetArgs = {
  filter: InputMaybe<SanityImageAssetFilterInput>;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
  sort: InputMaybe<ReadonlyArray<InputMaybe<SanityImageAssetSortInput>>>;
};


type Query_allSanityMediaTagArgs = {
  filter: InputMaybe<SanityMediaTagFilterInput>;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
  sort: InputMaybe<ReadonlyArray<InputMaybe<SanityMediaTagSortInput>>>;
};


type Query_allSanityPostArgs = {
  filter: InputMaybe<SanityPostFilterInput>;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
  sort: InputMaybe<ReadonlyArray<InputMaybe<SanityPostSortInput>>>;
};


type Query_allSiteArgs = {
  filter: InputMaybe<SiteFilterInput>;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
  sort: InputMaybe<ReadonlyArray<InputMaybe<SiteSortInput>>>;
};


type Query_allSiteBuildMetadataArgs = {
  filter: InputMaybe<SiteBuildMetadataFilterInput>;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
  sort: InputMaybe<ReadonlyArray<InputMaybe<SiteBuildMetadataSortInput>>>;
};


type Query_allSiteFunctionArgs = {
  filter: InputMaybe<SiteFunctionFilterInput>;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
  sort: InputMaybe<ReadonlyArray<InputMaybe<SiteFunctionSortInput>>>;
};


type Query_allSitePageArgs = {
  filter: InputMaybe<SitePageFilterInput>;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
  sort: InputMaybe<ReadonlyArray<InputMaybe<SitePageSortInput>>>;
};


type Query_allSitePluginArgs = {
  filter: InputMaybe<SitePluginFilterInput>;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
  sort: InputMaybe<ReadonlyArray<InputMaybe<SitePluginSortInput>>>;
};


type Query_dataJsonArgs = {
  IBAN: InputMaybe<DataJsonIBANFilterInput>;
  children: InputMaybe<NodeFilterListInput>;
  email: InputMaybe<StringQueryOperatorInput>;
  facebook_laghetti: InputMaybe<StringQueryOperatorInput>;
  facebook_narcisi: InputMaybe<StringQueryOperatorInput>;
  id: InputMaybe<StringQueryOperatorInput>;
  internal: InputMaybe<InternalFilterInput>;
  parent: InputMaybe<NodeFilterInput>;
  phone: InputMaybe<StringQueryOperatorInput>;
  youtube: InputMaybe<StringQueryOperatorInput>;
};


type Query_directoryArgs = {
  absolutePath: InputMaybe<StringQueryOperatorInput>;
  accessTime: InputMaybe<DateQueryOperatorInput>;
  atime: InputMaybe<DateQueryOperatorInput>;
  atimeMs: InputMaybe<FloatQueryOperatorInput>;
  base: InputMaybe<StringQueryOperatorInput>;
  birthTime: InputMaybe<DateQueryOperatorInput>;
  birthtime: InputMaybe<DateQueryOperatorInput>;
  birthtimeMs: InputMaybe<FloatQueryOperatorInput>;
  changeTime: InputMaybe<DateQueryOperatorInput>;
  children: InputMaybe<NodeFilterListInput>;
  ctime: InputMaybe<DateQueryOperatorInput>;
  ctimeMs: InputMaybe<FloatQueryOperatorInput>;
  dev: InputMaybe<IntQueryOperatorInput>;
  dir: InputMaybe<StringQueryOperatorInput>;
  ext: InputMaybe<StringQueryOperatorInput>;
  extension: InputMaybe<StringQueryOperatorInput>;
  gid: InputMaybe<IntQueryOperatorInput>;
  id: InputMaybe<StringQueryOperatorInput>;
  ino: InputMaybe<FloatQueryOperatorInput>;
  internal: InputMaybe<InternalFilterInput>;
  mode: InputMaybe<IntQueryOperatorInput>;
  modifiedTime: InputMaybe<DateQueryOperatorInput>;
  mtime: InputMaybe<DateQueryOperatorInput>;
  mtimeMs: InputMaybe<FloatQueryOperatorInput>;
  name: InputMaybe<StringQueryOperatorInput>;
  nlink: InputMaybe<IntQueryOperatorInput>;
  parent: InputMaybe<NodeFilterInput>;
  prettySize: InputMaybe<StringQueryOperatorInput>;
  rdev: InputMaybe<IntQueryOperatorInput>;
  relativeDirectory: InputMaybe<StringQueryOperatorInput>;
  relativePath: InputMaybe<StringQueryOperatorInput>;
  root: InputMaybe<StringQueryOperatorInput>;
  size: InputMaybe<IntQueryOperatorInput>;
  sourceInstanceName: InputMaybe<StringQueryOperatorInput>;
  uid: InputMaybe<IntQueryOperatorInput>;
};


type Query_fileArgs = {
  absolutePath: InputMaybe<StringQueryOperatorInput>;
  accessTime: InputMaybe<DateQueryOperatorInput>;
  atime: InputMaybe<DateQueryOperatorInput>;
  atimeMs: InputMaybe<FloatQueryOperatorInput>;
  base: InputMaybe<StringQueryOperatorInput>;
  birthTime: InputMaybe<DateQueryOperatorInput>;
  birthtime: InputMaybe<DateQueryOperatorInput>;
  birthtimeMs: InputMaybe<FloatQueryOperatorInput>;
  blksize: InputMaybe<IntQueryOperatorInput>;
  blocks: InputMaybe<IntQueryOperatorInput>;
  changeTime: InputMaybe<DateQueryOperatorInput>;
  childDataJson: InputMaybe<DataJsonFilterInput>;
  childImageMetadataJson: InputMaybe<ImageMetadataJsonFilterInput>;
  childImageSharp: InputMaybe<ImageSharpFilterInput>;
  children: InputMaybe<NodeFilterListInput>;
  childrenDataJson: InputMaybe<DataJsonFilterListInput>;
  childrenImageMetadataJson: InputMaybe<ImageMetadataJsonFilterListInput>;
  childrenImageSharp: InputMaybe<ImageSharpFilterListInput>;
  ctime: InputMaybe<DateQueryOperatorInput>;
  ctimeMs: InputMaybe<FloatQueryOperatorInput>;
  dev: InputMaybe<IntQueryOperatorInput>;
  dir: InputMaybe<StringQueryOperatorInput>;
  ext: InputMaybe<StringQueryOperatorInput>;
  extension: InputMaybe<StringQueryOperatorInput>;
  gid: InputMaybe<IntQueryOperatorInput>;
  id: InputMaybe<StringQueryOperatorInput>;
  ino: InputMaybe<FloatQueryOperatorInput>;
  internal: InputMaybe<InternalFilterInput>;
  mode: InputMaybe<IntQueryOperatorInput>;
  modifiedTime: InputMaybe<DateQueryOperatorInput>;
  mtime: InputMaybe<DateQueryOperatorInput>;
  mtimeMs: InputMaybe<FloatQueryOperatorInput>;
  name: InputMaybe<StringQueryOperatorInput>;
  nlink: InputMaybe<IntQueryOperatorInput>;
  parent: InputMaybe<NodeFilterInput>;
  prettySize: InputMaybe<StringQueryOperatorInput>;
  publicURL: InputMaybe<StringQueryOperatorInput>;
  rdev: InputMaybe<IntQueryOperatorInput>;
  relativeDirectory: InputMaybe<StringQueryOperatorInput>;
  relativePath: InputMaybe<StringQueryOperatorInput>;
  root: InputMaybe<StringQueryOperatorInput>;
  size: InputMaybe<IntQueryOperatorInput>;
  sourceInstanceName: InputMaybe<StringQueryOperatorInput>;
  uid: InputMaybe<IntQueryOperatorInput>;
};


type Query_imageMetadataJsonArgs = {
  alt: InputMaybe<StringQueryOperatorInput>;
  children: InputMaybe<NodeFilterListInput>;
  copyright: InputMaybe<StringQueryOperatorInput>;
  description: InputMaybe<StringQueryOperatorInput>;
  fileName: InputMaybe<StringQueryOperatorInput>;
  id: InputMaybe<StringQueryOperatorInput>;
  internal: InputMaybe<InternalFilterInput>;
  parent: InputMaybe<NodeFilterInput>;
  tags: InputMaybe<StringQueryOperatorInput>;
  title: InputMaybe<StringQueryOperatorInput>;
};


type Query_imageSharpArgs = {
  children: InputMaybe<NodeFilterListInput>;
  fixed: InputMaybe<ImageSharpFixedFilterInput>;
  fluid: InputMaybe<ImageSharpFluidFilterInput>;
  gatsbyImageData: InputMaybe<GatsbyImageDataQueryOperatorInput>;
  id: InputMaybe<StringQueryOperatorInput>;
  internal: InputMaybe<InternalFilterInput>;
  original: InputMaybe<ImageSharpOriginalFilterInput>;
  parent: InputMaybe<NodeFilterInput>;
  resize: InputMaybe<ImageSharpResizeFilterInput>;
};


type Query_markdownRemarkArgs = {
  children: InputMaybe<NodeFilterListInput>;
  excerpt: InputMaybe<StringQueryOperatorInput>;
  excerptAst: InputMaybe<JSONQueryOperatorInput>;
  headings: InputMaybe<MarkdownHeadingFilterListInput>;
  html: InputMaybe<StringQueryOperatorInput>;
  htmlAst: InputMaybe<JSONQueryOperatorInput>;
  id: InputMaybe<StringQueryOperatorInput>;
  internal: InputMaybe<InternalFilterInput>;
  parent: InputMaybe<NodeFilterInput>;
  tableOfContents: InputMaybe<StringQueryOperatorInput>;
  timeToRead: InputMaybe<IntQueryOperatorInput>;
  wordCount: InputMaybe<MarkdownWordCountFilterInput>;
};


type Query_sanityFileAssetArgs = {
  _createdAt: InputMaybe<DateQueryOperatorInput>;
  _id: InputMaybe<StringQueryOperatorInput>;
  _key: InputMaybe<StringQueryOperatorInput>;
  _rawSource: InputMaybe<JSONQueryOperatorInput>;
  _rev: InputMaybe<StringQueryOperatorInput>;
  _type: InputMaybe<StringQueryOperatorInput>;
  _updatedAt: InputMaybe<DateQueryOperatorInput>;
  altText: InputMaybe<StringQueryOperatorInput>;
  assetId: InputMaybe<StringQueryOperatorInput>;
  children: InputMaybe<NodeFilterListInput>;
  description: InputMaybe<StringQueryOperatorInput>;
  extension: InputMaybe<StringQueryOperatorInput>;
  id: InputMaybe<StringQueryOperatorInput>;
  internal: InputMaybe<InternalFilterInput>;
  label: InputMaybe<StringQueryOperatorInput>;
  mimeType: InputMaybe<StringQueryOperatorInput>;
  originalFilename: InputMaybe<StringQueryOperatorInput>;
  parent: InputMaybe<NodeFilterInput>;
  path: InputMaybe<StringQueryOperatorInput>;
  sha1hash: InputMaybe<StringQueryOperatorInput>;
  size: InputMaybe<FloatQueryOperatorInput>;
  source: InputMaybe<SanityAssetSourceDataFilterInput>;
  title: InputMaybe<StringQueryOperatorInput>;
  uploadId: InputMaybe<StringQueryOperatorInput>;
  url: InputMaybe<StringQueryOperatorInput>;
};


type Query_sanityImageAssetArgs = {
  _createdAt: InputMaybe<DateQueryOperatorInput>;
  _id: InputMaybe<StringQueryOperatorInput>;
  _key: InputMaybe<StringQueryOperatorInput>;
  _rawMetadata: InputMaybe<JSONQueryOperatorInput>;
  _rawSource: InputMaybe<JSONQueryOperatorInput>;
  _rev: InputMaybe<StringQueryOperatorInput>;
  _type: InputMaybe<StringQueryOperatorInput>;
  _updatedAt: InputMaybe<DateQueryOperatorInput>;
  altText: InputMaybe<StringQueryOperatorInput>;
  assetId: InputMaybe<StringQueryOperatorInput>;
  children: InputMaybe<NodeFilterListInput>;
  description: InputMaybe<StringQueryOperatorInput>;
  extension: InputMaybe<StringQueryOperatorInput>;
  filename: InputMaybe<StringQueryOperatorInput>;
  filesize: InputMaybe<IntQueryOperatorInput>;
  gatsbyImage: InputMaybe<GatsbyImageDataQueryOperatorInput>;
  gatsbyImageData: InputMaybe<GatsbyImageDataQueryOperatorInput>;
  height: InputMaybe<IntQueryOperatorInput>;
  id: InputMaybe<StringQueryOperatorInput>;
  internal: InputMaybe<InternalFilterInput>;
  label: InputMaybe<StringQueryOperatorInput>;
  metadata: InputMaybe<SanityImageMetadataFilterInput>;
  mimeType: InputMaybe<StringQueryOperatorInput>;
  originalFilename: InputMaybe<StringQueryOperatorInput>;
  parent: InputMaybe<NodeFilterInput>;
  path: InputMaybe<StringQueryOperatorInput>;
  publicUrl: InputMaybe<StringQueryOperatorInput>;
  resize: InputMaybe<RemoteFileResizeFilterInput>;
  sha1hash: InputMaybe<StringQueryOperatorInput>;
  size: InputMaybe<FloatQueryOperatorInput>;
  source: InputMaybe<SanityAssetSourceDataFilterInput>;
  title: InputMaybe<StringQueryOperatorInput>;
  uploadId: InputMaybe<StringQueryOperatorInput>;
  url: InputMaybe<StringQueryOperatorInput>;
  width: InputMaybe<IntQueryOperatorInput>;
};


type Query_sanityMediaTagArgs = {
  _createdAt: InputMaybe<DateQueryOperatorInput>;
  _id: InputMaybe<StringQueryOperatorInput>;
  _key: InputMaybe<StringQueryOperatorInput>;
  _rawName: InputMaybe<JSONQueryOperatorInput>;
  _rev: InputMaybe<StringQueryOperatorInput>;
  _type: InputMaybe<StringQueryOperatorInput>;
  _updatedAt: InputMaybe<DateQueryOperatorInput>;
  children: InputMaybe<NodeFilterListInput>;
  id: InputMaybe<StringQueryOperatorInput>;
  internal: InputMaybe<InternalFilterInput>;
  name: InputMaybe<SanitySlugFilterInput>;
  parent: InputMaybe<NodeFilterInput>;
};


type Query_sanityPostArgs = {
  _createdAt: InputMaybe<DateQueryOperatorInput>;
  _id: InputMaybe<StringQueryOperatorInput>;
  _key: InputMaybe<StringQueryOperatorInput>;
  _rawBody: InputMaybe<JSONQueryOperatorInput>;
  _rawImage: InputMaybe<JSONQueryOperatorInput>;
  _rawSlug: InputMaybe<JSONQueryOperatorInput>;
  _rev: InputMaybe<StringQueryOperatorInput>;
  _type: InputMaybe<StringQueryOperatorInput>;
  _updatedAt: InputMaybe<DateQueryOperatorInput>;
  author: InputMaybe<StringQueryOperatorInput>;
  body: InputMaybe<SanityBlockFilterListInput>;
  children: InputMaybe<NodeFilterListInput>;
  id: InputMaybe<StringQueryOperatorInput>;
  image: InputMaybe<SanityImageFilterInput>;
  internal: InputMaybe<InternalFilterInput>;
  parent: InputMaybe<NodeFilterInput>;
  publishedAt: InputMaybe<DateQueryOperatorInput>;
  slug: InputMaybe<SanitySlugFilterInput>;
  title: InputMaybe<StringQueryOperatorInput>;
};


type Query_siteArgs = {
  buildTime: InputMaybe<DateQueryOperatorInput>;
  children: InputMaybe<NodeFilterListInput>;
  graphqlTypegen: InputMaybe<SiteGraphqlTypegenFilterInput>;
  host: InputMaybe<StringQueryOperatorInput>;
  id: InputMaybe<StringQueryOperatorInput>;
  internal: InputMaybe<InternalFilterInput>;
  jsxRuntime: InputMaybe<StringQueryOperatorInput>;
  parent: InputMaybe<NodeFilterInput>;
  pathPrefix: InputMaybe<StringQueryOperatorInput>;
  polyfill: InputMaybe<BooleanQueryOperatorInput>;
  port: InputMaybe<IntQueryOperatorInput>;
  siteMetadata: InputMaybe<SiteSiteMetadataFilterInput>;
  trailingSlash: InputMaybe<StringQueryOperatorInput>;
};


type Query_siteBuildMetadataArgs = {
  buildTime: InputMaybe<DateQueryOperatorInput>;
  children: InputMaybe<NodeFilterListInput>;
  id: InputMaybe<StringQueryOperatorInput>;
  internal: InputMaybe<InternalFilterInput>;
  parent: InputMaybe<NodeFilterInput>;
};


type Query_siteFunctionArgs = {
  absoluteCompiledFilePath: InputMaybe<StringQueryOperatorInput>;
  children: InputMaybe<NodeFilterListInput>;
  functionRoute: InputMaybe<StringQueryOperatorInput>;
  id: InputMaybe<StringQueryOperatorInput>;
  internal: InputMaybe<InternalFilterInput>;
  matchPath: InputMaybe<StringQueryOperatorInput>;
  originalAbsoluteFilePath: InputMaybe<StringQueryOperatorInput>;
  originalRelativeFilePath: InputMaybe<StringQueryOperatorInput>;
  parent: InputMaybe<NodeFilterInput>;
  pluginName: InputMaybe<StringQueryOperatorInput>;
  relativeCompiledFilePath: InputMaybe<StringQueryOperatorInput>;
};


type Query_sitePageArgs = {
  children: InputMaybe<NodeFilterListInput>;
  component: InputMaybe<StringQueryOperatorInput>;
  componentChunkName: InputMaybe<StringQueryOperatorInput>;
  id: InputMaybe<StringQueryOperatorInput>;
  internal: InputMaybe<InternalFilterInput>;
  internalComponentName: InputMaybe<StringQueryOperatorInput>;
  matchPath: InputMaybe<StringQueryOperatorInput>;
  pageContext: InputMaybe<JSONQueryOperatorInput>;
  parent: InputMaybe<NodeFilterInput>;
  path: InputMaybe<StringQueryOperatorInput>;
  pluginCreator: InputMaybe<SitePluginFilterInput>;
};


type Query_sitePluginArgs = {
  browserAPIs: InputMaybe<StringQueryOperatorInput>;
  children: InputMaybe<NodeFilterListInput>;
  id: InputMaybe<StringQueryOperatorInput>;
  internal: InputMaybe<InternalFilterInput>;
  name: InputMaybe<StringQueryOperatorInput>;
  nodeAPIs: InputMaybe<StringQueryOperatorInput>;
  packageJson: InputMaybe<JSONQueryOperatorInput>;
  parent: InputMaybe<NodeFilterInput>;
  pluginFilepath: InputMaybe<StringQueryOperatorInput>;
  pluginOptions: InputMaybe<JSONQueryOperatorInput>;
  resolve: InputMaybe<StringQueryOperatorInput>;
  ssrAPIs: InputMaybe<StringQueryOperatorInput>;
  version: InputMaybe<StringQueryOperatorInput>;
};

/** Remote Interface */
type RemoteFile = {
  readonly filename: Scalars['String'];
  readonly filesize: Maybe<Scalars['Int']>;
  /** Data used in the <GatsbyImage /> component. See https://gatsby.dev/img for more info. */
  readonly gatsbyImage: Maybe<Scalars['GatsbyImageData']>;
  readonly height: Maybe<Scalars['Int']>;
  readonly id: Scalars['ID'];
  readonly mimeType: Scalars['String'];
  readonly publicUrl: Scalars['String'];
  readonly resize: Maybe<RemoteFileResize>;
  readonly width: Maybe<Scalars['Int']>;
};


/** Remote Interface */
type RemoteFile_gatsbyImageArgs = {
  aspectRatio: InputMaybe<Scalars['Float']>;
  backgroundColor: InputMaybe<Scalars['String']>;
  breakpoints?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Int']>>>;
  cropFocus: InputMaybe<ReadonlyArray<InputMaybe<RemoteFileCropFocus>>>;
  fit?: InputMaybe<RemoteFileFit>;
  formats?: InputMaybe<ReadonlyArray<RemoteFileFormat>>;
  height: InputMaybe<Scalars['Int']>;
  layout?: InputMaybe<RemoteFileLayout>;
  outputPixelDensities?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Float']>>>;
  placeholder?: InputMaybe<RemoteFilePlaceholder>;
  quality?: InputMaybe<Scalars['Int']>;
  sizes: InputMaybe<Scalars['String']>;
  width: InputMaybe<Scalars['Int']>;
};


/** Remote Interface */
type RemoteFile_resizeArgs = {
  aspectRatio: InputMaybe<Scalars['Float']>;
  cropFocus: InputMaybe<ReadonlyArray<InputMaybe<RemoteFileCropFocus>>>;
  fit?: InputMaybe<RemoteFileFit>;
  format?: InputMaybe<RemoteFileFormat>;
  height: InputMaybe<Scalars['Int']>;
  quality?: InputMaybe<Scalars['Int']>;
  width: InputMaybe<Scalars['Int']>;
};

type RemoteFileCropFocus =
  | 'bottom'
  | 'center'
  | 'edges'
  | 'entropy'
  | 'faces'
  | 'left'
  | 'right'
  | 'top';

type RemoteFileFit =
  | 'contain'
  | 'cover'
  | 'fill'
  | 'outside';

type RemoteFileFormat =
  | 'auto'
  | 'avif'
  | 'jpg'
  | 'png'
  | 'webp';

type RemoteFileLayout =
  | 'constrained'
  | 'fixed'
  | 'fullWidth';

type RemoteFilePlaceholder =
  | 'blurred'
  | 'dominantColor'
  | 'none'
  | 'tracedSVG';

type RemoteFileResize = {
  readonly height: Maybe<Scalars['Int']>;
  readonly src: Maybe<Scalars['String']>;
  readonly width: Maybe<Scalars['Int']>;
};

type RemoteFileResizeFieldSelector = {
  readonly height: InputMaybe<FieldSelectorEnum>;
  readonly src: InputMaybe<FieldSelectorEnum>;
  readonly width: InputMaybe<FieldSelectorEnum>;
};

type RemoteFileResizeFilterInput = {
  readonly height: InputMaybe<IntQueryOperatorInput>;
  readonly src: InputMaybe<StringQueryOperatorInput>;
  readonly width: InputMaybe<IntQueryOperatorInput>;
};

type RemoteFileResizeSortInput = {
  readonly height: InputMaybe<SortOrderEnum>;
  readonly src: InputMaybe<SortOrderEnum>;
  readonly width: InputMaybe<SortOrderEnum>;
};

type SanityAssetSourceData = {
  readonly _key: Maybe<Scalars['String']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly id: Maybe<Scalars['String']>;
  readonly name: Maybe<Scalars['String']>;
  readonly url: Maybe<Scalars['String']>;
};

type SanityAssetSourceDataFieldSelector = {
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly name: InputMaybe<FieldSelectorEnum>;
  readonly url: InputMaybe<FieldSelectorEnum>;
};

type SanityAssetSourceDataFilterInput = {
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly name: InputMaybe<StringQueryOperatorInput>;
  readonly url: InputMaybe<StringQueryOperatorInput>;
};

type SanityAssetSourceDataSortInput = {
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly name: InputMaybe<SortOrderEnum>;
  readonly url: InputMaybe<SortOrderEnum>;
};

type SanityBlock = {
  readonly _key: Maybe<Scalars['String']>;
  readonly _rawChildren: Maybe<Scalars['JSON']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly children: Maybe<ReadonlyArray<Maybe<SanitySpan>>>;
  readonly level: Maybe<Scalars['Float']>;
  readonly listItem: Maybe<Scalars['String']>;
  readonly style: Maybe<Scalars['String']>;
};


type SanityBlock__rawChildrenArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};

type SanityBlockFieldSelector = {
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _rawChildren: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly children: InputMaybe<SanitySpanFieldSelector>;
  readonly level: InputMaybe<FieldSelectorEnum>;
  readonly listItem: InputMaybe<FieldSelectorEnum>;
  readonly style: InputMaybe<FieldSelectorEnum>;
};

type SanityBlockFilterInput = {
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _rawChildren: InputMaybe<JSONQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly children: InputMaybe<SanitySpanFilterListInput>;
  readonly level: InputMaybe<FloatQueryOperatorInput>;
  readonly listItem: InputMaybe<StringQueryOperatorInput>;
  readonly style: InputMaybe<StringQueryOperatorInput>;
};

type SanityBlockFilterListInput = {
  readonly elemMatch: InputMaybe<SanityBlockFilterInput>;
};

type SanityBlockOrImage = SanityBlock | SanityImage;

type SanityBlockSortInput = {
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _rawChildren: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly children: InputMaybe<SanitySpanSortInput>;
  readonly level: InputMaybe<SortOrderEnum>;
  readonly listItem: InputMaybe<SortOrderEnum>;
  readonly style: InputMaybe<SortOrderEnum>;
};

type SanityCrossDatasetReference = {
  readonly _dataset: Maybe<Scalars['String']>;
  readonly _key: Maybe<Scalars['String']>;
  readonly _projectId: Maybe<Scalars['String']>;
  readonly _ref: Maybe<Scalars['String']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly _weak: Maybe<Scalars['Boolean']>;
};

/** A Sanity document */
type SanityDocument = {
  readonly _createdAt: Maybe<Scalars['Date']>;
  readonly _id: Maybe<Scalars['String']>;
  readonly _rev: Maybe<Scalars['String']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly _updatedAt: Maybe<Scalars['Date']>;
};

type SanityFile = {
  readonly _key: Maybe<Scalars['String']>;
  readonly _rawAsset: Maybe<Scalars['JSON']>;
  readonly _rawMedia: Maybe<Scalars['JSON']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly asset: Maybe<SanityFileAsset>;
  readonly media: Maybe<SanityGlobalDocumentReference>;
};


type SanityFile__rawAssetArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityFile__rawMediaArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};

type SanityFileAsset = Node & SanityDocument & {
  readonly _createdAt: Maybe<Scalars['Date']>;
  readonly _id: Maybe<Scalars['String']>;
  readonly _key: Maybe<Scalars['String']>;
  readonly _rawSource: Maybe<Scalars['JSON']>;
  readonly _rev: Maybe<Scalars['String']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly _updatedAt: Maybe<Scalars['Date']>;
  readonly altText: Maybe<Scalars['String']>;
  readonly assetId: Maybe<Scalars['String']>;
  readonly children: ReadonlyArray<Node>;
  readonly description: Maybe<Scalars['String']>;
  readonly extension: Maybe<Scalars['String']>;
  readonly id: Scalars['ID'];
  readonly internal: Internal;
  readonly label: Maybe<Scalars['String']>;
  readonly mimeType: Maybe<Scalars['String']>;
  readonly originalFilename: Maybe<Scalars['String']>;
  readonly parent: Maybe<Node>;
  readonly path: Maybe<Scalars['String']>;
  readonly sha1hash: Maybe<Scalars['String']>;
  readonly size: Maybe<Scalars['Float']>;
  readonly source: Maybe<SanityAssetSourceData>;
  readonly title: Maybe<Scalars['String']>;
  readonly uploadId: Maybe<Scalars['String']>;
  readonly url: Maybe<Scalars['String']>;
};


type SanityFileAsset__createdAtArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type SanityFileAsset__rawSourceArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityFileAsset__updatedAtArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};

type SanityFileAssetConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SanityFileAssetEdge>;
  readonly group: ReadonlyArray<SanityFileAssetGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SanityFileAsset>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SanityFileAssetConnection_distinctArgs = {
  field: SanityFileAssetFieldSelector;
};


type SanityFileAssetConnection_groupArgs = {
  field: SanityFileAssetFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SanityFileAssetConnection_maxArgs = {
  field: SanityFileAssetFieldSelector;
};


type SanityFileAssetConnection_minArgs = {
  field: SanityFileAssetFieldSelector;
};


type SanityFileAssetConnection_sumArgs = {
  field: SanityFileAssetFieldSelector;
};

type SanityFileAssetEdge = {
  readonly next: Maybe<SanityFileAsset>;
  readonly node: SanityFileAsset;
  readonly previous: Maybe<SanityFileAsset>;
};

type SanityFileAssetFieldSelector = {
  readonly _createdAt: InputMaybe<FieldSelectorEnum>;
  readonly _id: InputMaybe<FieldSelectorEnum>;
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _rawSource: InputMaybe<FieldSelectorEnum>;
  readonly _rev: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly _updatedAt: InputMaybe<FieldSelectorEnum>;
  readonly altText: InputMaybe<FieldSelectorEnum>;
  readonly assetId: InputMaybe<FieldSelectorEnum>;
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly description: InputMaybe<FieldSelectorEnum>;
  readonly extension: InputMaybe<FieldSelectorEnum>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly label: InputMaybe<FieldSelectorEnum>;
  readonly mimeType: InputMaybe<FieldSelectorEnum>;
  readonly originalFilename: InputMaybe<FieldSelectorEnum>;
  readonly parent: InputMaybe<NodeFieldSelector>;
  readonly path: InputMaybe<FieldSelectorEnum>;
  readonly sha1hash: InputMaybe<FieldSelectorEnum>;
  readonly size: InputMaybe<FieldSelectorEnum>;
  readonly source: InputMaybe<SanityAssetSourceDataFieldSelector>;
  readonly title: InputMaybe<FieldSelectorEnum>;
  readonly uploadId: InputMaybe<FieldSelectorEnum>;
  readonly url: InputMaybe<FieldSelectorEnum>;
};

type SanityFileAssetFilterInput = {
  readonly _createdAt: InputMaybe<DateQueryOperatorInput>;
  readonly _id: InputMaybe<StringQueryOperatorInput>;
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _rawSource: InputMaybe<JSONQueryOperatorInput>;
  readonly _rev: InputMaybe<StringQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly _updatedAt: InputMaybe<DateQueryOperatorInput>;
  readonly altText: InputMaybe<StringQueryOperatorInput>;
  readonly assetId: InputMaybe<StringQueryOperatorInput>;
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly description: InputMaybe<StringQueryOperatorInput>;
  readonly extension: InputMaybe<StringQueryOperatorInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly label: InputMaybe<StringQueryOperatorInput>;
  readonly mimeType: InputMaybe<StringQueryOperatorInput>;
  readonly originalFilename: InputMaybe<StringQueryOperatorInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
  readonly path: InputMaybe<StringQueryOperatorInput>;
  readonly sha1hash: InputMaybe<StringQueryOperatorInput>;
  readonly size: InputMaybe<FloatQueryOperatorInput>;
  readonly source: InputMaybe<SanityAssetSourceDataFilterInput>;
  readonly title: InputMaybe<StringQueryOperatorInput>;
  readonly uploadId: InputMaybe<StringQueryOperatorInput>;
  readonly url: InputMaybe<StringQueryOperatorInput>;
};

type SanityFileAssetGroupConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SanityFileAssetEdge>;
  readonly field: Scalars['String'];
  readonly fieldValue: Maybe<Scalars['String']>;
  readonly group: ReadonlyArray<SanityFileAssetGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SanityFileAsset>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SanityFileAssetGroupConnection_distinctArgs = {
  field: SanityFileAssetFieldSelector;
};


type SanityFileAssetGroupConnection_groupArgs = {
  field: SanityFileAssetFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SanityFileAssetGroupConnection_maxArgs = {
  field: SanityFileAssetFieldSelector;
};


type SanityFileAssetGroupConnection_minArgs = {
  field: SanityFileAssetFieldSelector;
};


type SanityFileAssetGroupConnection_sumArgs = {
  field: SanityFileAssetFieldSelector;
};

type SanityFileAssetSortInput = {
  readonly _createdAt: InputMaybe<SortOrderEnum>;
  readonly _id: InputMaybe<SortOrderEnum>;
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _rawSource: InputMaybe<SortOrderEnum>;
  readonly _rev: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly _updatedAt: InputMaybe<SortOrderEnum>;
  readonly altText: InputMaybe<SortOrderEnum>;
  readonly assetId: InputMaybe<SortOrderEnum>;
  readonly children: InputMaybe<NodeSortInput>;
  readonly description: InputMaybe<SortOrderEnum>;
  readonly extension: InputMaybe<SortOrderEnum>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly label: InputMaybe<SortOrderEnum>;
  readonly mimeType: InputMaybe<SortOrderEnum>;
  readonly originalFilename: InputMaybe<SortOrderEnum>;
  readonly parent: InputMaybe<NodeSortInput>;
  readonly path: InputMaybe<SortOrderEnum>;
  readonly sha1hash: InputMaybe<SortOrderEnum>;
  readonly size: InputMaybe<SortOrderEnum>;
  readonly source: InputMaybe<SanityAssetSourceDataSortInput>;
  readonly title: InputMaybe<SortOrderEnum>;
  readonly uploadId: InputMaybe<SortOrderEnum>;
  readonly url: InputMaybe<SortOrderEnum>;
};

type SanityGatsbyImagePlaceholder =
  | 'blurred'
  | 'dominantColor'
  | 'none';

type SanityGeopoint = {
  readonly _key: Maybe<Scalars['String']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly alt: Maybe<Scalars['Float']>;
  readonly lat: Maybe<Scalars['Float']>;
  readonly lng: Maybe<Scalars['Float']>;
};

type SanityGeopointFieldSelector = {
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly alt: InputMaybe<FieldSelectorEnum>;
  readonly lat: InputMaybe<FieldSelectorEnum>;
  readonly lng: InputMaybe<FieldSelectorEnum>;
};

type SanityGeopointFilterInput = {
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly alt: InputMaybe<FloatQueryOperatorInput>;
  readonly lat: InputMaybe<FloatQueryOperatorInput>;
  readonly lng: InputMaybe<FloatQueryOperatorInput>;
};

type SanityGeopointSortInput = {
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly alt: InputMaybe<SortOrderEnum>;
  readonly lat: InputMaybe<SortOrderEnum>;
  readonly lng: InputMaybe<SortOrderEnum>;
};

type SanityGlobalDocumentReference = {
  readonly _key: Maybe<Scalars['String']>;
  readonly _ref: Maybe<Scalars['String']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly _weak: Maybe<Scalars['Boolean']>;
};

type SanityGlobalDocumentReferenceFieldSelector = {
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _ref: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly _weak: InputMaybe<FieldSelectorEnum>;
};

type SanityGlobalDocumentReferenceFilterInput = {
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _ref: InputMaybe<StringQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly _weak: InputMaybe<BooleanQueryOperatorInput>;
};

type SanityGlobalDocumentReferenceSortInput = {
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _ref: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly _weak: InputMaybe<SortOrderEnum>;
};

type SanityImage = {
  readonly _key: Maybe<Scalars['String']>;
  readonly _rawAsset: Maybe<Scalars['JSON']>;
  readonly _rawCrop: Maybe<Scalars['JSON']>;
  readonly _rawHotspot: Maybe<Scalars['JSON']>;
  readonly _rawMedia: Maybe<Scalars['JSON']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly asset: Maybe<SanityImageAsset>;
  readonly crop: Maybe<SanityImageCrop>;
  readonly hotspot: Maybe<SanityImageHotspot>;
  readonly media: Maybe<SanityGlobalDocumentReference>;
};


type SanityImage__rawAssetArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityImage__rawCropArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityImage__rawHotspotArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityImage__rawMediaArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};

type SanityImageAsset = Node & RemoteFile & SanityDocument & {
  readonly _createdAt: Maybe<Scalars['Date']>;
  readonly _id: Maybe<Scalars['String']>;
  readonly _key: Maybe<Scalars['String']>;
  readonly _rawMetadata: Maybe<Scalars['JSON']>;
  readonly _rawSource: Maybe<Scalars['JSON']>;
  readonly _rev: Maybe<Scalars['String']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly _updatedAt: Maybe<Scalars['Date']>;
  readonly altText: Maybe<Scalars['String']>;
  readonly assetId: Maybe<Scalars['String']>;
  readonly children: ReadonlyArray<Node>;
  readonly description: Maybe<Scalars['String']>;
  readonly extension: Maybe<Scalars['String']>;
  readonly filename: Scalars['String'];
  readonly filesize: Maybe<Scalars['Int']>;
  /** Data used in the <GatsbyImage /> component. See https://gatsby.dev/img for more info. */
  readonly gatsbyImage: Maybe<Scalars['GatsbyImageData']>;
  readonly gatsbyImageData: Scalars['GatsbyImageData'];
  readonly height: Maybe<Scalars['Int']>;
  readonly id: Scalars['ID'];
  readonly internal: Internal;
  readonly label: Maybe<Scalars['String']>;
  readonly metadata: Maybe<SanityImageMetadata>;
  readonly mimeType: Scalars['String'];
  readonly originalFilename: Maybe<Scalars['String']>;
  readonly parent: Maybe<Node>;
  readonly path: Maybe<Scalars['String']>;
  readonly publicUrl: Scalars['String'];
  readonly resize: Maybe<RemoteFileResize>;
  readonly sha1hash: Maybe<Scalars['String']>;
  readonly size: Maybe<Scalars['Float']>;
  readonly source: Maybe<SanityAssetSourceData>;
  readonly title: Maybe<Scalars['String']>;
  readonly uploadId: Maybe<Scalars['String']>;
  readonly url: Maybe<Scalars['String']>;
  readonly width: Maybe<Scalars['Int']>;
};


type SanityImageAsset__createdAtArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type SanityImageAsset__rawMetadataArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityImageAsset__rawSourceArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityImageAsset__updatedAtArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type SanityImageAsset_gatsbyImageArgs = {
  aspectRatio: InputMaybe<Scalars['Float']>;
  backgroundColor: InputMaybe<Scalars['String']>;
  breakpoints?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Int']>>>;
  cropFocus: InputMaybe<ReadonlyArray<InputMaybe<RemoteFileCropFocus>>>;
  fit?: InputMaybe<RemoteFileFit>;
  formats?: InputMaybe<ReadonlyArray<RemoteFileFormat>>;
  height: InputMaybe<Scalars['Int']>;
  layout?: InputMaybe<RemoteFileLayout>;
  outputPixelDensities?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Float']>>>;
  placeholder?: InputMaybe<RemoteFilePlaceholder>;
  quality?: InputMaybe<Scalars['Int']>;
  sizes: InputMaybe<Scalars['String']>;
  width: InputMaybe<Scalars['Int']>;
};


type SanityImageAsset_gatsbyImageDataArgs = {
  aspectRatio: InputMaybe<Scalars['Float']>;
  backgroundColor: InputMaybe<Scalars['String']>;
  breakpoints: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Int']>>>;
  fit?: InputMaybe<SanityImageFit>;
  formats?: InputMaybe<ReadonlyArray<InputMaybe<GatsbyImageFormat>>>;
  height: InputMaybe<Scalars['Int']>;
  layout: InputMaybe<GatsbyImageLayout>;
  outputPixelDensities: InputMaybe<ReadonlyArray<InputMaybe<Scalars['Float']>>>;
  placeholder?: InputMaybe<SanityGatsbyImagePlaceholder>;
  sizes: InputMaybe<Scalars['String']>;
  width: InputMaybe<Scalars['Int']>;
};


type SanityImageAsset_resizeArgs = {
  aspectRatio: InputMaybe<Scalars['Float']>;
  cropFocus: InputMaybe<ReadonlyArray<InputMaybe<RemoteFileCropFocus>>>;
  fit?: InputMaybe<RemoteFileFit>;
  format?: InputMaybe<RemoteFileFormat>;
  height: InputMaybe<Scalars['Int']>;
  quality?: InputMaybe<Scalars['Int']>;
  width: InputMaybe<Scalars['Int']>;
};

type SanityImageAssetConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SanityImageAssetEdge>;
  readonly group: ReadonlyArray<SanityImageAssetGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SanityImageAsset>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SanityImageAssetConnection_distinctArgs = {
  field: SanityImageAssetFieldSelector;
};


type SanityImageAssetConnection_groupArgs = {
  field: SanityImageAssetFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SanityImageAssetConnection_maxArgs = {
  field: SanityImageAssetFieldSelector;
};


type SanityImageAssetConnection_minArgs = {
  field: SanityImageAssetFieldSelector;
};


type SanityImageAssetConnection_sumArgs = {
  field: SanityImageAssetFieldSelector;
};

type SanityImageAssetEdge = {
  readonly next: Maybe<SanityImageAsset>;
  readonly node: SanityImageAsset;
  readonly previous: Maybe<SanityImageAsset>;
};

type SanityImageAssetFieldSelector = {
  readonly _createdAt: InputMaybe<FieldSelectorEnum>;
  readonly _id: InputMaybe<FieldSelectorEnum>;
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _rawMetadata: InputMaybe<FieldSelectorEnum>;
  readonly _rawSource: InputMaybe<FieldSelectorEnum>;
  readonly _rev: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly _updatedAt: InputMaybe<FieldSelectorEnum>;
  readonly altText: InputMaybe<FieldSelectorEnum>;
  readonly assetId: InputMaybe<FieldSelectorEnum>;
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly description: InputMaybe<FieldSelectorEnum>;
  readonly extension: InputMaybe<FieldSelectorEnum>;
  readonly filename: InputMaybe<FieldSelectorEnum>;
  readonly filesize: InputMaybe<FieldSelectorEnum>;
  readonly gatsbyImage: InputMaybe<FieldSelectorEnum>;
  readonly gatsbyImageData: InputMaybe<FieldSelectorEnum>;
  readonly height: InputMaybe<FieldSelectorEnum>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly label: InputMaybe<FieldSelectorEnum>;
  readonly metadata: InputMaybe<SanityImageMetadataFieldSelector>;
  readonly mimeType: InputMaybe<FieldSelectorEnum>;
  readonly originalFilename: InputMaybe<FieldSelectorEnum>;
  readonly parent: InputMaybe<NodeFieldSelector>;
  readonly path: InputMaybe<FieldSelectorEnum>;
  readonly publicUrl: InputMaybe<FieldSelectorEnum>;
  readonly resize: InputMaybe<RemoteFileResizeFieldSelector>;
  readonly sha1hash: InputMaybe<FieldSelectorEnum>;
  readonly size: InputMaybe<FieldSelectorEnum>;
  readonly source: InputMaybe<SanityAssetSourceDataFieldSelector>;
  readonly title: InputMaybe<FieldSelectorEnum>;
  readonly uploadId: InputMaybe<FieldSelectorEnum>;
  readonly url: InputMaybe<FieldSelectorEnum>;
  readonly width: InputMaybe<FieldSelectorEnum>;
};

type SanityImageAssetFilterInput = {
  readonly _createdAt: InputMaybe<DateQueryOperatorInput>;
  readonly _id: InputMaybe<StringQueryOperatorInput>;
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _rawMetadata: InputMaybe<JSONQueryOperatorInput>;
  readonly _rawSource: InputMaybe<JSONQueryOperatorInput>;
  readonly _rev: InputMaybe<StringQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly _updatedAt: InputMaybe<DateQueryOperatorInput>;
  readonly altText: InputMaybe<StringQueryOperatorInput>;
  readonly assetId: InputMaybe<StringQueryOperatorInput>;
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly description: InputMaybe<StringQueryOperatorInput>;
  readonly extension: InputMaybe<StringQueryOperatorInput>;
  readonly filename: InputMaybe<StringQueryOperatorInput>;
  readonly filesize: InputMaybe<IntQueryOperatorInput>;
  readonly gatsbyImage: InputMaybe<GatsbyImageDataQueryOperatorInput>;
  readonly gatsbyImageData: InputMaybe<GatsbyImageDataQueryOperatorInput>;
  readonly height: InputMaybe<IntQueryOperatorInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly label: InputMaybe<StringQueryOperatorInput>;
  readonly metadata: InputMaybe<SanityImageMetadataFilterInput>;
  readonly mimeType: InputMaybe<StringQueryOperatorInput>;
  readonly originalFilename: InputMaybe<StringQueryOperatorInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
  readonly path: InputMaybe<StringQueryOperatorInput>;
  readonly publicUrl: InputMaybe<StringQueryOperatorInput>;
  readonly resize: InputMaybe<RemoteFileResizeFilterInput>;
  readonly sha1hash: InputMaybe<StringQueryOperatorInput>;
  readonly size: InputMaybe<FloatQueryOperatorInput>;
  readonly source: InputMaybe<SanityAssetSourceDataFilterInput>;
  readonly title: InputMaybe<StringQueryOperatorInput>;
  readonly uploadId: InputMaybe<StringQueryOperatorInput>;
  readonly url: InputMaybe<StringQueryOperatorInput>;
  readonly width: InputMaybe<IntQueryOperatorInput>;
};

type SanityImageAssetGroupConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SanityImageAssetEdge>;
  readonly field: Scalars['String'];
  readonly fieldValue: Maybe<Scalars['String']>;
  readonly group: ReadonlyArray<SanityImageAssetGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SanityImageAsset>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SanityImageAssetGroupConnection_distinctArgs = {
  field: SanityImageAssetFieldSelector;
};


type SanityImageAssetGroupConnection_groupArgs = {
  field: SanityImageAssetFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SanityImageAssetGroupConnection_maxArgs = {
  field: SanityImageAssetFieldSelector;
};


type SanityImageAssetGroupConnection_minArgs = {
  field: SanityImageAssetFieldSelector;
};


type SanityImageAssetGroupConnection_sumArgs = {
  field: SanityImageAssetFieldSelector;
};

type SanityImageAssetSortInput = {
  readonly _createdAt: InputMaybe<SortOrderEnum>;
  readonly _id: InputMaybe<SortOrderEnum>;
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _rawMetadata: InputMaybe<SortOrderEnum>;
  readonly _rawSource: InputMaybe<SortOrderEnum>;
  readonly _rev: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly _updatedAt: InputMaybe<SortOrderEnum>;
  readonly altText: InputMaybe<SortOrderEnum>;
  readonly assetId: InputMaybe<SortOrderEnum>;
  readonly children: InputMaybe<NodeSortInput>;
  readonly description: InputMaybe<SortOrderEnum>;
  readonly extension: InputMaybe<SortOrderEnum>;
  readonly filename: InputMaybe<SortOrderEnum>;
  readonly filesize: InputMaybe<SortOrderEnum>;
  readonly gatsbyImage: InputMaybe<SortOrderEnum>;
  readonly gatsbyImageData: InputMaybe<SortOrderEnum>;
  readonly height: InputMaybe<SortOrderEnum>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly label: InputMaybe<SortOrderEnum>;
  readonly metadata: InputMaybe<SanityImageMetadataSortInput>;
  readonly mimeType: InputMaybe<SortOrderEnum>;
  readonly originalFilename: InputMaybe<SortOrderEnum>;
  readonly parent: InputMaybe<NodeSortInput>;
  readonly path: InputMaybe<SortOrderEnum>;
  readonly publicUrl: InputMaybe<SortOrderEnum>;
  readonly resize: InputMaybe<RemoteFileResizeSortInput>;
  readonly sha1hash: InputMaybe<SortOrderEnum>;
  readonly size: InputMaybe<SortOrderEnum>;
  readonly source: InputMaybe<SanityAssetSourceDataSortInput>;
  readonly title: InputMaybe<SortOrderEnum>;
  readonly uploadId: InputMaybe<SortOrderEnum>;
  readonly url: InputMaybe<SortOrderEnum>;
  readonly width: InputMaybe<SortOrderEnum>;
};

type SanityImageCrop = {
  readonly _key: Maybe<Scalars['String']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly bottom: Maybe<Scalars['Float']>;
  readonly left: Maybe<Scalars['Float']>;
  readonly right: Maybe<Scalars['Float']>;
  readonly top: Maybe<Scalars['Float']>;
};

type SanityImageCropFieldSelector = {
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly bottom: InputMaybe<FieldSelectorEnum>;
  readonly left: InputMaybe<FieldSelectorEnum>;
  readonly right: InputMaybe<FieldSelectorEnum>;
  readonly top: InputMaybe<FieldSelectorEnum>;
};

type SanityImageCropFilterInput = {
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly bottom: InputMaybe<FloatQueryOperatorInput>;
  readonly left: InputMaybe<FloatQueryOperatorInput>;
  readonly right: InputMaybe<FloatQueryOperatorInput>;
  readonly top: InputMaybe<FloatQueryOperatorInput>;
};

type SanityImageCropSortInput = {
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly bottom: InputMaybe<SortOrderEnum>;
  readonly left: InputMaybe<SortOrderEnum>;
  readonly right: InputMaybe<SortOrderEnum>;
  readonly top: InputMaybe<SortOrderEnum>;
};

type SanityImageDimensions = {
  readonly _key: Maybe<Scalars['String']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly aspectRatio: Maybe<Scalars['Float']>;
  readonly height: Maybe<Scalars['Float']>;
  readonly width: Maybe<Scalars['Float']>;
};

type SanityImageDimensionsFieldSelector = {
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly aspectRatio: InputMaybe<FieldSelectorEnum>;
  readonly height: InputMaybe<FieldSelectorEnum>;
  readonly width: InputMaybe<FieldSelectorEnum>;
};

type SanityImageDimensionsFilterInput = {
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly aspectRatio: InputMaybe<FloatQueryOperatorInput>;
  readonly height: InputMaybe<FloatQueryOperatorInput>;
  readonly width: InputMaybe<FloatQueryOperatorInput>;
};

type SanityImageDimensionsSortInput = {
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly aspectRatio: InputMaybe<SortOrderEnum>;
  readonly height: InputMaybe<SortOrderEnum>;
  readonly width: InputMaybe<SortOrderEnum>;
};

type SanityImageFieldSelector = {
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _rawAsset: InputMaybe<FieldSelectorEnum>;
  readonly _rawCrop: InputMaybe<FieldSelectorEnum>;
  readonly _rawHotspot: InputMaybe<FieldSelectorEnum>;
  readonly _rawMedia: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly asset: InputMaybe<SanityImageAssetFieldSelector>;
  readonly crop: InputMaybe<SanityImageCropFieldSelector>;
  readonly hotspot: InputMaybe<SanityImageHotspotFieldSelector>;
  readonly media: InputMaybe<SanityGlobalDocumentReferenceFieldSelector>;
};

type SanityImageFilterInput = {
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _rawAsset: InputMaybe<JSONQueryOperatorInput>;
  readonly _rawCrop: InputMaybe<JSONQueryOperatorInput>;
  readonly _rawHotspot: InputMaybe<JSONQueryOperatorInput>;
  readonly _rawMedia: InputMaybe<JSONQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly asset: InputMaybe<SanityImageAssetFilterInput>;
  readonly crop: InputMaybe<SanityImageCropFilterInput>;
  readonly hotspot: InputMaybe<SanityImageHotspotFilterInput>;
  readonly media: InputMaybe<SanityGlobalDocumentReferenceFilterInput>;
};

type SanityImageFit =
  | 'clip'
  | 'crop'
  | 'fill'
  | 'fillmax'
  | 'max'
  | 'min'
  | 'scale';

type SanityImageHotspot = {
  readonly _key: Maybe<Scalars['String']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly height: Maybe<Scalars['Float']>;
  readonly width: Maybe<Scalars['Float']>;
  readonly x: Maybe<Scalars['Float']>;
  readonly y: Maybe<Scalars['Float']>;
};

type SanityImageHotspotFieldSelector = {
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly height: InputMaybe<FieldSelectorEnum>;
  readonly width: InputMaybe<FieldSelectorEnum>;
  readonly x: InputMaybe<FieldSelectorEnum>;
  readonly y: InputMaybe<FieldSelectorEnum>;
};

type SanityImageHotspotFilterInput = {
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly height: InputMaybe<FloatQueryOperatorInput>;
  readonly width: InputMaybe<FloatQueryOperatorInput>;
  readonly x: InputMaybe<FloatQueryOperatorInput>;
  readonly y: InputMaybe<FloatQueryOperatorInput>;
};

type SanityImageHotspotSortInput = {
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly height: InputMaybe<SortOrderEnum>;
  readonly width: InputMaybe<SortOrderEnum>;
  readonly x: InputMaybe<SortOrderEnum>;
  readonly y: InputMaybe<SortOrderEnum>;
};

type SanityImageMetadata = {
  readonly _key: Maybe<Scalars['String']>;
  readonly _rawDimensions: Maybe<Scalars['JSON']>;
  readonly _rawLocation: Maybe<Scalars['JSON']>;
  readonly _rawPalette: Maybe<Scalars['JSON']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly blurHash: Maybe<Scalars['String']>;
  readonly dimensions: Maybe<SanityImageDimensions>;
  readonly hasAlpha: Maybe<Scalars['Boolean']>;
  readonly isOpaque: Maybe<Scalars['Boolean']>;
  readonly location: Maybe<SanityGeopoint>;
  readonly lqip: Maybe<Scalars['String']>;
  readonly palette: Maybe<SanityImagePalette>;
};


type SanityImageMetadata__rawDimensionsArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityImageMetadata__rawLocationArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityImageMetadata__rawPaletteArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};

type SanityImageMetadataFieldSelector = {
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _rawDimensions: InputMaybe<FieldSelectorEnum>;
  readonly _rawLocation: InputMaybe<FieldSelectorEnum>;
  readonly _rawPalette: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly blurHash: InputMaybe<FieldSelectorEnum>;
  readonly dimensions: InputMaybe<SanityImageDimensionsFieldSelector>;
  readonly hasAlpha: InputMaybe<FieldSelectorEnum>;
  readonly isOpaque: InputMaybe<FieldSelectorEnum>;
  readonly location: InputMaybe<SanityGeopointFieldSelector>;
  readonly lqip: InputMaybe<FieldSelectorEnum>;
  readonly palette: InputMaybe<SanityImagePaletteFieldSelector>;
};

type SanityImageMetadataFilterInput = {
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _rawDimensions: InputMaybe<JSONQueryOperatorInput>;
  readonly _rawLocation: InputMaybe<JSONQueryOperatorInput>;
  readonly _rawPalette: InputMaybe<JSONQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly blurHash: InputMaybe<StringQueryOperatorInput>;
  readonly dimensions: InputMaybe<SanityImageDimensionsFilterInput>;
  readonly hasAlpha: InputMaybe<BooleanQueryOperatorInput>;
  readonly isOpaque: InputMaybe<BooleanQueryOperatorInput>;
  readonly location: InputMaybe<SanityGeopointFilterInput>;
  readonly lqip: InputMaybe<StringQueryOperatorInput>;
  readonly palette: InputMaybe<SanityImagePaletteFilterInput>;
};

type SanityImageMetadataSortInput = {
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _rawDimensions: InputMaybe<SortOrderEnum>;
  readonly _rawLocation: InputMaybe<SortOrderEnum>;
  readonly _rawPalette: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly blurHash: InputMaybe<SortOrderEnum>;
  readonly dimensions: InputMaybe<SanityImageDimensionsSortInput>;
  readonly hasAlpha: InputMaybe<SortOrderEnum>;
  readonly isOpaque: InputMaybe<SortOrderEnum>;
  readonly location: InputMaybe<SanityGeopointSortInput>;
  readonly lqip: InputMaybe<SortOrderEnum>;
  readonly palette: InputMaybe<SanityImagePaletteSortInput>;
};

type SanityImagePalette = {
  readonly _key: Maybe<Scalars['String']>;
  readonly _rawDarkMuted: Maybe<Scalars['JSON']>;
  readonly _rawDarkVibrant: Maybe<Scalars['JSON']>;
  readonly _rawDominant: Maybe<Scalars['JSON']>;
  readonly _rawLightMuted: Maybe<Scalars['JSON']>;
  readonly _rawLightVibrant: Maybe<Scalars['JSON']>;
  readonly _rawMuted: Maybe<Scalars['JSON']>;
  readonly _rawVibrant: Maybe<Scalars['JSON']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly darkMuted: Maybe<SanityImagePaletteSwatch>;
  readonly darkVibrant: Maybe<SanityImagePaletteSwatch>;
  readonly dominant: Maybe<SanityImagePaletteSwatch>;
  readonly lightMuted: Maybe<SanityImagePaletteSwatch>;
  readonly lightVibrant: Maybe<SanityImagePaletteSwatch>;
  readonly muted: Maybe<SanityImagePaletteSwatch>;
  readonly vibrant: Maybe<SanityImagePaletteSwatch>;
};


type SanityImagePalette__rawDarkMutedArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityImagePalette__rawDarkVibrantArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityImagePalette__rawDominantArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityImagePalette__rawLightMutedArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityImagePalette__rawLightVibrantArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityImagePalette__rawMutedArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityImagePalette__rawVibrantArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};

type SanityImagePaletteFieldSelector = {
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _rawDarkMuted: InputMaybe<FieldSelectorEnum>;
  readonly _rawDarkVibrant: InputMaybe<FieldSelectorEnum>;
  readonly _rawDominant: InputMaybe<FieldSelectorEnum>;
  readonly _rawLightMuted: InputMaybe<FieldSelectorEnum>;
  readonly _rawLightVibrant: InputMaybe<FieldSelectorEnum>;
  readonly _rawMuted: InputMaybe<FieldSelectorEnum>;
  readonly _rawVibrant: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly darkMuted: InputMaybe<SanityImagePaletteSwatchFieldSelector>;
  readonly darkVibrant: InputMaybe<SanityImagePaletteSwatchFieldSelector>;
  readonly dominant: InputMaybe<SanityImagePaletteSwatchFieldSelector>;
  readonly lightMuted: InputMaybe<SanityImagePaletteSwatchFieldSelector>;
  readonly lightVibrant: InputMaybe<SanityImagePaletteSwatchFieldSelector>;
  readonly muted: InputMaybe<SanityImagePaletteSwatchFieldSelector>;
  readonly vibrant: InputMaybe<SanityImagePaletteSwatchFieldSelector>;
};

type SanityImagePaletteFilterInput = {
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _rawDarkMuted: InputMaybe<JSONQueryOperatorInput>;
  readonly _rawDarkVibrant: InputMaybe<JSONQueryOperatorInput>;
  readonly _rawDominant: InputMaybe<JSONQueryOperatorInput>;
  readonly _rawLightMuted: InputMaybe<JSONQueryOperatorInput>;
  readonly _rawLightVibrant: InputMaybe<JSONQueryOperatorInput>;
  readonly _rawMuted: InputMaybe<JSONQueryOperatorInput>;
  readonly _rawVibrant: InputMaybe<JSONQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly darkMuted: InputMaybe<SanityImagePaletteSwatchFilterInput>;
  readonly darkVibrant: InputMaybe<SanityImagePaletteSwatchFilterInput>;
  readonly dominant: InputMaybe<SanityImagePaletteSwatchFilterInput>;
  readonly lightMuted: InputMaybe<SanityImagePaletteSwatchFilterInput>;
  readonly lightVibrant: InputMaybe<SanityImagePaletteSwatchFilterInput>;
  readonly muted: InputMaybe<SanityImagePaletteSwatchFilterInput>;
  readonly vibrant: InputMaybe<SanityImagePaletteSwatchFilterInput>;
};

type SanityImagePaletteSortInput = {
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _rawDarkMuted: InputMaybe<SortOrderEnum>;
  readonly _rawDarkVibrant: InputMaybe<SortOrderEnum>;
  readonly _rawDominant: InputMaybe<SortOrderEnum>;
  readonly _rawLightMuted: InputMaybe<SortOrderEnum>;
  readonly _rawLightVibrant: InputMaybe<SortOrderEnum>;
  readonly _rawMuted: InputMaybe<SortOrderEnum>;
  readonly _rawVibrant: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly darkMuted: InputMaybe<SanityImagePaletteSwatchSortInput>;
  readonly darkVibrant: InputMaybe<SanityImagePaletteSwatchSortInput>;
  readonly dominant: InputMaybe<SanityImagePaletteSwatchSortInput>;
  readonly lightMuted: InputMaybe<SanityImagePaletteSwatchSortInput>;
  readonly lightVibrant: InputMaybe<SanityImagePaletteSwatchSortInput>;
  readonly muted: InputMaybe<SanityImagePaletteSwatchSortInput>;
  readonly vibrant: InputMaybe<SanityImagePaletteSwatchSortInput>;
};

type SanityImagePaletteSwatch = {
  readonly _key: Maybe<Scalars['String']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly background: Maybe<Scalars['String']>;
  readonly foreground: Maybe<Scalars['String']>;
  readonly population: Maybe<Scalars['Float']>;
  readonly title: Maybe<Scalars['String']>;
};

type SanityImagePaletteSwatchFieldSelector = {
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly background: InputMaybe<FieldSelectorEnum>;
  readonly foreground: InputMaybe<FieldSelectorEnum>;
  readonly population: InputMaybe<FieldSelectorEnum>;
  readonly title: InputMaybe<FieldSelectorEnum>;
};

type SanityImagePaletteSwatchFilterInput = {
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly background: InputMaybe<StringQueryOperatorInput>;
  readonly foreground: InputMaybe<StringQueryOperatorInput>;
  readonly population: InputMaybe<FloatQueryOperatorInput>;
  readonly title: InputMaybe<StringQueryOperatorInput>;
};

type SanityImagePaletteSwatchSortInput = {
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly background: InputMaybe<SortOrderEnum>;
  readonly foreground: InputMaybe<SortOrderEnum>;
  readonly population: InputMaybe<SortOrderEnum>;
  readonly title: InputMaybe<SortOrderEnum>;
};

type SanityImageSortInput = {
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _rawAsset: InputMaybe<SortOrderEnum>;
  readonly _rawCrop: InputMaybe<SortOrderEnum>;
  readonly _rawHotspot: InputMaybe<SortOrderEnum>;
  readonly _rawMedia: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly asset: InputMaybe<SanityImageAssetSortInput>;
  readonly crop: InputMaybe<SanityImageCropSortInput>;
  readonly hotspot: InputMaybe<SanityImageHotspotSortInput>;
  readonly media: InputMaybe<SanityGlobalDocumentReferenceSortInput>;
};

type SanityMediaTag = Node & SanityDocument & {
  readonly _createdAt: Maybe<Scalars['Date']>;
  readonly _id: Maybe<Scalars['String']>;
  readonly _key: Maybe<Scalars['String']>;
  readonly _rawName: Maybe<Scalars['JSON']>;
  readonly _rev: Maybe<Scalars['String']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly _updatedAt: Maybe<Scalars['Date']>;
  readonly children: ReadonlyArray<Node>;
  readonly id: Scalars['ID'];
  readonly internal: Internal;
  readonly name: Maybe<SanitySlug>;
  readonly parent: Maybe<Node>;
};


type SanityMediaTag__createdAtArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type SanityMediaTag__rawNameArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityMediaTag__updatedAtArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};

type SanityMediaTagConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SanityMediaTagEdge>;
  readonly group: ReadonlyArray<SanityMediaTagGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SanityMediaTag>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SanityMediaTagConnection_distinctArgs = {
  field: SanityMediaTagFieldSelector;
};


type SanityMediaTagConnection_groupArgs = {
  field: SanityMediaTagFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SanityMediaTagConnection_maxArgs = {
  field: SanityMediaTagFieldSelector;
};


type SanityMediaTagConnection_minArgs = {
  field: SanityMediaTagFieldSelector;
};


type SanityMediaTagConnection_sumArgs = {
  field: SanityMediaTagFieldSelector;
};

type SanityMediaTagEdge = {
  readonly next: Maybe<SanityMediaTag>;
  readonly node: SanityMediaTag;
  readonly previous: Maybe<SanityMediaTag>;
};

type SanityMediaTagFieldSelector = {
  readonly _createdAt: InputMaybe<FieldSelectorEnum>;
  readonly _id: InputMaybe<FieldSelectorEnum>;
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _rawName: InputMaybe<FieldSelectorEnum>;
  readonly _rev: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly _updatedAt: InputMaybe<FieldSelectorEnum>;
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly name: InputMaybe<SanitySlugFieldSelector>;
  readonly parent: InputMaybe<NodeFieldSelector>;
};

type SanityMediaTagFilterInput = {
  readonly _createdAt: InputMaybe<DateQueryOperatorInput>;
  readonly _id: InputMaybe<StringQueryOperatorInput>;
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _rawName: InputMaybe<JSONQueryOperatorInput>;
  readonly _rev: InputMaybe<StringQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly _updatedAt: InputMaybe<DateQueryOperatorInput>;
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly name: InputMaybe<SanitySlugFilterInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
};

type SanityMediaTagGroupConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SanityMediaTagEdge>;
  readonly field: Scalars['String'];
  readonly fieldValue: Maybe<Scalars['String']>;
  readonly group: ReadonlyArray<SanityMediaTagGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SanityMediaTag>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SanityMediaTagGroupConnection_distinctArgs = {
  field: SanityMediaTagFieldSelector;
};


type SanityMediaTagGroupConnection_groupArgs = {
  field: SanityMediaTagFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SanityMediaTagGroupConnection_maxArgs = {
  field: SanityMediaTagFieldSelector;
};


type SanityMediaTagGroupConnection_minArgs = {
  field: SanityMediaTagFieldSelector;
};


type SanityMediaTagGroupConnection_sumArgs = {
  field: SanityMediaTagFieldSelector;
};

type SanityMediaTagSortInput = {
  readonly _createdAt: InputMaybe<SortOrderEnum>;
  readonly _id: InputMaybe<SortOrderEnum>;
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _rawName: InputMaybe<SortOrderEnum>;
  readonly _rev: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly _updatedAt: InputMaybe<SortOrderEnum>;
  readonly children: InputMaybe<NodeSortInput>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly name: InputMaybe<SanitySlugSortInput>;
  readonly parent: InputMaybe<NodeSortInput>;
};

type SanityPost = Node & SanityDocument & {
  readonly _createdAt: Maybe<Scalars['Date']>;
  readonly _id: Maybe<Scalars['String']>;
  readonly _key: Maybe<Scalars['String']>;
  readonly _rawBody: Maybe<Scalars['JSON']>;
  readonly _rawImage: Maybe<Scalars['JSON']>;
  readonly _rawSlug: Maybe<Scalars['JSON']>;
  readonly _rev: Maybe<Scalars['String']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly _updatedAt: Maybe<Scalars['Date']>;
  readonly author: Maybe<Scalars['String']>;
  readonly body: Maybe<ReadonlyArray<Maybe<SanityBlock>>>;
  readonly children: ReadonlyArray<Node>;
  readonly id: Scalars['ID'];
  readonly image: Maybe<SanityImage>;
  readonly internal: Internal;
  readonly parent: Maybe<Node>;
  readonly publishedAt: Maybe<Scalars['Date']>;
  readonly slug: Maybe<SanitySlug>;
  readonly title: Maybe<Scalars['String']>;
};


type SanityPost__createdAtArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type SanityPost__rawBodyArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityPost__rawImageArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityPost__rawSlugArgs = {
  resolveReferences: InputMaybe<SanityResolveReferencesConfiguration>;
};


type SanityPost__updatedAtArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};


type SanityPost_publishedAtArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};

type SanityPostConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SanityPostEdge>;
  readonly group: ReadonlyArray<SanityPostGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SanityPost>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SanityPostConnection_distinctArgs = {
  field: SanityPostFieldSelector;
};


type SanityPostConnection_groupArgs = {
  field: SanityPostFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SanityPostConnection_maxArgs = {
  field: SanityPostFieldSelector;
};


type SanityPostConnection_minArgs = {
  field: SanityPostFieldSelector;
};


type SanityPostConnection_sumArgs = {
  field: SanityPostFieldSelector;
};

type SanityPostEdge = {
  readonly next: Maybe<SanityPost>;
  readonly node: SanityPost;
  readonly previous: Maybe<SanityPost>;
};

type SanityPostFieldSelector = {
  readonly _createdAt: InputMaybe<FieldSelectorEnum>;
  readonly _id: InputMaybe<FieldSelectorEnum>;
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _rawBody: InputMaybe<FieldSelectorEnum>;
  readonly _rawImage: InputMaybe<FieldSelectorEnum>;
  readonly _rawSlug: InputMaybe<FieldSelectorEnum>;
  readonly _rev: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly _updatedAt: InputMaybe<FieldSelectorEnum>;
  readonly author: InputMaybe<FieldSelectorEnum>;
  readonly body: InputMaybe<SanityBlockFieldSelector>;
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly image: InputMaybe<SanityImageFieldSelector>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly parent: InputMaybe<NodeFieldSelector>;
  readonly publishedAt: InputMaybe<FieldSelectorEnum>;
  readonly slug: InputMaybe<SanitySlugFieldSelector>;
  readonly title: InputMaybe<FieldSelectorEnum>;
};

type SanityPostFilterInput = {
  readonly _createdAt: InputMaybe<DateQueryOperatorInput>;
  readonly _id: InputMaybe<StringQueryOperatorInput>;
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _rawBody: InputMaybe<JSONQueryOperatorInput>;
  readonly _rawImage: InputMaybe<JSONQueryOperatorInput>;
  readonly _rawSlug: InputMaybe<JSONQueryOperatorInput>;
  readonly _rev: InputMaybe<StringQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly _updatedAt: InputMaybe<DateQueryOperatorInput>;
  readonly author: InputMaybe<StringQueryOperatorInput>;
  readonly body: InputMaybe<SanityBlockFilterListInput>;
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly image: InputMaybe<SanityImageFilterInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
  readonly publishedAt: InputMaybe<DateQueryOperatorInput>;
  readonly slug: InputMaybe<SanitySlugFilterInput>;
  readonly title: InputMaybe<StringQueryOperatorInput>;
};

type SanityPostGroupConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SanityPostEdge>;
  readonly field: Scalars['String'];
  readonly fieldValue: Maybe<Scalars['String']>;
  readonly group: ReadonlyArray<SanityPostGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SanityPost>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SanityPostGroupConnection_distinctArgs = {
  field: SanityPostFieldSelector;
};


type SanityPostGroupConnection_groupArgs = {
  field: SanityPostFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SanityPostGroupConnection_maxArgs = {
  field: SanityPostFieldSelector;
};


type SanityPostGroupConnection_minArgs = {
  field: SanityPostFieldSelector;
};


type SanityPostGroupConnection_sumArgs = {
  field: SanityPostFieldSelector;
};

type SanityPostSortInput = {
  readonly _createdAt: InputMaybe<SortOrderEnum>;
  readonly _id: InputMaybe<SortOrderEnum>;
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _rawBody: InputMaybe<SortOrderEnum>;
  readonly _rawImage: InputMaybe<SortOrderEnum>;
  readonly _rawSlug: InputMaybe<SortOrderEnum>;
  readonly _rev: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly _updatedAt: InputMaybe<SortOrderEnum>;
  readonly author: InputMaybe<SortOrderEnum>;
  readonly body: InputMaybe<SanityBlockSortInput>;
  readonly children: InputMaybe<NodeSortInput>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly image: InputMaybe<SanityImageSortInput>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly parent: InputMaybe<NodeSortInput>;
  readonly publishedAt: InputMaybe<SortOrderEnum>;
  readonly slug: InputMaybe<SanitySlugSortInput>;
  readonly title: InputMaybe<SortOrderEnum>;
};

type SanityResolveReferencesConfiguration = {
  /** Max depth to resolve references to */
  readonly maxDepth: Scalars['Int'];
};

type SanitySlug = {
  readonly _key: Maybe<Scalars['String']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly current: Maybe<Scalars['String']>;
  readonly source: Maybe<Scalars['String']>;
};

type SanitySlugFieldSelector = {
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly current: InputMaybe<FieldSelectorEnum>;
  readonly source: InputMaybe<FieldSelectorEnum>;
};

type SanitySlugFilterInput = {
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly current: InputMaybe<StringQueryOperatorInput>;
  readonly source: InputMaybe<StringQueryOperatorInput>;
};

type SanitySlugSortInput = {
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly current: InputMaybe<SortOrderEnum>;
  readonly source: InputMaybe<SortOrderEnum>;
};

type SanitySpan = {
  readonly _key: Maybe<Scalars['String']>;
  readonly _type: Maybe<Scalars['String']>;
  readonly marks: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly text: Maybe<Scalars['String']>;
};

type SanitySpanFieldSelector = {
  readonly _key: InputMaybe<FieldSelectorEnum>;
  readonly _type: InputMaybe<FieldSelectorEnum>;
  readonly marks: InputMaybe<FieldSelectorEnum>;
  readonly text: InputMaybe<FieldSelectorEnum>;
};

type SanitySpanFilterInput = {
  readonly _key: InputMaybe<StringQueryOperatorInput>;
  readonly _type: InputMaybe<StringQueryOperatorInput>;
  readonly marks: InputMaybe<StringQueryOperatorInput>;
  readonly text: InputMaybe<StringQueryOperatorInput>;
};

type SanitySpanFilterListInput = {
  readonly elemMatch: InputMaybe<SanitySpanFilterInput>;
};

type SanitySpanSortInput = {
  readonly _key: InputMaybe<SortOrderEnum>;
  readonly _type: InputMaybe<SortOrderEnum>;
  readonly marks: InputMaybe<SortOrderEnum>;
  readonly text: InputMaybe<SortOrderEnum>;
};

type Site = Node & {
  readonly buildTime: Maybe<Scalars['Date']>;
  readonly children: ReadonlyArray<Node>;
  readonly graphqlTypegen: Maybe<SiteGraphqlTypegen>;
  readonly host: Maybe<Scalars['String']>;
  readonly id: Scalars['ID'];
  readonly internal: Internal;
  readonly jsxRuntime: Maybe<Scalars['String']>;
  readonly parent: Maybe<Node>;
  readonly pathPrefix: Maybe<Scalars['String']>;
  readonly polyfill: Maybe<Scalars['Boolean']>;
  readonly port: Maybe<Scalars['Int']>;
  readonly siteMetadata: Maybe<SiteSiteMetadata>;
  readonly trailingSlash: Maybe<Scalars['String']>;
};


type Site_buildTimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};

type SiteBuildMetadata = Node & {
  readonly buildTime: Maybe<Scalars['Date']>;
  readonly children: ReadonlyArray<Node>;
  readonly id: Scalars['ID'];
  readonly internal: Internal;
  readonly parent: Maybe<Node>;
};


type SiteBuildMetadata_buildTimeArgs = {
  difference: InputMaybe<Scalars['String']>;
  formatString: InputMaybe<Scalars['String']>;
  fromNow: InputMaybe<Scalars['Boolean']>;
  locale: InputMaybe<Scalars['String']>;
};

type SiteBuildMetadataConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SiteBuildMetadataEdge>;
  readonly group: ReadonlyArray<SiteBuildMetadataGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SiteBuildMetadata>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SiteBuildMetadataConnection_distinctArgs = {
  field: SiteBuildMetadataFieldSelector;
};


type SiteBuildMetadataConnection_groupArgs = {
  field: SiteBuildMetadataFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SiteBuildMetadataConnection_maxArgs = {
  field: SiteBuildMetadataFieldSelector;
};


type SiteBuildMetadataConnection_minArgs = {
  field: SiteBuildMetadataFieldSelector;
};


type SiteBuildMetadataConnection_sumArgs = {
  field: SiteBuildMetadataFieldSelector;
};

type SiteBuildMetadataEdge = {
  readonly next: Maybe<SiteBuildMetadata>;
  readonly node: SiteBuildMetadata;
  readonly previous: Maybe<SiteBuildMetadata>;
};

type SiteBuildMetadataFieldSelector = {
  readonly buildTime: InputMaybe<FieldSelectorEnum>;
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly parent: InputMaybe<NodeFieldSelector>;
};

type SiteBuildMetadataFilterInput = {
  readonly buildTime: InputMaybe<DateQueryOperatorInput>;
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
};

type SiteBuildMetadataGroupConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SiteBuildMetadataEdge>;
  readonly field: Scalars['String'];
  readonly fieldValue: Maybe<Scalars['String']>;
  readonly group: ReadonlyArray<SiteBuildMetadataGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SiteBuildMetadata>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SiteBuildMetadataGroupConnection_distinctArgs = {
  field: SiteBuildMetadataFieldSelector;
};


type SiteBuildMetadataGroupConnection_groupArgs = {
  field: SiteBuildMetadataFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SiteBuildMetadataGroupConnection_maxArgs = {
  field: SiteBuildMetadataFieldSelector;
};


type SiteBuildMetadataGroupConnection_minArgs = {
  field: SiteBuildMetadataFieldSelector;
};


type SiteBuildMetadataGroupConnection_sumArgs = {
  field: SiteBuildMetadataFieldSelector;
};

type SiteBuildMetadataSortInput = {
  readonly buildTime: InputMaybe<SortOrderEnum>;
  readonly children: InputMaybe<NodeSortInput>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly parent: InputMaybe<NodeSortInput>;
};

type SiteConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SiteEdge>;
  readonly group: ReadonlyArray<SiteGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<Site>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SiteConnection_distinctArgs = {
  field: SiteFieldSelector;
};


type SiteConnection_groupArgs = {
  field: SiteFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SiteConnection_maxArgs = {
  field: SiteFieldSelector;
};


type SiteConnection_minArgs = {
  field: SiteFieldSelector;
};


type SiteConnection_sumArgs = {
  field: SiteFieldSelector;
};

type SiteEdge = {
  readonly next: Maybe<Site>;
  readonly node: Site;
  readonly previous: Maybe<Site>;
};

type SiteFieldSelector = {
  readonly buildTime: InputMaybe<FieldSelectorEnum>;
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly graphqlTypegen: InputMaybe<SiteGraphqlTypegenFieldSelector>;
  readonly host: InputMaybe<FieldSelectorEnum>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly jsxRuntime: InputMaybe<FieldSelectorEnum>;
  readonly parent: InputMaybe<NodeFieldSelector>;
  readonly pathPrefix: InputMaybe<FieldSelectorEnum>;
  readonly polyfill: InputMaybe<FieldSelectorEnum>;
  readonly port: InputMaybe<FieldSelectorEnum>;
  readonly siteMetadata: InputMaybe<SiteSiteMetadataFieldSelector>;
  readonly trailingSlash: InputMaybe<FieldSelectorEnum>;
};

type SiteFilterInput = {
  readonly buildTime: InputMaybe<DateQueryOperatorInput>;
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly graphqlTypegen: InputMaybe<SiteGraphqlTypegenFilterInput>;
  readonly host: InputMaybe<StringQueryOperatorInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly jsxRuntime: InputMaybe<StringQueryOperatorInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
  readonly pathPrefix: InputMaybe<StringQueryOperatorInput>;
  readonly polyfill: InputMaybe<BooleanQueryOperatorInput>;
  readonly port: InputMaybe<IntQueryOperatorInput>;
  readonly siteMetadata: InputMaybe<SiteSiteMetadataFilterInput>;
  readonly trailingSlash: InputMaybe<StringQueryOperatorInput>;
};

type SiteFunction = Node & {
  readonly absoluteCompiledFilePath: Scalars['String'];
  readonly children: ReadonlyArray<Node>;
  readonly functionRoute: Scalars['String'];
  readonly id: Scalars['ID'];
  readonly internal: Internal;
  readonly matchPath: Maybe<Scalars['String']>;
  readonly originalAbsoluteFilePath: Scalars['String'];
  readonly originalRelativeFilePath: Scalars['String'];
  readonly parent: Maybe<Node>;
  readonly pluginName: Scalars['String'];
  readonly relativeCompiledFilePath: Scalars['String'];
};

type SiteFunctionConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SiteFunctionEdge>;
  readonly group: ReadonlyArray<SiteFunctionGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SiteFunction>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SiteFunctionConnection_distinctArgs = {
  field: SiteFunctionFieldSelector;
};


type SiteFunctionConnection_groupArgs = {
  field: SiteFunctionFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SiteFunctionConnection_maxArgs = {
  field: SiteFunctionFieldSelector;
};


type SiteFunctionConnection_minArgs = {
  field: SiteFunctionFieldSelector;
};


type SiteFunctionConnection_sumArgs = {
  field: SiteFunctionFieldSelector;
};

type SiteFunctionEdge = {
  readonly next: Maybe<SiteFunction>;
  readonly node: SiteFunction;
  readonly previous: Maybe<SiteFunction>;
};

type SiteFunctionFieldSelector = {
  readonly absoluteCompiledFilePath: InputMaybe<FieldSelectorEnum>;
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly functionRoute: InputMaybe<FieldSelectorEnum>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly matchPath: InputMaybe<FieldSelectorEnum>;
  readonly originalAbsoluteFilePath: InputMaybe<FieldSelectorEnum>;
  readonly originalRelativeFilePath: InputMaybe<FieldSelectorEnum>;
  readonly parent: InputMaybe<NodeFieldSelector>;
  readonly pluginName: InputMaybe<FieldSelectorEnum>;
  readonly relativeCompiledFilePath: InputMaybe<FieldSelectorEnum>;
};

type SiteFunctionFilterInput = {
  readonly absoluteCompiledFilePath: InputMaybe<StringQueryOperatorInput>;
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly functionRoute: InputMaybe<StringQueryOperatorInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly matchPath: InputMaybe<StringQueryOperatorInput>;
  readonly originalAbsoluteFilePath: InputMaybe<StringQueryOperatorInput>;
  readonly originalRelativeFilePath: InputMaybe<StringQueryOperatorInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
  readonly pluginName: InputMaybe<StringQueryOperatorInput>;
  readonly relativeCompiledFilePath: InputMaybe<StringQueryOperatorInput>;
};

type SiteFunctionGroupConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SiteFunctionEdge>;
  readonly field: Scalars['String'];
  readonly fieldValue: Maybe<Scalars['String']>;
  readonly group: ReadonlyArray<SiteFunctionGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SiteFunction>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SiteFunctionGroupConnection_distinctArgs = {
  field: SiteFunctionFieldSelector;
};


type SiteFunctionGroupConnection_groupArgs = {
  field: SiteFunctionFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SiteFunctionGroupConnection_maxArgs = {
  field: SiteFunctionFieldSelector;
};


type SiteFunctionGroupConnection_minArgs = {
  field: SiteFunctionFieldSelector;
};


type SiteFunctionGroupConnection_sumArgs = {
  field: SiteFunctionFieldSelector;
};

type SiteFunctionSortInput = {
  readonly absoluteCompiledFilePath: InputMaybe<SortOrderEnum>;
  readonly children: InputMaybe<NodeSortInput>;
  readonly functionRoute: InputMaybe<SortOrderEnum>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly matchPath: InputMaybe<SortOrderEnum>;
  readonly originalAbsoluteFilePath: InputMaybe<SortOrderEnum>;
  readonly originalRelativeFilePath: InputMaybe<SortOrderEnum>;
  readonly parent: InputMaybe<NodeSortInput>;
  readonly pluginName: InputMaybe<SortOrderEnum>;
  readonly relativeCompiledFilePath: InputMaybe<SortOrderEnum>;
};

type SiteGraphqlTypegen = {
  readonly documentSearchPaths: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly generateOnBuild: Maybe<Scalars['Boolean']>;
  readonly typesOutputPath: Maybe<Scalars['String']>;
};

type SiteGraphqlTypegenFieldSelector = {
  readonly documentSearchPaths: InputMaybe<FieldSelectorEnum>;
  readonly generateOnBuild: InputMaybe<FieldSelectorEnum>;
  readonly typesOutputPath: InputMaybe<FieldSelectorEnum>;
};

type SiteGraphqlTypegenFilterInput = {
  readonly documentSearchPaths: InputMaybe<StringQueryOperatorInput>;
  readonly generateOnBuild: InputMaybe<BooleanQueryOperatorInput>;
  readonly typesOutputPath: InputMaybe<StringQueryOperatorInput>;
};

type SiteGraphqlTypegenSortInput = {
  readonly documentSearchPaths: InputMaybe<SortOrderEnum>;
  readonly generateOnBuild: InputMaybe<SortOrderEnum>;
  readonly typesOutputPath: InputMaybe<SortOrderEnum>;
};

type SiteGroupConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SiteEdge>;
  readonly field: Scalars['String'];
  readonly fieldValue: Maybe<Scalars['String']>;
  readonly group: ReadonlyArray<SiteGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<Site>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SiteGroupConnection_distinctArgs = {
  field: SiteFieldSelector;
};


type SiteGroupConnection_groupArgs = {
  field: SiteFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SiteGroupConnection_maxArgs = {
  field: SiteFieldSelector;
};


type SiteGroupConnection_minArgs = {
  field: SiteFieldSelector;
};


type SiteGroupConnection_sumArgs = {
  field: SiteFieldSelector;
};

type SitePage = Node & {
  readonly children: ReadonlyArray<Node>;
  readonly component: Scalars['String'];
  readonly componentChunkName: Scalars['String'];
  readonly id: Scalars['ID'];
  readonly internal: Internal;
  readonly internalComponentName: Scalars['String'];
  readonly matchPath: Maybe<Scalars['String']>;
  readonly pageContext: Maybe<Scalars['JSON']>;
  readonly parent: Maybe<Node>;
  readonly path: Scalars['String'];
  readonly pluginCreator: Maybe<SitePlugin>;
};

type SitePageConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SitePageEdge>;
  readonly group: ReadonlyArray<SitePageGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SitePage>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SitePageConnection_distinctArgs = {
  field: SitePageFieldSelector;
};


type SitePageConnection_groupArgs = {
  field: SitePageFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SitePageConnection_maxArgs = {
  field: SitePageFieldSelector;
};


type SitePageConnection_minArgs = {
  field: SitePageFieldSelector;
};


type SitePageConnection_sumArgs = {
  field: SitePageFieldSelector;
};

type SitePageEdge = {
  readonly next: Maybe<SitePage>;
  readonly node: SitePage;
  readonly previous: Maybe<SitePage>;
};

type SitePageFieldSelector = {
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly component: InputMaybe<FieldSelectorEnum>;
  readonly componentChunkName: InputMaybe<FieldSelectorEnum>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly internalComponentName: InputMaybe<FieldSelectorEnum>;
  readonly matchPath: InputMaybe<FieldSelectorEnum>;
  readonly pageContext: InputMaybe<FieldSelectorEnum>;
  readonly parent: InputMaybe<NodeFieldSelector>;
  readonly path: InputMaybe<FieldSelectorEnum>;
  readonly pluginCreator: InputMaybe<SitePluginFieldSelector>;
};

type SitePageFilterInput = {
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly component: InputMaybe<StringQueryOperatorInput>;
  readonly componentChunkName: InputMaybe<StringQueryOperatorInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly internalComponentName: InputMaybe<StringQueryOperatorInput>;
  readonly matchPath: InputMaybe<StringQueryOperatorInput>;
  readonly pageContext: InputMaybe<JSONQueryOperatorInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
  readonly path: InputMaybe<StringQueryOperatorInput>;
  readonly pluginCreator: InputMaybe<SitePluginFilterInput>;
};

type SitePageGroupConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SitePageEdge>;
  readonly field: Scalars['String'];
  readonly fieldValue: Maybe<Scalars['String']>;
  readonly group: ReadonlyArray<SitePageGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SitePage>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SitePageGroupConnection_distinctArgs = {
  field: SitePageFieldSelector;
};


type SitePageGroupConnection_groupArgs = {
  field: SitePageFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SitePageGroupConnection_maxArgs = {
  field: SitePageFieldSelector;
};


type SitePageGroupConnection_minArgs = {
  field: SitePageFieldSelector;
};


type SitePageGroupConnection_sumArgs = {
  field: SitePageFieldSelector;
};

type SitePageSortInput = {
  readonly children: InputMaybe<NodeSortInput>;
  readonly component: InputMaybe<SortOrderEnum>;
  readonly componentChunkName: InputMaybe<SortOrderEnum>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly internalComponentName: InputMaybe<SortOrderEnum>;
  readonly matchPath: InputMaybe<SortOrderEnum>;
  readonly pageContext: InputMaybe<SortOrderEnum>;
  readonly parent: InputMaybe<NodeSortInput>;
  readonly path: InputMaybe<SortOrderEnum>;
  readonly pluginCreator: InputMaybe<SitePluginSortInput>;
};

type SitePlugin = Node & {
  readonly browserAPIs: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly children: ReadonlyArray<Node>;
  readonly id: Scalars['ID'];
  readonly internal: Internal;
  readonly name: Maybe<Scalars['String']>;
  readonly nodeAPIs: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly packageJson: Maybe<Scalars['JSON']>;
  readonly parent: Maybe<Node>;
  readonly pluginFilepath: Maybe<Scalars['String']>;
  readonly pluginOptions: Maybe<Scalars['JSON']>;
  readonly resolve: Maybe<Scalars['String']>;
  readonly ssrAPIs: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly version: Maybe<Scalars['String']>;
};

type SitePluginConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SitePluginEdge>;
  readonly group: ReadonlyArray<SitePluginGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SitePlugin>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SitePluginConnection_distinctArgs = {
  field: SitePluginFieldSelector;
};


type SitePluginConnection_groupArgs = {
  field: SitePluginFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SitePluginConnection_maxArgs = {
  field: SitePluginFieldSelector;
};


type SitePluginConnection_minArgs = {
  field: SitePluginFieldSelector;
};


type SitePluginConnection_sumArgs = {
  field: SitePluginFieldSelector;
};

type SitePluginEdge = {
  readonly next: Maybe<SitePlugin>;
  readonly node: SitePlugin;
  readonly previous: Maybe<SitePlugin>;
};

type SitePluginFieldSelector = {
  readonly browserAPIs: InputMaybe<FieldSelectorEnum>;
  readonly children: InputMaybe<NodeFieldSelector>;
  readonly id: InputMaybe<FieldSelectorEnum>;
  readonly internal: InputMaybe<InternalFieldSelector>;
  readonly name: InputMaybe<FieldSelectorEnum>;
  readonly nodeAPIs: InputMaybe<FieldSelectorEnum>;
  readonly packageJson: InputMaybe<FieldSelectorEnum>;
  readonly parent: InputMaybe<NodeFieldSelector>;
  readonly pluginFilepath: InputMaybe<FieldSelectorEnum>;
  readonly pluginOptions: InputMaybe<FieldSelectorEnum>;
  readonly resolve: InputMaybe<FieldSelectorEnum>;
  readonly ssrAPIs: InputMaybe<FieldSelectorEnum>;
  readonly version: InputMaybe<FieldSelectorEnum>;
};

type SitePluginFilterInput = {
  readonly browserAPIs: InputMaybe<StringQueryOperatorInput>;
  readonly children: InputMaybe<NodeFilterListInput>;
  readonly id: InputMaybe<StringQueryOperatorInput>;
  readonly internal: InputMaybe<InternalFilterInput>;
  readonly name: InputMaybe<StringQueryOperatorInput>;
  readonly nodeAPIs: InputMaybe<StringQueryOperatorInput>;
  readonly packageJson: InputMaybe<JSONQueryOperatorInput>;
  readonly parent: InputMaybe<NodeFilterInput>;
  readonly pluginFilepath: InputMaybe<StringQueryOperatorInput>;
  readonly pluginOptions: InputMaybe<JSONQueryOperatorInput>;
  readonly resolve: InputMaybe<StringQueryOperatorInput>;
  readonly ssrAPIs: InputMaybe<StringQueryOperatorInput>;
  readonly version: InputMaybe<StringQueryOperatorInput>;
};

type SitePluginGroupConnection = {
  readonly distinct: ReadonlyArray<Scalars['String']>;
  readonly edges: ReadonlyArray<SitePluginEdge>;
  readonly field: Scalars['String'];
  readonly fieldValue: Maybe<Scalars['String']>;
  readonly group: ReadonlyArray<SitePluginGroupConnection>;
  readonly max: Maybe<Scalars['Float']>;
  readonly min: Maybe<Scalars['Float']>;
  readonly nodes: ReadonlyArray<SitePlugin>;
  readonly pageInfo: PageInfo;
  readonly sum: Maybe<Scalars['Float']>;
  readonly totalCount: Scalars['Int'];
};


type SitePluginGroupConnection_distinctArgs = {
  field: SitePluginFieldSelector;
};


type SitePluginGroupConnection_groupArgs = {
  field: SitePluginFieldSelector;
  limit: InputMaybe<Scalars['Int']>;
  skip: InputMaybe<Scalars['Int']>;
};


type SitePluginGroupConnection_maxArgs = {
  field: SitePluginFieldSelector;
};


type SitePluginGroupConnection_minArgs = {
  field: SitePluginFieldSelector;
};


type SitePluginGroupConnection_sumArgs = {
  field: SitePluginFieldSelector;
};

type SitePluginSortInput = {
  readonly browserAPIs: InputMaybe<SortOrderEnum>;
  readonly children: InputMaybe<NodeSortInput>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly name: InputMaybe<SortOrderEnum>;
  readonly nodeAPIs: InputMaybe<SortOrderEnum>;
  readonly packageJson: InputMaybe<SortOrderEnum>;
  readonly parent: InputMaybe<NodeSortInput>;
  readonly pluginFilepath: InputMaybe<SortOrderEnum>;
  readonly pluginOptions: InputMaybe<SortOrderEnum>;
  readonly resolve: InputMaybe<SortOrderEnum>;
  readonly ssrAPIs: InputMaybe<SortOrderEnum>;
  readonly version: InputMaybe<SortOrderEnum>;
};

type SiteSiteMetadata = {
  readonly description: Maybe<Scalars['String']>;
  readonly siteUrl: Maybe<Scalars['String']>;
  readonly title: Maybe<Scalars['String']>;
};

type SiteSiteMetadataFieldSelector = {
  readonly description: InputMaybe<FieldSelectorEnum>;
  readonly siteUrl: InputMaybe<FieldSelectorEnum>;
  readonly title: InputMaybe<FieldSelectorEnum>;
};

type SiteSiteMetadataFilterInput = {
  readonly description: InputMaybe<StringQueryOperatorInput>;
  readonly siteUrl: InputMaybe<StringQueryOperatorInput>;
  readonly title: InputMaybe<StringQueryOperatorInput>;
};

type SiteSiteMetadataSortInput = {
  readonly description: InputMaybe<SortOrderEnum>;
  readonly siteUrl: InputMaybe<SortOrderEnum>;
  readonly title: InputMaybe<SortOrderEnum>;
};

type SiteSortInput = {
  readonly buildTime: InputMaybe<SortOrderEnum>;
  readonly children: InputMaybe<NodeSortInput>;
  readonly graphqlTypegen: InputMaybe<SiteGraphqlTypegenSortInput>;
  readonly host: InputMaybe<SortOrderEnum>;
  readonly id: InputMaybe<SortOrderEnum>;
  readonly internal: InputMaybe<InternalSortInput>;
  readonly jsxRuntime: InputMaybe<SortOrderEnum>;
  readonly parent: InputMaybe<NodeSortInput>;
  readonly pathPrefix: InputMaybe<SortOrderEnum>;
  readonly polyfill: InputMaybe<SortOrderEnum>;
  readonly port: InputMaybe<SortOrderEnum>;
  readonly siteMetadata: InputMaybe<SiteSiteMetadataSortInput>;
  readonly trailingSlash: InputMaybe<SortOrderEnum>;
};

type SortOrderEnum =
  | 'ASC'
  | 'DESC';

type StringQueryOperatorInput = {
  readonly eq: InputMaybe<Scalars['String']>;
  readonly glob: InputMaybe<Scalars['String']>;
  readonly in: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']>>>;
  readonly ne: InputMaybe<Scalars['String']>;
  readonly nin: InputMaybe<ReadonlyArray<InputMaybe<Scalars['String']>>>;
  readonly regex: InputMaybe<Scalars['String']>;
};

type TransformOptions = {
  readonly cropFocus: InputMaybe<ImageCropFocus>;
  readonly duotone: InputMaybe<DuotoneGradient>;
  readonly fit: InputMaybe<ImageFit>;
  readonly grayscale: InputMaybe<Scalars['Boolean']>;
  readonly rotate: InputMaybe<Scalars['Int']>;
  readonly trim: InputMaybe<Scalars['Float']>;
};

type WebPOptions = {
  readonly quality: InputMaybe<Scalars['Int']>;
};

type BlogPageQueryQueryVariables = Exact<{ [key: string]: never; }>;


type BlogPageQueryQuery = { readonly allSanityPost: { readonly nodes: ReadonlyArray<{ readonly id: string, readonly title: string | null, readonly publishedAt: string | null, readonly _rawBody: Record<string, unknown> | null, readonly author: string | null, readonly slug: { readonly current: string | null } | null, readonly image: { readonly asset: { readonly description: string | null, readonly altText: string | null, readonly title: string | null, readonly gatsbyImageData: import('gatsby-plugin-image').IGatsbyImageData } | null } | null }> } };

type GatsbyImageSharpFixedFragment = { readonly base64: string | null, readonly width: number, readonly height: number, readonly src: string, readonly srcSet: string };

type GatsbyImageSharpFixed_noBase64Fragment = { readonly width: number, readonly height: number, readonly src: string, readonly srcSet: string };

type GatsbyImageSharpFixed_tracedSVGFragment = { readonly tracedSVG: string | null, readonly width: number, readonly height: number, readonly src: string, readonly srcSet: string };

type GatsbyImageSharpFixed_withWebpFragment = { readonly base64: string | null, readonly width: number, readonly height: number, readonly src: string, readonly srcSet: string, readonly srcWebp: string | null, readonly srcSetWebp: string | null };

type GatsbyImageSharpFixed_withWebp_noBase64Fragment = { readonly width: number, readonly height: number, readonly src: string, readonly srcSet: string, readonly srcWebp: string | null, readonly srcSetWebp: string | null };

type GatsbyImageSharpFixed_withWebp_tracedSVGFragment = { readonly tracedSVG: string | null, readonly width: number, readonly height: number, readonly src: string, readonly srcSet: string, readonly srcWebp: string | null, readonly srcSetWebp: string | null };

type GatsbyImageSharpFluidFragment = { readonly base64: string | null, readonly aspectRatio: number, readonly src: string, readonly srcSet: string, readonly sizes: string };

type GatsbyImageSharpFluid_noBase64Fragment = { readonly aspectRatio: number, readonly src: string, readonly srcSet: string, readonly sizes: string };

type GatsbyImageSharpFluid_tracedSVGFragment = { readonly tracedSVG: string | null, readonly aspectRatio: number, readonly src: string, readonly srcSet: string, readonly sizes: string };

type GatsbyImageSharpFluid_withWebpFragment = { readonly base64: string | null, readonly aspectRatio: number, readonly src: string, readonly srcSet: string, readonly srcWebp: string | null, readonly srcSetWebp: string | null, readonly sizes: string };

type GatsbyImageSharpFluid_withWebp_noBase64Fragment = { readonly aspectRatio: number, readonly src: string, readonly srcSet: string, readonly srcWebp: string | null, readonly srcSetWebp: string | null, readonly sizes: string };

type GatsbyImageSharpFluid_withWebp_tracedSVGFragment = { readonly tracedSVG: string | null, readonly aspectRatio: number, readonly src: string, readonly srcSet: string, readonly srcWebp: string | null, readonly srcSetWebp: string | null, readonly sizes: string };

type GatsbyImageSharpFluidLimitPresentationSizeFragment = { readonly maxHeight: number, readonly maxWidth: number };

type SinglePostQueryQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


type SinglePostQueryQuery = { readonly sanityPost: { readonly title: string | null, readonly publishedAt: string | null, readonly _rawBody: Record<string, unknown> | null, readonly author: string | null, readonly image: { readonly asset: { readonly description: string | null, readonly altText: string | null, readonly url: string | null, readonly title: string | null, readonly gatsbyImageData: import('gatsby-plugin-image').IGatsbyImageData } | null } | null } | null };

type SourcingAllPostsQueryVariables = Exact<{ [key: string]: never; }>;


type SourcingAllPostsQuery = { readonly allSanityPost: { readonly nodes: ReadonlyArray<{ readonly title: string | null, readonly slug: { readonly current: string | null } | null }> } };


}
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/helpers.ts
========================================

import { pathPrefix } from "./constants"

const stripTrailingSlash = (str: string) =>
  str.endsWith("/") ? str.slice(0, -1) : str

export const cleanSlug = (str: string) =>
  stripTrailingSlash(str.replace(pathPrefix, ""))

export const getSanityImageUrl = (ref: string) => {
  if (!ref) return null

  const [, id, dimensions, format] =
    ref.match(/image-([^-]+)-(\d+x\d+)-(.+)/) || []
  if (!id || !dimensions || !format) return null

  return `https://cdn.sanity.io/images/ze02ljgl/post-blog/${id}-${dimensions}.${format}`
}

export const fromBodyRawToExcerpt = (bodyRaw: any) =>
  bodyRaw
    .filter((c: any) => c._type === "block")
    .map((c: any) => c.children.map((child: any) => child?.text ?? "").join(""))
    .join(" ")
    .slice(0, 200)
    .concat("...")
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/templates/post.tsx
========================================

// src/templates/post.tsx
import { PageProps, HeadFC, graphql } from "gatsby"
import { SEO } from "../components/seo"
import { IGatsbyImageData } from "gatsby-plugin-image"
import React from "react"
import DefaultLayout from "../components/default-layout"
import Post from "../components/post"

type PostData = {
  sanityPost: {
    title: string
    publishedAt: string
    _rawBody: any
    author: string
    image: {
      asset: {
        description: string
        altText: string
        title: string
        gatsbyImageData: IGatsbyImageData
        url: string
      }
    }
  }
}

type PostPageContext = {
  slug: string
  prevSlug: string | null
  prevTitle: string | null
  nextSlug: string | null
  nextTitle: string | null
}

const PostTemplate: React.FC<PageProps<PostData, PostPageContext>> = ({
  data,
  pageContext
}) => {
  const post = data.sanityPost

  if (!post) {
    return <DefaultLayout><p>Post non trovato</p></DefaultLayout>
  }

  const renderTitle = post.title || "Loading..."
  const renderPublishedAt = post.publishedAt || null
  const renderBody = post._rawBody || null
  const author = post.author || null

  const mainImgAlt = post.image?.asset?.altText || ""
  const gatsbyImage = post.image?.asset?.gatsbyImageData || undefined
  const renderImageUrl = null

  return (
    <DefaultLayout>
      <Post
        renderTitle={renderTitle}
        renderPublishedAt={renderPublishedAt ?? ""}
        gatsbyImage={gatsbyImage}
        renderImageUrl={renderImageUrl ?? ""}
        renderBody={renderBody}
        author={author ?? ""}
        coverImageAlt={mainImgAlt}
        prevPost={pageContext.prevSlug ? { slug: pageContext.prevSlug, title: pageContext.prevTitle } : null}
        nextPost={pageContext.nextSlug ? { slug: pageContext.nextSlug, title: pageContext.nextTitle } : null}
      />
    </DefaultLayout>
  )
}

export default PostTemplate

// La Head query riceve i dati dalla query principale
export const Head: HeadFC<PostData, PostPageContext> = ({ location, data }) => {
  const post = data.sanityPost
  return (
    <SEO
      title={`Gruppo Natura Lentiai - ${post?.title}`}
      description={post?.image?.asset?.description || post?.image?.asset?.altText}
      pathname={location.pathname}
      image={post?.image?.asset?.url}
    />
  )
}

// QUESTA √à LA MAGIA: Gatsby usa la variabile $slug dal pageContext per cercare il singolo post
export const query = graphql`
  query SinglePostQuery($slug: String!) {
    sanityPost(slug: { current: { eq: $slug } }) {
      title
      publishedAt
      _rawBody
      author
      image {
        asset {
          description
          altText
          url
          title
          gatsbyImageData(
            width: 1200
            placeholder: BLURRED
            formats: [AUTO, WEBP, AVIF]
          )
        }
      }
    }
  }
`Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/sociale/ideali.tsx
========================================

import * as React from "react"
import type { HeadFC, PageProps } from "gatsby"
import DefaultLayout from "../../components/default-layout"
import WorkInProgress from "../../components/work-in-progress"

const NostriIdealiPage: React.FC<PageProps> = () => {
  return (
    <DefaultLayout>
      <WorkInProgress />
    </DefaultLayout>
  )
}

export default NostriIdealiPage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Gruppo Natura Lentiai - I nostri Ideali" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/sociale/index.tsx
========================================

import * as React from "react"
import type { HeadFC, PageProps } from "gatsby"
import DefaultLayout from "../../components/default-layout"
import WorkInProgress from "../../components/work-in-progress"

const SocialePage: React.FC<PageProps> = () => {
  return (
    <DefaultLayout>
      <WorkInProgress />
    </DefaultLayout>
  )
}

export default SocialePage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Gruppo Natura Lentiai - Sociale" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/sociale/mobilit√†-sostenibile.tsx
========================================

import * as React from "react"
import { graphql, useStaticQuery, type HeadFC, type PageProps } from "gatsby"
import DefaultLayout from "../../components/default-layout"
import ContentToComponent from "../../components/pagedata-text-components"
import MobileContentToComponent from "../../components/mobile-pagedata-text-components"
import { GatsbyImage, getImage } from "gatsby-plugin-image"
import { DataJSONType, ImageData } from "../../types"
import dataJSON from "../../../content/sociale/mobilit√†.json"
import * as T from "./../../components/typography"

const Mobilit√†SostenibilePage: React.FC<PageProps> = () => {
  const data = useStaticQuery(graphql`
    query {
      allImageMetadataJson(filter: { tags: { in: ["mobilit√†"] } }) {
        nodes {
          title
          description
          fileName
          tags
          copyright
          alt
        }
      }
      allFile(filter: { sourceInstanceName: { eq: "images" } }) {
        nodes {
          base
          childImageSharp {
            gatsbyImageData(
              width: 1600
              placeholder: BLURRED
              formats: [AUTO, WEBP, AVIF]
            )
          }
        }
      }
    }
  `)

  const content = dataJSON.mobilit√† as DataJSONType
  if (!content)
    return (
      <DefaultLayout>
        <T.H1>Contenuto non trovato!</T.H1>
      </DefaultLayout>
    )

  // Map metadata and image nodes
  const metadata = data.allImageMetadataJson.nodes
  const images = data.allFile.nodes

  // Match images to metadata using the fileName
  const filteredImages = metadata.map((meta: any) => {
    const image = images.find((img: any) => img.base === meta.fileName)
    return {
      ...meta,
      image: image ? getImage(image.childImageSharp) : null,
    }
  }) as ImageData[]

  const mapUp = getImage(
    images.find((img: any) => img.base === "anello-ciclopedonale-lentiai-00.jpeg")
      .childImageSharp,
  )
  const mapDown = getImage(
    images.find((img: any) => img.base === "anello-ciclopedonale-lentiai-01.jpeg")
      .childImageSharp,
  )

  return (
    <DefaultLayout>
      <ContentToComponent pageData={content} images={filteredImages} />
      <MobileContentToComponent pageData={content} images={filteredImages} />
      <div style={{ display: "flex", flexDirection: "column", alignItems: "center", margin: "2em", gap: "2em" }}>
        {mapUp && (
          <GatsbyImage
            image={mapUp}
            alt={"Informazioni utili dell'anello Ciclopedonale di Lentiai Fronte"}
            style={{ borderRadius: "8px", marginTop: 4, maxWidth: 1600 }}
          />
        )}
        {mapDown && (
          <GatsbyImage
            image={mapDown}
            alt={"Cartina dell'anello Ciclopedonale di Lentiai"}
            style={{ borderRadius: "8px", marginTop: 4, maxWidth: 1600 }}
          />
        )}
      </div>
    </DefaultLayout>
  )
}

export default Mobilit√†SostenibilePage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Gruppo Natura Lentiai - Mobilit√† sostenibile" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/sociale/rifiuti.tsx
========================================

import * as React from "react"
import type { HeadFC, PageProps } from "gatsby"
import DefaultLayout from "../../components/default-layout"
import WorkInProgress from "../../components/work-in-progress"

const RifiutiPage: React.FC<PageProps> = () => {
  return (
    <DefaultLayout>
      <WorkInProgress />
    </DefaultLayout>
  )
}

export default RifiutiPage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Gruppo Natura Lentiai - Rifiuti" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/sociale/educazione-ambientale.tsx
========================================

import * as React from "react"
import type { HeadFC, PageProps } from "gatsby"
import DefaultLayout from "../../components/default-layout"
import WorkInProgress from "../../components/work-in-progress"

const EducazioneAmbientalePage: React.FC<PageProps> = () => {
  return (
    <DefaultLayout>
      <WorkInProgress />
    </DefaultLayout>
  )
}

export default EducazioneAmbientalePage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Gruppo Natura Lentiai - Educazione ambientale" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/chi-siamo.tsx
========================================

import * as React from "react"
import { graphql, useStaticQuery, type HeadFC, type PageProps } from "gatsby"
import DefaultLayout from "../components/default-layout"
import { getImage } from "gatsby-plugin-image"
import Carousel from "../components/carousel"
import { DataJSONType, ImageData } from "../types"
import dataJSON from "../../content/chi-siamo.json"
import ContentToComponent from "../components/pagedata-text-components"
import MobileContentToComponent from "../components/mobile-pagedata-text-components"
import * as T from "../components/typography"

const ChiSiamoPage: React.FC<PageProps> = () => {
  const data = useStaticQuery(graphql`
    query {
      allImageMetadataJson(filter: { tags: { in: ["chi-siamo"] } }) {
        nodes {
          title
          description
          fileName
          tags
          copyright
          alt
        }
      }
      allFile(filter: { sourceInstanceName: { eq: "images" } }) {
        nodes {
          base
          childImageSharp {
            gatsbyImageData(
              width: 1400
              placeholder: BLURRED
              formats: [AUTO, WEBP, AVIF]
            )
          }
        }
      }
    }
  `)

  // Map metadata and image nodes
  const metadata = data.allImageMetadataJson.nodes
  const images = data.allFile.nodes

  // Match images to metadata using the fileName
  const filteredImages = metadata.map((meta: any) => {
    const image = images.find((img: any) => img.base === meta.fileName)
    return {
      ...meta,
      ...image,
      image: image ? getImage(image.childImageSharp) : null,
    }
  }) as ImageData[]

  const content = dataJSON["chi-siamo"] as DataJSONType
  if (!content)
    return (
      <DefaultLayout>
        <T.H1>Contenuto non trovato!</T.H1>
      </DefaultLayout>
    )

  return (
    <DefaultLayout>
      <ContentToComponent pageData={content} images={filteredImages} />
      <MobileContentToComponent pageData={content} images={filteredImages} />
      <Carousel images={filteredImages} />
    </DefaultLayout>
  )
}

export default ChiSiamoPage

import { SEO } from "../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Gruppo Natura Lentiai - Chi siamo" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/404.tsx
========================================

import * as React from "react"
import type { HeadFC, PageProps } from "gatsby"
import DefaultLayout from "../components/default-layout"
import Component404 from "../components/404"

const IndexPage: React.FC<PageProps> = () => {
  return (
    <DefaultLayout>
      <Component404 />
    </DefaultLayout>
  )
}

export default IndexPage

import { SEO } from "../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Gruppo Natura Lentiai - 404" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/cookies-policy.tsx
========================================

import * as React from "react"
import { type HeadFC, type PageProps } from "gatsby"
import DefaultLayout from "../components/default-layout"
import { DataJSONType } from "../types"
import dataJSON from "../../content/cookies-policy.json"
import ContentToComponent from "../components/pagedata-text-components"
import MobileContentToComponent from "../components/mobile-pagedata-text-components"
import * as T from "../components/typography"

const CookiesPolicyPage: React.FC<PageProps> = () => {
  const content = dataJSON["cookies-policy"] as DataJSONType
  if (!content)
    return (
      <DefaultLayout>
        <T.H1>Contenuto non trovato!</T.H1>
      </DefaultLayout>
    )

  return (
    <DefaultLayout>
      <ContentToComponent pageData={content} images={[]} />
      <MobileContentToComponent pageData={content} images={[]} />
    </DefaultLayout>
  )
}

export default CookiesPolicyPage

import { SEO } from "../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Gruppo Natura Lentiai - Politica sui cookie" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/contatti.tsx
========================================

import * as React from "react"
import type { HeadFC, PageProps } from "gatsby"
import DefaultLayout from "../components/default-layout"
import ContactUs from "../components/contact-us"

const ContactPage: React.FC<PageProps> = () => {
  return (
    <DefaultLayout>
      <ContactUs />
    </DefaultLayout>
  )
}

export default ContactPage

import { SEO } from "../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Gruppo Natura Lentiai - Contattaci" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/index.tsx
========================================

import { graphql, useStaticQuery, type HeadFC, type PageProps } from "gatsby"
import { getImage } from "gatsby-plugin-image"
import * as React from "react"
import DefaultLayout from "../components/default-layout"
import HeroMain from "../components/hero-main"
import { ImageData } from "../types"

const content = {
  quote:
    "‚ÄúIl Creato non √® una propriet√† di cui possiamo spadroneggiare a nostro piacimento; n√©, tanto meno, √® una propriet√† solo di alcuni, di pochi: il Creato √® un dono, un dono meraviglioso che Dio ci ha dato perch√© ne abbiamo cura e lo utilizziamo a beneficio di tutti, sempre con grande rispetto e gratitudine.‚Äù",
  signature: "Papa Francesco",
}

const IndexPage: React.FC<PageProps> = () => {
  const data = useStaticQuery(graphql`
    query {
      allImageMetadataJson(filter: { tags: { in: ["main"] } }) {
        nodes {
          title
          description
          fileName
          tags
          copyright
          alt
        }
      }
      allFile(filter: { sourceInstanceName: { eq: "images" } }) {
        nodes {
          base
          childImageSharp {
            gatsbyImageData(
              width: 1050
              placeholder: BLURRED
              formats: [AUTO, WEBP, AVIF]
            )
          }
        }
      }
    }
  `)

  // Map metadata and image nodes
  const metadata = data.allImageMetadataJson.nodes
  const images = data.allFile.nodes

  // Match images to metadata using the fileName
  const filteredImages = metadata.map((meta: any) => {
    const image = images.find((img: any) => img.base === meta.fileName)
    return {
      ...meta,
      image: image ? getImage(image.childImageSharp) : null,
    }
  }) as ImageData[]
  const coverImage = filteredImages.find(
    img => img.fileName === "Fioritura02.jpg",
  )

  return (
    <DefaultLayout>
      {coverImage && <HeroMain content={content} img={coverImage} />}
    </DefaultLayout>
  )
}

export default IndexPage

import { SEO } from "../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Gruppo Natura Lentiai" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/laghetti/rimontarte.tsx
========================================

import { graphql, useStaticQuery, type HeadFC, type PageProps } from "gatsby"
import { GatsbyImage, getImage } from "gatsby-plugin-image"
import * as React from "react"
import dataJSON from "../../../content/laghetti/rimontarte.json"
import DefaultLayout from "../../components/default-layout"
import ContentToComponent from "../../components/pagedata-text-components"
import { DataJSONType, ImageData } from "../../types"
import * as T from "./../../components/typography"
import MobileContentToComponent from "../../components/mobile-pagedata-text-components"

const LaghettiRimontartePage: React.FC<PageProps> = () => {
  const data = useStaticQuery(graphql`
    query {
      allImageMetadataJson(filter: { tags: { in: ["laghetti-rimontarte"] } }) {
        nodes {
          title
          description
          fileName
          tags
          copyright
          alt
        }
      }
      allFile(filter: { sourceInstanceName: { eq: "images" } }) {
        nodes {
          base
          childImageSharp {
            gatsbyImageData(
              width: 1200
              placeholder: BLURRED
              formats: [AUTO, WEBP, AVIF]
            )
          }
        }
      }
    }
  `)

  const content = dataJSON.rimontarte as DataJSONType
  if (!content)
    return (
      <DefaultLayout>
        <T.H1>Contenuto non trovato!</T.H1>
      </DefaultLayout>
    )

  // Map metadata and image nodes
  const metadata = data.allImageMetadataJson.nodes
  const images = data.allFile.nodes

  // Match images to metadata using the fileName
  const filteredImages = metadata.map((meta: any) => {
    const image = images.find((img: any) => img.base === meta.fileName)
    return {
      ...meta,
      image: image ? getImage(image.childImageSharp) : null,
    }
  }) as ImageData[]
  const logoImg = getImage(
    images.find((img: any) => img.base === "rimontarte-logo-transparent.png")
      .childImageSharp,
  )

  return (
    <DefaultLayout>
      <div style={{ justifySelf: "center" }}>
        {logoImg && (
          <GatsbyImage
            image={logoImg}
            alt={"Rimontarte Logo"}
            style={{ borderRadius: "8px", marginTop: 4, maxWidth: 400 }}
          />
        )}
      </div>
      <ContentToComponent pageData={content} images={filteredImages} />
      <MobileContentToComponent pageData={content} images={filteredImages} />
    </DefaultLayout>
  )
}

export default LaghettiRimontartePage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Laghetti della Rimonta - Rimontarte" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/laghetti/galleria.tsx
========================================

import { graphql, useStaticQuery, type HeadFC, type PageProps } from "gatsby"
import { getImage } from "gatsby-plugin-image"
import * as React from "react"
import Carousel from "../../components/carousel"
import DefaultLayout from "../../components/default-layout"
import { ImageData } from "../../types"

const LaghettiGalleriaPage: React.FC<PageProps> = () => {
  const data = useStaticQuery(graphql`
    query {
      allImageMetadataJson(filter: { tags: { in: ["laghetti"] } }) {
        nodes {
          title
          description
          fileName
          tags
          copyright
          alt
        }
      }
      allFile(filter: { sourceInstanceName: { eq: "images" } }) {
        nodes {
          base
          childImageSharp {
            gatsbyImageData(
              width: 1400
              placeholder: BLURRED
              formats: [AUTO, WEBP, AVIF]
            )
          }
        }
      }
    }
  `)

  // Map metadata and image nodes
  const metadata = data.allImageMetadataJson.nodes
  const images = data.allFile.nodes

  // Match images to metadata using the fileName
  const filteredImages = metadata.map((meta: any) => {
    const image = images.find((img: any) => img.base === meta.fileName)
    return {
      ...meta,
      ...image,
      image: image ? getImage(image.childImageSharp) : null,
    }
  }) as ImageData[]

  return (
    <DefaultLayout>
      <Carousel images={filteredImages} />
    </DefaultLayout>
  )
}

export default LaghettiGalleriaPage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Laghetti della Rimonta - Galleria" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/laghetti/index.tsx
========================================

import { graphql, useStaticQuery, type HeadFC, type PageProps } from "gatsby"
import { GatsbyImage, getImage } from "gatsby-plugin-image"
import * as React from "react"
import dataJSON from "../../../content/laghetti/index.json"
import ButtonLink from "../../components/button-link"
import DefaultLayout from "../../components/default-layout"
import MobileContentToComponent from "../../components/mobile-pagedata-text-components"
import ContentToComponent from "../../components/pagedata-text-components"
import { DataJSONType, ImageData } from "../../types"
import * as T from "./../../components/typography"

const LaghettiPage: React.FC<PageProps> = () => {
  const data = useStaticQuery(graphql`
    query {
      allImageMetadataJson(filter: { tags: { in: ["laghetti-main"] } }) {
        nodes {
          title
          description
          fileName
          tags
          copyright
          alt
        }
      }
      allFile(filter: { sourceInstanceName: { eq: "images" } }) {
        nodes {
          base
          childImageSharp {
            gatsbyImageData(
              width: 1200
              placeholder: BLURRED
              formats: [AUTO, WEBP, AVIF]
            )
          }
        }
      }
    }
  `)

  const content = dataJSON.index as DataJSONType
  if (!content)
    return (
      <DefaultLayout>
        <T.H1>Contenuto non trovato!</T.H1>
      </DefaultLayout>
    )

  // Map metadata and image nodes
  const metadata = data.allImageMetadataJson.nodes
  const images = data.allFile.nodes

  // Match images to metadata using the fileName
  const filteredImages = metadata.map((meta: any) => {
    const image = images.find((img: any) => img.base === meta.fileName)
    return {
      ...meta,
      image: image ? getImage(image.childImageSharp) : null,
    }
  }) as ImageData[]
  const coverUp = getImage(
    images.find((img: any) => img.base === "rimonta-cover-01.jpg")
      .childImageSharp,
  )
  const coverDown = getImage(
    images.find((img: any) => img.base === "rimonta-cover-02.jpg")
      .childImageSharp,
  )

  return (
    <DefaultLayout>
      <div style={{ padding: 16 }}>
        <div style={{ justifySelf: "center" }}>
          {coverUp && (
            <GatsbyImage
              image={coverUp}
              alt={"Una passerella in legno con dietro il torrente Rimonta"}
              style={{ borderRadius: "8px", marginTop: 4, maxWidth: 1200 }}
            />
          )}
          <T.P4 $textAlign="center">Foto di Walter Argenta</T.P4>
        </div>
        <ContentToComponent pageData={content} images={filteredImages} />
        <MobileContentToComponent pageData={content} images={filteredImages} />
        <ButtonLink to="mappe" label="Vai a mappe!" />
        <div style={{ justifySelf: "center" }}>
          {coverDown && (
            <GatsbyImage
              image={coverDown}
              alt={"Un panorama invernale dei laghetti della Rimonta"}
              style={{ borderRadius: "8px", marginTop: 4, maxWidth: 1200 }}
            />
          )}
          <T.P4 $textAlign="center">Foto di Walter Argenta</T.P4>
        </div>
      </div>
    </DefaultLayout>
  )
}

export default LaghettiPage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Gruppo Natura Lentiai - Laghetti della Rimonta" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/laghetti/natura.tsx
========================================

import { graphql, useStaticQuery, type HeadFC, type PageProps } from "gatsby"
import { getImage } from "gatsby-plugin-image"
import * as React from "react"
import dataJSON from "../../../content/laghetti/natura.json"
import DefaultLayout from "../../components/default-layout"
import ContentToComponent from "../../components/pagedata-text-components"
import { DataJSONType, ImageData } from "../../types"
import * as T from "./../../components/typography"
import MobileContentToComponent from "../../components/mobile-pagedata-text-components"

const LaghettiNaturaPage: React.FC<PageProps> = () => {
  const data = useStaticQuery(graphql`
    query {
      allImageMetadataJson(filter: { tags: { in: ["laghetti-natura"] } }) {
        nodes {
          title
          description
          fileName
          tags
          copyright
          alt
        }
      }
      allFile(filter: { sourceInstanceName: { eq: "images" } }) {
        nodes {
          base
          childImageSharp {
            gatsbyImageData(
              width: 600
              placeholder: BLURRED
              formats: [AUTO, WEBP, AVIF]
            )
          }
        }
      }
    }
  `)

  const content = dataJSON.natura as DataJSONType
  if (!content)
    return (
      <DefaultLayout>
        <T.H1>Contenuto non trovato!</T.H1>
      </DefaultLayout>
    )

  // Map metadata and image nodes
  const metadata = data.allImageMetadataJson.nodes
  const images = data.allFile.nodes

  // Match images to metadata using the fileName
  const filteredImages = metadata.map((meta: any) => {
    const image = images.find((img: any) => img.base === meta.fileName)
    return {
      ...meta,
      image: image ? getImage(image.childImageSharp) : null,
    }
  }) as ImageData[]

  return (
    <DefaultLayout>
      <ContentToComponent pageData={content} images={filteredImages} />
      <MobileContentToComponent pageData={content} images={filteredImages} />
    </DefaultLayout>
  )
}

export default LaghettiNaturaPage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Laghetti della Rimonta - Natura" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/laghetti/mappe.tsx
========================================

import { graphql, useStaticQuery, type HeadFC, type PageProps } from "gatsby"
import { getImage } from "gatsby-plugin-image"
import * as React from "react"
import dataJSON from "../../../content/laghetti/mappe.json"
import DefaultLayout from "../../components/default-layout"
import ContentToComponent from "../../components/pagedata-text-components"
import { DataJSONType, ImageData, Location } from "../../types"
import * as T from "./../../components/typography"
import MapComponent from "../../components/map-laghetti"
import MobileContentToComponent from "../../components/mobile-pagedata-text-components"
import paths from "./../../data/paths/laghetti"
import AccessWarnings from "../../components/access-warnings"

const markersMap: Location[] = [
  {
    type: "start",
    name: "Inizio del percorso",
    lat: 46.04923742844764,
    lon: 12.02636613390803,
  },
  {
    type: "park",
    iconType: "park",
    name: "Parcheggio",
    lat: 46.046873575356855,
    lon: 12.024898230581327,
  },
]

const LaghettiMappePage: React.FC<PageProps> = () => {
  const data = useStaticQuery(graphql`
    query {
      allImageMetadataJson(filter: { tags: { in: ["laghetti-mappe"] } }) {
        nodes {
          title
          description
          fileName
          tags
          copyright
          alt
        }
      }
      allFile(filter: { sourceInstanceName: { eq: "images" } }) {
        nodes {
          base
          childImageSharp {
            gatsbyImageData(
              width: 1200
              placeholder: BLURRED
              formats: [AUTO, WEBP, AVIF]
            )
          }
        }
      }
    }
  `)

  const content = dataJSON.mappe as DataJSONType
  if (!content)
    return (
      <DefaultLayout>
        <T.H1>Contenuto non trovato!</T.H1>
      </DefaultLayout>
    )

  // Map metadata and image nodes
  const metadata = data.allImageMetadataJson.nodes
  const images = data.allFile.nodes

  // Match images to metadata using the fileName
  const filteredImages = metadata.map((meta: any) => {
    const image = images.find((img: any) => img.base === meta.fileName)
    return {
      ...meta,
      image: image ? getImage(image.childImageSharp) : null,
    }
  }) as ImageData[]

  return (
    <DefaultLayout>
      <ContentToComponent pageData={content} images={filteredImages} />
      <MobileContentToComponent pageData={content} images={filteredImages} />
      <AccessWarnings type="laghetti" />
      <MapComponent markers={markersMap} paths={paths} />
    </DefaultLayout>
  )
}

export default LaghettiMappePage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Laghetti della Rimonta - Mappe" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/laghetti/storia.tsx
========================================

import { graphql, useStaticQuery, type HeadFC, type PageProps } from "gatsby"
import { getImage } from "gatsby-plugin-image"
import * as React from "react"
import dataJSON from "../../../content/laghetti/storia.json"
import DefaultLayout from "../../components/default-layout"
import ContentToComponent from "../../components/pagedata-text-components"
import { DataJSONType, ImageData } from "../../types"
import * as T from "./../../components/typography"
import MobileContentToComponent from "../../components/mobile-pagedata-text-components"

const LaghettiStoriaPage: React.FC<PageProps> = () => {
  const data = useStaticQuery(graphql`
    query {
      allImageMetadataJson(filter: { tags: { in: ["laghetti-storia"] } }) {
        nodes {
          title
          description
          fileName
          tags
          copyright
          alt
        }
      }
      allFile(filter: { sourceInstanceName: { eq: "images" } }) {
        nodes {
          base
          childImageSharp {
            gatsbyImageData(
              width: 600
              placeholder: BLURRED
              formats: [AUTO, WEBP, AVIF]
            )
          }
        }
      }
    }
  `)

  const content = dataJSON.storia as DataJSONType
  if (!content)
    return (
      <DefaultLayout>
        <T.H1>Contenuto non trovato!</T.H1>
      </DefaultLayout>
    )

  // Map metadata and image nodes
  const metadata = data.allImageMetadataJson.nodes
  const images = data.allFile.nodes

  // Match images to metadata using the fileName
  const filteredImages = metadata.map((meta: any) => {
    const image = images.find((img: any) => img.base === meta.fileName)
    return {
      ...meta,
      image: image ? getImage(image.childImageSharp) : null,
    }
  }) as ImageData[]

  return (
    <DefaultLayout>
      <ContentToComponent pageData={content} images={filteredImages} />
      <MobileContentToComponent pageData={content} images={filteredImages} />
    </DefaultLayout>
  )
}

export default LaghettiStoriaPage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Laghetti della Rimonta - Storia" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/narcisi/progetto.tsx
========================================

import { graphql, useStaticQuery, type HeadFC, type PageProps } from "gatsby"
import { getImage } from "gatsby-plugin-image"
import * as React from "react"
import dataJSON from "../../../content/narcisi/progetto.json"
import DefaultLayout from "../../components/default-layout"
import MobileContentToComponent from "../../components/mobile-pagedata-text-components"
import ContentToComponent from "../../components/pagedata-text-components"
import { DataJSONType, ImageData } from "../../types"
import * as T from "./../../components/typography"

const NarcisiProgettoPage: React.FC<PageProps> = () => {
  const data = useStaticQuery(graphql`
    query {
      allImageMetadataJson(filter: { tags: { in: ["narcisi-progetto"] } }) {
        nodes {
          title
          description
          fileName
          tags
          copyright
          alt
        }
      }
      allFile(filter: { sourceInstanceName: { eq: "images" } }) {
        nodes {
          base
          childImageSharp {
            gatsbyImageData(
              width: 1200
              placeholder: BLURRED
              formats: [AUTO, WEBP, AVIF]
            )
          }
        }
      }
    }
  `)

  const content = dataJSON.progetto as DataJSONType
  if (!content)
    return (
      <DefaultLayout>
        <T.H1>Contenuto non trovato!</T.H1>
      </DefaultLayout>
    )

  // Map metadata and image nodes
  const metadata = data.allImageMetadataJson.nodes
  const images = data.allFile.nodes

  // Match images to metadata using the fileName
  const filteredImages = metadata.map((meta: any) => {
    const image = images.find((img: any) => img.base === meta.fileName)
    return {
      ...meta,
      image: image ? getImage(image.childImageSharp) : null,
    }
  }) as ImageData[]

  return (
    <DefaultLayout>
      <ContentToComponent pageData={content} images={filteredImages} />
      <MobileContentToComponent pageData={content} images={filteredImages} />
    </DefaultLayout>
  )
}

export default NarcisiProgettoPage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Progetto Narcisi - Progetto" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/narcisi/valbelluna.tsx
========================================

import * as React from "react"
import { graphql, useStaticQuery, type HeadFC, type PageProps } from "gatsby"
import DefaultLayout from "../../components/default-layout"
import { getImage } from "gatsby-plugin-image"
import { DataJSONType, ImageData } from "../../types"
import dataJSON from "../../../content/narcisi/valbelluna.json"
import * as T from "./../../components/typography"
import ContentToComponent from "../../components/pagedata-text-components"
import MobileContentToComponent from "../../components/mobile-pagedata-text-components"

const NarcisiValbellunaPage: React.FC<PageProps> = () => {
  const data = useStaticQuery(graphql`
    query {
      allImageMetadataJson(filter: { tags: { in: ["narcisi-valbelluna"] } }) {
        nodes {
          title
          description
          fileName
          tags
          copyright
          alt
        }
      }
      allFile(filter: { sourceInstanceName: { eq: "images" } }) {
        nodes {
          base
          childImageSharp {
            gatsbyImageData(
              width: 1200
              placeholder: BLURRED
              formats: [AUTO, WEBP, AVIF]
            )
          }
        }
      }
    }
  `)

  const content = dataJSON.valbelluna as DataJSONType
  if (!content)
    return (
      <DefaultLayout>
        <T.H1>Contenuto non trovato!</T.H1>
      </DefaultLayout>
    )

  // Map metadata and image nodes
  const metadata = data.allImageMetadataJson.nodes
  const images = data.allFile.nodes

  // Match images to metadata using the fileName
  const filteredImages = metadata.map((meta: any) => {
    const image = images.find((img: any) => img.base === meta.fileName)
    return {
      ...meta,
      image: image ? getImage(image.childImageSharp) : null,
    }
  }) as ImageData[]

  return (
    <DefaultLayout>
      <ContentToComponent pageData={content} images={filteredImages} />
      <MobileContentToComponent pageData={content} images={filteredImages} />
    </DefaultLayout>
  )
}

export default NarcisiValbellunaPage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Progetto Narcisi - Valbelluna" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/narcisi/galleria.tsx
========================================

import { graphql, useStaticQuery, type HeadFC, type PageProps } from "gatsby"
import { getImage } from "gatsby-plugin-image"
import * as React from "react"
import Carousel from "../../components/carousel"
import DefaultLayout from "../../components/default-layout"
import { ImageData } from "../../types"

const NarcisiGalleriaPage: React.FC<PageProps> = () => {
  const data = useStaticQuery(graphql`
    query {
      allImageMetadataJson(filter: { tags: { in: ["narcisi"] } }) {
        nodes {
          title
          description
          fileName
          tags
          copyright
          alt
        }
      }
      allFile(filter: { sourceInstanceName: { eq: "images" } }) {
        nodes {
          base
          childImageSharp {
            gatsbyImageData(
              width: 1400
              placeholder: BLURRED
              formats: [AUTO, WEBP, AVIF]
            )
          }
        }
      }
    }
  `)

  // Map metadata and image nodes
  const metadata = data.allImageMetadataJson.nodes
  const images = data.allFile.nodes

  // Match images to metadata using the fileName
  const filteredImages = metadata.map((meta: any) => {
    const image = images.find((img: any) => img.base === meta.fileName)
    return {
      ...meta,
      ...image,
      image: image ? getImage(image.childImageSharp) : null,
    }
  }) as ImageData[]

  return (
    <DefaultLayout>
      <Carousel images={filteredImages} />
    </DefaultLayout>
  )
}

export default NarcisiGalleriaPage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Progetto Narcisi - Galleria" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/narcisi/index.tsx
========================================

import { graphql, useStaticQuery, type HeadFC, type PageProps } from "gatsby"
import { getImage } from "gatsby-plugin-image"
import * as React from "react"
import DefaultLayout from "../../components/default-layout"
import MobileContentToComponent from "../../components/mobile-pagedata-text-components"
import ContentToComponent from "../../components/pagedata-text-components"
import { DataJSONType, ImageData } from "../../types"
import * as T from "./../../components/typography"
import dataJSON from "../../../content/narcisi/index.json"
import ButtonLink from "../../components/button-link"

const NarcisiPage: React.FC<PageProps> = () => {
  const data = useStaticQuery(graphql`
    query {
      allImageMetadataJson(filter: { tags: { in: ["narcisi-main"] } }) {
        nodes {
          title
          description
          fileName
          tags
          copyright
          alt
        }
      }
      allFile(filter: { sourceInstanceName: { eq: "images" } }) {
        nodes {
          base
          childImageSharp {
            gatsbyImageData(
              width: 1200
              placeholder: BLURRED
              formats: [AUTO, WEBP, AVIF]
            )
          }
        }
      }
    }
  `)

  const content = dataJSON.index as DataJSONType
  if (!content)
    return (
      <DefaultLayout>
        <T.H1>Contenuto non trovato!</T.H1>
      </DefaultLayout>
    )

  // Map metadata and image nodes
  const metadata = data.allImageMetadataJson.nodes
  const images = data.allFile.nodes

  // Match images to metadata using the fileName
  const filteredImages = metadata.map((meta: any) => {
    const image = images.find((img: any) => img.base === meta.fileName)
    return {
      ...meta,
      image: image ? getImage(image.childImageSharp) : null,
    }
  }) as ImageData[]

  return (
    <DefaultLayout>
      <ContentToComponent pageData={content} images={filteredImages} />
      <MobileContentToComponent pageData={content} images={filteredImages} />
      <ButtonLink to="mappe" label="Vai a mappe!" />
    </DefaultLayout>
  )
}

export default NarcisiPage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Gruppo Natura Lentiai - Progetto Narcisi" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/narcisi/natura.tsx
========================================

import * as React from "react"
import type { HeadFC, PageProps } from "gatsby"
import DefaultLayout from "../../components/default-layout"
import WorkInProgress from "../../components/work-in-progress"

const NarcisiNaturaPage: React.FC<PageProps> = () => {
  return (
    <DefaultLayout>
      <WorkInProgress />
    </DefaultLayout>
  )
}

export default NarcisiNaturaPage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Progetto Narcisi - Natura" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/narcisi/mappe.tsx
========================================

import type { HeadFC, PageProps } from "gatsby"
import * as React from "react"
import AccessWarnings from "../../components/access-warnings"
import DefaultLayout from "../../components/default-layout"
import MapComponent from "../../components/map-narcisi"
import paths from "../../data/paths/narcisi"
import { Location } from "../../types"

const markersMap: Location[] = [
  {
    type: "park",
    iconType: "park",
    name: "Parcheggio",
    lat: 46.00797704443462,
    lon: 12.022993713170376,
  },
  {
    type: "daffodil",
    iconType: "daffodil",
    name: "Fioritura dei narcisi",
    lat: 46.01073603970253,
    lon: 12.025127478790541,
  },
  {
    type: "daffodil",
    iconType: "daffodil",
    name: "Fioritura dei narcisi",
    lat: 46.006950306310024,
    lon: 12.023120915478003,
  },
  {
    type: "daffodil",
    iconType: "daffodil",
    name: "Fioritura dei narcisi",
    lat: 46.00330147743768,
    lon: 12.019027555533151,
  },
  {
    type: "daffodil",
    iconType: "daffodil",
    name: "Fioritura dei narcisi",
    lat: 45.997452061901924,
    lon: 12.01622871715491,
  },
  {
    type: "daffodil",
    iconType: "daffodil",
    name: "Fioritura dei narcisi",
    lat: 45.99111388253593,
    lon: 12.012709597534387,
  },
]

const NarcisiMappePage: React.FC<PageProps> = () => {
  return (
    <DefaultLayout>
      <AccessWarnings type="narcisi" />
      <MapComponent markers={markersMap} paths={paths} />
    </DefaultLayout>
  )
}

export default NarcisiMappePage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Progetto Narcisi - Mappe" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/narcisi/storia.tsx
========================================

import * as React from "react"
import type { HeadFC, PageProps } from "gatsby"
import DefaultLayout from "../../components/default-layout"
import WorkInProgress from "../../components/work-in-progress"

const NarcisiStoriaPage: React.FC<PageProps> = () => {
  return (
    <DefaultLayout>
      <WorkInProgress />
    </DefaultLayout>
  )
}

export default NarcisiStoriaPage

import { SEO } from "../../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Progetto Narcisi - Storia" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/partecipa.tsx
========================================

import type { HeadFC, PageProps } from "gatsby"
import * as React from "react"
import DefaultLayout from "../components/default-layout"
import SustainUs from "../components/sustain-us"

const PartecipaPage: React.FC<PageProps> = () => {
  return (
    <DefaultLayout>
      <SustainUs />
    </DefaultLayout>
  )
}

export default PartecipaPage

import { SEO } from "../components/seo"

export const Head: HeadFC = ({ location }) => (
  <SEO title="Gruppo Natura Lentiai - Partecipa!" pathname={location.pathname} />
)
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/pages/blog.tsx
========================================

import { graphql, HeadFC, PageProps } from "gatsby"
import React, { useEffect, useMemo, useState } from "react"
import DefaultLayout from "../components/default-layout"
import { remoteGraphqlURL } from "../constants"
import { FeaturedBlog, PostInfo } from "../components/blog-list"
import { fromBodyRawToExcerpt } from "../helpers"
import { SEO } from "../components/seo"

// Definiamo il tipo per i dati che arrivano dalla query GraphQL di Gatsby
type BlogData = {
  allSanityPost: {
    nodes: Array<{
      id: string
      title: string
      publishedAt: string
      _rawBody: any
      author: string
      slug: { current: string }
      image: {
        asset: {
          description: string
          altText: string
          title: string
          gatsbyImageData: any
        }
      }
    }>
  }
}

const filterDummyPosts = (post: PostInfo) =>
  post.slug !== "/post/1" && post.slug !== "/post/2"

const sortByPublishedAt = (p1: PostInfo, p2: PostInfo) =>
  new Date(p1.publishedAt).getTime() - new Date(p2.publishedAt).getTime()

const Blog: React.FC<PageProps<BlogData>> = ({ data, location }) => {
  const isFromPost = (location.state as any)?.fromPost === true

  // Trasformiamo i dati statici di Gatsby nel formato PostInfo
  const staticPosts: PostInfo[] = useMemo(() => {
    return (data.allSanityPost.nodes || []).map(node => ({
      id: node.id,
      title: node.title,
      publishedAt: node.publishedAt,
      author: node.author,
      slug: node.slug.current,
      excerpt: fromBodyRawToExcerpt(node._rawBody),
      coverImage: {
        description: node.image?.asset?.description,
        altText: node.image?.asset?.altText,
        title: node.image?.asset?.title,
        gatsbyImage: node.image?.asset?.gatsbyImageData || null,
      },
    }))
  }, [data])

  const [posts, setPosts] = useState<PostInfo[]>(
    staticPosts.filter(filterDummyPosts).sort(sortByPublishedAt).reverse()
  )

  useEffect(() => {
    const fetchPosts = async () => {
      try {
        const query = `query {
          allPost {
            _id
            slug { current }
            title
            publishedAt
            bodyRaw
            author
            image {
              asset {
                description
                title
                altText
                url
              }
            }
          }
        }`

        const response = await fetch(remoteGraphqlURL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query }),
        })

        const result = await response.json()
        if (result.errors) throw new Error(result.errors[0].message)

        const remotePostsRaw = result.data?.allPost ?? []

        const remotePosts: PostInfo[] = remotePostsRaw.map((p: any) => ({
          id: p._id,
          title: p.title,
          publishedAt: p.publishedAt,
          author: p.author,
          slug: p.slug.current,
          excerpt: fromBodyRawToExcerpt(p.bodyRaw),
          coverImage: {
            description: p.image?.asset?.description,
            altText: p.image?.asset?.altText,
            title: p.image?.asset?.title,
            renderImageUrl: p.image?.asset?.url || null,
          },
        }))

        // Uniamo i post statici con quelli remoti (evitando duplicati)
        const combined = [...staticPosts]
        remotePosts.forEach(rp => {
          if (!combined.some(cp => cp.slug === rp.slug)) {
            combined.push(rp)
          }
        })

        setPosts(
          combined.filter(filterDummyPosts).sort(sortByPublishedAt).reverse()
        )
      } catch (err: any) {
        console.error("Errore nel fetch remoto, uso i dati statici:", err)
      }
    }

    fetchPosts()
  }, [staticPosts])

  return (
    <DefaultLayout>
      <FeaturedBlog posts={posts} isFromPost={isFromPost} />
    </DefaultLayout>
  )
}

// Questa query viene eseguita da Gatsby a tempo di build
export const query = graphql`
  query BlogPageQuery {
    allSanityPost(sort: { publishedAt: DESC }) {
      nodes {
        id
        title
        publishedAt
        _rawBody
        author
        slug {
          current
        }
        image {
          asset {
            description
            altText
            title
            gatsbyImageData(
              width: 800
              placeholder: BLURRED
              formats: [AUTO, WEBP, AVIF]
            )
          }
        }
      }
    }
  }
`

export default Blog

export const Head: HeadFC = ({ location }) => (
  <SEO title="Gruppo Natura Lentiai - Blog" pathname={location.pathname} />
)Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/constants.ts
========================================

export const remoteGraphqlURL =
  "https://ze02ljgl.api.sanity.io/v2023-08-01/graphql/post-blog/default" as const

// export const pathPrefix = "/Frontend" as const // old when hosted in https://grupponaturalentiai.github.io/Frontend
export const pathPrefix = "" // actual having bought the domain
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/styles/index.ts
========================================

export const breakpoint = {
  siteWidth: "1900px",
  verylarge: "1650px",
  large: "1400px",
  medium: "1150px",
  bigtablet: "900px",
  tablet: "768px",
  smalltablet: "600px",
  mobile: "480px",
} as const

export const breakpointNum = {
  siteWidth: 1900,
  verylarge: 1650,
  large: 1400,
  medium: 1150,
  bigtablet: 900,
  tablet: 768,
  smalltablet: 600,
  mobile: 480,
} as const

export const horizBreakpointsHeight = {
  medium: 600,
  thin: 400,
} as const

export const colors = {
  red: {
    warning: "#f60000",
  },
  green: {
    green50: "#f2f9ec",
    green100: "#e1f1d6",
    green200: "#c6e5b1",
    green300: "#a2d383",
    green400: "#80c05b",
    green500: "#62a43e",
    green550: "#329e31",
    green600: "#4a822e",
    green700: "#3a6427",
    green800: "#315123",
    green900: "#2c4522",
    green950: "#1e3815",
  },
  paths: {
    tomato: "#FE4A49",
    mustard: "#FED766",
    moonstone: "#009FB7",
    indigo: "#3A1772",
    liver: "#654236",
    orange: "#FF9030",
    green: "#446b34",
    yellow: "#FFD700",
  },
}
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./src/images.d.ts
========================================

// global.d.ts
declare module "*.png" {
  const value: string
  export default value
}

declare module "*.jpg" {
  const value: string
  export default value
}

declare module "*.jpeg" {
  const value: string
  export default value
}

declare module "*.svg" {
  const value: string
  export default value
}
Generated at Sun Feb 22 10:26:50 AM UTC 2026

========================================
FILE: ./gatsby-browser.tsx
========================================

import "leaflet/dist/leaflet.css"
import "normalize.css"

import * as React from "react"

// The `wrapRootElement` function wraps the root element of your Gatsby app with additional elements like context providers.
export const wrapRootElement = ({ element }: any) => {
  return <>{element}</>
}
